
Title:  OLE-container library for Dylan -- user description

Author: David N. Gray  <gray@harlequin.com>

Date:	October 1, 1998 - initial version
        October 5, 1998 - minor updates

Status: This describes what is currently implemented, but it is
	preliminary and likely to change before the design is finalized.
	There is enough functionality here to support the initial example,
	but more features remain to be added.  Criticisms and suggestions
	are invited.

Copyright (c) 1998 Functional Objects, Inc.  All rights reserved.

Version: $HopeName: D-doc-lib!ole-container.text(trunk.2) $
         $Date: 2004/03/12 00:12:07 $

--------------


Introduction
------------

The "ole-container" library is for use by Dylan programs that use the Win32
API for their user interface and that want to support embedding of OLE
components as an OLE "compound document".  Knowledge of the low-level OLE
API is not required, although there are occasional references to low-level
names for the sake of a precise specification and for extensibility.
The reader is assumed to be acquainted with the basic concepts of Windows
programming. 

Applications using the "ole-container" library do not normally need to
directly use the "COM" or "OLE" libraries unless using low-level features
not documented here.


Concepts and terminology
------------------------

 [to be supplied]


Overview
--------

For storing state information used by the library, the program needs to
have a single "application object", and there will be a "document object"
for each embedded server.

The user needs to define a subclass of `<container-app>' and make an
instance when the program starts.  Slots of the subclass can be used for
whatever information the program wants to use for its own purposes.
`<container-app>' is a subclass of the COM interface class `<IUnknown>', so
the subclass needs to be defined by `define COM-interface' and the user
should call `AddRef' on the instance after making it, and call `Release' on
it just before the program exits.

So the main program for a container might look something like this:

  define COM-interface <my-application> ( <container-app> ) 
    slot ...
    ...
  end;

  define variable *app* :: false-or(<my-application>) = #f;

  define method main () => ()

     *app* := make(<my-application>, accel: LoadAccelerators(...));
     AddRef(*app*);

     ... // initialization - register window classes, etc.

    // Make the top-level window:
    *app*.container-frame-window := CreateWindow(...);

     ... // additional initialization - create other windows, etc.

     let msg :: <LPMSG> = make(<LPMSG>);
     // event loop:
     while( GetMessage(msg, $NULL-HWND, 0, 0) )
       unless ( container-handle-accelerators(*app*, msg) )
         TranslateMessage(msg);
         DispatchMessage(msg); 
       end unless;
     end while;

     Release(*app*);
  end main;

  main();

Note also that the application object needs to be given the handles of the
top-level frame window and its accelerator table, and note that the event
loop uses `container-handle-accelerators' instead of `TranslateAccelerator'
in order to handle any accelerator keys of an active in-place object.

If an application has more than one top-level window, each with its own
menu bar, and each of which is to be capable of acting as a container, then
the application will need to have a separate "application object" for each
of those top-level windows.  Thus, the "application object" might be more
accurately thought of as a "frame window object".

The `container-frame-window' could be left unspecified if the application
does not intend to provide any frame-level user interface support for
embedded objects (i.e., no menu bar, status bar, tool bar, or accelerators).

To embed another object into an application window, use one of the
`insert-...' functions provided by the library:

  insert-object-from-dialog    Lets user pick from a dialog box.
  insert-object-by-class       Create new object by class ID or prog ID.
  insert-object-from-file      Load object from a file.

Each of these takes as arguments the application object, the parent window
for the embedded window, and the position within that window.  They return
a document object (an instance of `<contained-object>') which is used to
represent and communicate with the server.

For processing requests from the embedded object, the container program
will probably need to define methods on the application class for functions
such as:

  container-host-names          to specify the name of the application
  container-insert-menus        for merging server menus into the menu bar
  container-set-border-space    to make room for the server's tool bar

For interacting with the embedded object, the container program calls
library functions such as:

  container-add-verbs         to add the object's verbs to the Edit menu.
  container-remove-verbs      to remove the objects's verbs from the menu.
  container-do-verb           to activate the object.
  container-UI-deactivate     to deactivate the object.
  document-in-place-active?   to ask if the object is active.
  paint-contained-document    to pass a $WM-PAINT message on to the object.
  container-activate-application  to pass on a $WM-ACTIVATEAPP message.
  close-doc-object            to close the embedded object.

For a complete example program, see directory
"~dylan/sources/app/win32-ole-container" or check out HOPE compound
"D-app-win32-ole-container".  See its "README.txt" file for an explanation.

The remainder of this document provides a detailed reference for each name
exported by the library.



Class reference
---------------

  <container-app>				Open Primary Class

    This is a subclass of `<IUnknown>'.  Each container application must
    define a subclass (using `define COM-interface') and create an instance
    of the subclass.  This instance will be used to hold various state
    information regarding the container application as a whole.  After
    creating the instance, call `AddRef' on it; call `Release' on it just
    before the program terminates.

    The available keyword options for `make' are:

      window-handle:  The window handle (instance of `<HWND>') for the
                      application's top-level frame window.  If not
                      specified here, it should be specified by calling
                      `container-frame-window-setter', unless the
		      application does not intend to provide any support
		      for objects in the UI-active state.

      accel:          The application's accelerator table (an instance of
		      `<HACCEL>', such as returned by the Win32 functions
		      `LoadAccelerators' or `CreateAcceleratorTable').
		      Defaults to a null handle, meaning no accelerator
		      keys.

      palette:        The color palette (instance of `<HPALETTE>') to be
                      used by the container application.  A null pointer
                      may be passed to specify not using a palette.  If
                      this option is not specified, the library will create
                      a default palette.  The specified palette will be
                      destroyed when the application object is terminated.
 
  <contained-object>				Open Primary Class

    This is a subclass of `<IUnknown>'.  When one of the `insert-...'
    functions is used to embed an OLE server in the container, it will
    return an instance of this class.  This instance is used to hold
    various state information regarding the embedded object.  The
    application may call function `close-doc-object' to close the embedded
    object, or else it will be closed automatically when the application
    object is released.

    If the application needs to obtain greater control by overriding some
    of the library's methods on `<contained-object>', it can use `define
    COM-interface' to define a subclass and add a method on
    `container-document-class' to specify the subclass to be instantiated.


Functions for the application to call
-------------------------------------

The following functions, listed in alphabetical order, are exported from
the `ole-container' module and may be called by the container
application.


  close-doc-object (obj :: <contained-object>, #key save? = #t) => ()

    This may be called to terminate an embedded server.  Use `save?: #t' to
    save the document to storage before closing, such as when exiting the
    application.  Use `save?: #f' to delete the document's storage, such as
    when deleting an object from the compound document.

    This will terminate the instance of `<contained-object>', so it should
    not be used again after this call.
 
  container-UI-deactivate (obj :: <contained-object>) => ()

    Call this method to change a server from the "UI active" state to just
    the "active" state by invoking the server's
    `IOleInPlaceObject/UIDeactivate' method.  This will remove any
    frame-level menus or tool bars belonging to the object.  Typically this
    will be called when the user clicks the mouse outside of the active
    object.  If the server is not in-place active, this call has no effect.

  container-UI-deactivate (app :: <container-app>) => ()

    This method may be called to deactivate the user interface of all
    in-place active objects, if any.

  container-accelerator-table (app :: <container-app>) => (accel :: <HACCEL>)

    Returns the container's keyboard accelerator table handle.

  container-accelerator-table-setter (accel :: <HACCEL>, 
				      app :: <container-app>)

    Sets the accelerator table handle that will be used by
    `container-handle-accelerators'.   Use this if key bindings change
    during execution.

  container-activate-application (app :: <container-app>,
                                   active? :: <boolean>)  => ()

    Call this when the application window receives a `$WM-ACTIVATEAPP'
    message.  It informs any active servers by invoking their 
    `IOleInPlaceActiveObject/OnFrameWindowActivate' method.  The second
    argument is `#t' when the application is being activated, or `#f' when
    it is being deactivated.  When the application is becoming active, this
    function also calls `container-query-new-palette'.

  container-add-verbs (obj :: <contained-object>, edit-menu :: <HMENU>,
                       command-code :: <integer>,
                     #key max-command :: <integer>, name :: <string>
			  convert :: <integer>)
               => (modified? :: <boolean>, cascade-menu :: <HMENU>)

    Call this to add the embedded object's verbs (such as "Edit", "Open",
    or "Play") to the container application's Edit menu.  These additional
    menu items can be used to activate an inactive object.  The arguments
    are the document object, the handle of the menu to be modified, and a
    command code offset; this is the value that will be passed to the
    application in a `$WM-COMMAND' message when the first verb's menu item
    is invoked.  If the object supports multiple verbs, they will be given
    sequential command numbers following this one.

    The optional keyword arguments are:

      max-command:     The maximum command code allowed.  If not specified,
                       no limit will be enforced.

      name:            The name of the object that will be shown in the
                       menu item.  If not specified, the object's "short
                       name" recorded in the System Registry will be used.

      convert:         If specified, a "Convert" menu item will be created
                       in addition to those for the object's verbs; the
                       value is the command code that will be returned if
                       it is invoked.

    The first return value is true if an item has been added to the menu
    (either in this call or when already done in a previous call), or false
    if the menu has not been altered because the object is already active
    or this operation is not applicable.

    If the object supports more than one verb, the added menu item will
    invoke a cascading sub-menu listing the verbs; this cascading menu is
    returned as the second value.  The second value will be a null handle
    if a cascading menu is not used.

    The function `container-remove-verbs' can be used to remove the added
    menu item, or it will be removed automatically when the object is
    closed (such as by `close-doc-object').  The caller does not ordinarily
    need to use or remember the values returned by `container-add-verbs',
    since the object automatically remembers them for use by
    `container-remove-verbs'.

    See also function `container-do-verb', which the application should
    call when it receives one of the verb commands.

  container-context-help (app :: <container-app>) => (do-help? :: <boolean>)

    Call this when a `$WM-COMMAND' message is received.  If the program is
    in context-sensitive help mode, it updates the help state of any
    embedded servers and returns `#t'; otherwise it returns `#f'.

    [Issue: support for context-sensitive help is incomplete; this function
    may need additional arguments.]

  container-destroy-documents (app :: <container-app>) => ()

    Calls `close-doc-object' on each embedded object.  You might want to
    call this before the application exits, or it will be called
    automatically in the application's `terminate' method.

  container-documents (app :: <container-app>) => (documents :: <sequence>)

    Returns a `<sequence>' whose elements are the current instances of
    `<contained-object>'.  This can be used to iterate over all of the
    embedded servers.

  container-do-verb (obj :: <contained-object>, verb :: <integer>,
                     message :: <LPMSG>)
               => (status :: <HRESULT>)

    This should be called when the application receives a `$WM-COMMAND'
    message corresponding to one of the menu entries added by the function
    `container-add-verbs'.  It invokes the server's `IOleObject/DoVerb'
    method to perform the appropriate action, and returns the status code
    that it reports.  The verb number is the command number
    (`LOWORD(wParam)') minus the command offset that was passed to
    `container-add-verbs'.

    This can also be called as a means of directly activating the object.
    For example, if the user double-clicks on an inactive object, a
    container will typically activate the object by calling this function
    with verb `$OLEIVERB-PRIMARY'.  Other standard verbs that can be
    invoked directly include:  $OLEIVERB-SHOW, $OLEIVERB-OPEN,
    $OLEIVERB-HIDE, $OLEIVERB-UIACTIVATE, $OLEIVERB-INPLACEACTIVATE, and
    $OLEIVERB-DISCARDUNDOSTATE .

    The last argument is the window message that instigated the action; it
    may be a NULL pointer if not relevant.  This might be useful to a
    server that wants to know what user gesture caused it to be activated,
    but it is never required.

  container-frame-window (app :: <container-app>) => (window :: <HWND>)

    Returns the handle of the application's top-level frame window.

  container-frame-window-setter (window :: <HWND>, app :: <container-app>)

    Specifies the handle of the application's top-level frame window.

  container-handle-accelerators (app :: <container-app>, message :: <LPMSG>)
		=> (handled? :: <boolean>)

    Call this in the application's event loop to see if a window message is
    an accelerator key.  The return value is `#t' if the message was an
    accelerator key that has been processed, or `#f' if `TranslateMessage'
    and `DispatchMessage' should be called to process the message.  Use
    this instead of `TranslateAccelerator' so that accelerators belonging
    to either an embedded object or the container application are handled
    correctly.  This function uses the container's accelerator table that
    was specified as the `accel:' option when making the application
    object, or set later by `container-accelerator-table-setter'.

  container-palette-changed (app :: <container-app>, app-window :: <HWND>,
				  wParam, lParam)
		=> (handled? :: <boolean>)

    Call this when a `$WM-PALETTECHANGED' message is received. It sets the
    background palette for the frame window (using the `palette:' option of
    `<container-app>') and forwards the message to all embedded objects
    that are in-place active.

    The second, third, and fourth arguments pass along the arguments
    received by the window function.

  container-remove-verbs (obj :: <contained-object>) => ()

    Call this to remove any menu entry that may have been added by a call
    to `container-remove-verbs' for this object.  It has no effect if there
    is no such menu entry.  This will be called automatically when the
    object is closed.

  container-query-new-palette (app :: <container-app>) => (value :: <integer>)

    Call this when a `$WM-QUERYNEWPALETTE' message is received.  If there
    is a UI-active embedded object, it is given the chance to select its
    palette.  Otherwise, the container application's palette is used (see
    the `palette:' option of `<container-app>').

    The return value is 1 if a palette was selected; else 0.

  container-size-changed (obj :: <contained-object>, rectangle :: <LPRECT>)
		=> ()

    Call this when the application frame window receives a `$WM-SIZE'
    message.  The second argument passes the new size of the window;
    typically it is filled in by calling `GetClientRect' on the window.
    For any in-place UI active object, this information will be passed
    along in a call to its `IOleInPlaceActiveObject/ResizeBorder' method.

  document-class-id (obj :: <contained-object>) => (class-ID :: <REFCLSID>)

    Returns the server's class ID.  This might be a null pointer if a
    server invoked from a file fails to identify itself.

  document-edges (obj :: <contained-object>)
		=> (left :: <integer>, top :: <integer>,
		    right :: <integer>, bottom :: <integer>)

    This can be called to return the position (in pixels) of the embedded
    object within the containing window.

  document-file-name (obj :: <contained-object>)
		=> (file :: false-or(<string>))

    If the server was created from a file, returns the pathname of that
    file.  Otherwise returns `#f'.

  document-in-place-active? (obj :: <contained-object>)
		=> (active? :: <boolean>)

    Call this to find out whether the server is currently in-place active.

  document-move (obj :: <contained-object>, x :: <integer>, y :: <integer>)
		=> ()

    Call this to change the position of an embedded document within its
    container window.  The new offset is given in pixels.  If the specified
    position is different from the current position, the server's
    `IOleInPlaceObject/SetObjectRects' method will be invoked.

  document-olemisc (obj :: <contained-object>) => (olemisc :: <integer>)

    Returns an integer which is the `logior' of a group of constants
    representing various attributes of the server.  For example, the
    application does not need to UI activate a server for which the
    following expression is true:

      ~ zero?(logand(obj.document-olemisc, $OLEMISC-NOUIACTIVATE))

    Values that might be relevant or useful include:

	    $OLEMISC-INSIDEOUT
	    Activate in-place, without any menus or tool bar.  More
	    than one such control can be active at the same time.

	    $OLEMISC-ACTIVATEWHENVISIBLE 
	    Requests that the container always make this control active
	    whenever it is visible.  Requires $OLEMISC-INSIDEOUT also.

	    $OLEMISC-ACTSLIKEBUTTON
	    The control behaves as a button.

	    $OLEMISC-ACTSLIKELABEL
	    The control acts as a label for the control following it in
	    the form.

	    $OLEMISC-NOUIACTIVATE
	    Control without any user interface.  It has no menu, no
	    accelerators, does not need to be activated, and never
	    needs the focus.

	    $OLEMISC-INVISIBLEATRUNTIME
	    The control has no run time user interface but should be
	    visible at design time.

	    $OLEMISC-STATIC
	    A static object, containing only a presentation without any
	    native data.

    Refer to the Microsoft OLE documentation for additional values and
    further details.

  document-open-out-of-place? (obj :: <contained-object>)
		=> (open? :: <boolean>)

    Returns true if the object is currently opened as a separate top-level
    window; in other words, if it is active not in-place.

  document-rectangle (obj :: <contained-object>, rectangle :: <LPRECT>) => ()

    This can be called to fill in a Windows RECT struct with the size and
    position (in pixels) of the embedded object within the container
    window.  This may be of use for passing on to some Win32 API functions.
    For example, the rectangle could be passed to `PtInRect' to test
    whether a mouse click is within the area of the embedded object.
    See also `document-edges' which returns the same values more directly.

  document-ui-active-window (obj :: <contained-object>) => (window :: <HWND>)

    This function returns the window handle of an embedded object that is
    in-place UI active.  A null handle (test with `null-handle?') will be
    returned if the object is not currently UI active.

  get-server-name (obj :: <contained-object>, which :: <integer>)
		=> (name :: <string>)

    Asks the server for an identifying string.  The second argument must be
    one of the following constants to select the kind of name desired:

      $USERCLASSTYPE-FULL     - The full name of the kind of object.
      $USERCLASSTYPE-SHORT    - The short name of the kind of object 
				(maximum of 15 characters), suitable for
				pop-up menus and the Links dialog box.
      $USERCLASSTYPE-APPNAME  - The name of the application.

    For example, for Microsoft Paintbrush, the full and short names are
    "Bitmap Image", while the application name is "Paint".

  insert-object-by-class (app :: <container-app>, window :: <HWND>,
                          ID :: type-union(<REFCLSID>,<string>),
                         #key x, y, document-name, aspect,
			  render, format-etc, doc-class)
                => (obj :: <contained-object>)

    Creates a new embedded object by initiating a server for a specified
    class ID or prog ID.  An instance of `<ole-error>' will be signaled if
    the server cannot be started; otherwise, an instance of
    `<contained-object>' will be created and returned.  The embedded object
    will be placed in the designated window at offset x,y (default 0,0).

    For example, the Microsoft Paintbrush utility can be embedded by
    calling this function with the ID argument being either
    "{0003000a-0000-0000-C000-000000000046}" (the class ID) or "PBrush"
    (the prog ID).

    The meanings of the optional keyword arguments are the same as for the
    `insert-object-from-dialog' function below, although not all apply
    here.

  insert-object-from-dialog (app :: <container-app>, window :: <HWND>,
                             #key x, y, title, failure-title, flags,
                             document-name, exclude, 
			     aspect, render, format-etc,
			     hook-function, hook-data, doc-class)
                 => (doc :: false-or(<contained-object>))

    Call this function to embed an object chosen by the user from a dialog
    box.  This would typically be used to implement a menu command for
    "Edit -> Insert Object ...".  The dialog box provides a list of all OLE
    embeddable document servers currently registered on the user's
    computer.  The only required arguments are the application object and
    the window that will serve as the parent for the embedded object.
    (This is not the frame window, but some child of it, directly or
    indirectly.)  If an error occurs while trying to start the chosen
    server, the error will be reported to the user in another dialog box
    and the function will return `#f'.  The function will also return `#f'
    if the user presses the "Cancel" button in the dialog box.  Otherwise,
    when a server has been successfully started, an instance of
    `<contained-object>' will be returned that represents it.  The
    functions `get-server-name', `document-class-id', or
    `document-file-name' may be used to find out what the user selected.

    The optional keyword arguments are as follows.  All but the first few
    represent low-level details and are unlikely to be needed, so don't
    worry if you don't understand them.

      x:
		An <integer> specifying the number of pixels offset from
                the left side of the specified parent window to the left
                side of the new embedded window.  Defaults to 0.
      y:
		An <integer> specifying the number of pixels offset from
                the top of the specified parent window to the top of the
                new embedded window.  Defaults to 0.
      document-name:
		A <string> which is the name of the compound document in
		which the object is being embedded, or `#f' if not
		applicable.  If provided, this will be passed to the
		server's `IOleObject/SetHostNames' method.  This
		information is not essential, and many servers do not use
		it.  Alternatively, if the container only implements a
		single document, the name can be specified as the second
		value returned from the application's
		`container-host-names' method instead of being specified
		for each embedded object.
      title:
		A <string> to be displayed in the title bar of the dialog
                box.  Defaults to "Insert Object".
      failure-title:
		A <string> to be displayed in the title bar of the error
                reporting dialog box, if one is used.  Defaults to
                "Insertion failure".
      doc-class:
		A <class> which will be instantiated as the return value.
                It must be a subclass of `<contained-object>'.  The default
		is to use the value returned by the function
                `container-document-class', whose default method just
                returns `<contained-object>' itself.
      exclude:
		A <sequence> of class IDs (each represented as either a
		<string> or <REFCLSID>) designating servers to be excluded
		from the list of choices offered to the user.  The default
		value is an empty sequence.
      flags:
		An <integer> value which is the `logior' of some constants
                which specify various options for the dialog box.
		The default value is:
                  logior($IOF-SELECTCREATENEW, $IOF-DISABLELINK,
			 $IOF-DISABLEDISPLAYASICON,
			 $IOF-CREATENEWOBJECT, $IOF-CREATEFILEOBJECT)
		See the Microsoft documentation for the `OLEUIINSERTOBJECT'
                structure for the available flags and their meanings.
      aspect: 
		An <integer> value which defaults to `$DVASPECT-CONTENT',
		meaning that the object will be displayed in its normal
		full representation.  Other possible values are:
		  $DVASPECT-THUMBNAIL  thumbnail representation
		  $DVASPECT-ICON       iconic representation
		  $DVASPECT-DOCPRINT   print preview representation
      render:
                Defaults to `$OLERENDER-DRAW'.  See the Microsoft
                documentation for the `OLERENDER' enumeration for other
                possibilities and their meanings.
      format-etc:
		A pointer of type `<LPFORMATETC>'; defaults to
                `null-pointer(<LPFORMATETC>)'.  See the Microsoft
                documentation for function `OleCreate' for how this is used.
      hook-function:
		If specified, this is a `<C-function-pointer>' that will be
                used as the message processing function for the dialog box,
                to enable customizing the behavior.  The default is to have
                no hook function.
      hook-data:
		If a `hook-function:' is specified, this option may be
                given an <integer> or <machine-word> value that will be
                passed as an additional argument to the hook function.


  insert-object-from-file (app :: <container-app>, window :: <HWND>,
                           file-name :: <string>,
                          #key x, y, document-name, aspect,
			   render, format-etc, doc-class)
                => (obj :: <contained-object>)

    Creates a new embedded object by initiating a server appropriate to
    edit the specified file.  An instance of `<ole-error>' will be signaled
    if the server cannot be started; otherwise, an instance of
    `<contained-object>' will be created and returned.  The embedded object
    will be placed in the designated window at offset x,y (default 0,0).

    For example, if the file name has a ".BMP" suffix, the Microsoft
    Paintbrush utility will be invoked to display the contents of the file.

    The meanings of the optional keyword arguments are the same as for the
    `insert-object-from-dialog' function above, although not all apply
    here.

  paint-contained-document (obj :: <contained-object>, hDC :: <HDC>) => ()

    Call this to cause an embedded object to re-draw itself into a given
    device context.  This will typically be done when the containing window
    receives a `$WM-PAINT' message.  

    The function invokes the server's `IViewObject::Draw' method as well as
    performing some additional bookkeeping such as managing the color
    palette.



Functions for the application to specialize
-------------------------------------------

The container application should usually add a method to the following
functions, specialized on the application's subclass of
`<container-app>'.
 
  container-host-names (app :: <container-app>)
		=> (application-name :: false-or(<string>,
                    document-name :: false-or(<string>)		[Open GF]

    Returns the name of the container application program (or `#f' if not
    applicable) and the name of the document (or `#f' if not applicable). 
    The default method returns `values(#f, #f)'.

    These names will be passed to a server's `IOleObject/SetHostNames'
    method for the server's information.

    If an embedded object is created with a string specified for the
    `document-name:' option, that string will override the one specified
    here.  Thus, the document name can be specified by this method if
    the application supports only one document, or passed to each
    `insert-...' call in the case of multiple documents.

    It is common for servers that implement out-of-place activation to
    alter their "Exit" menu item to say "Exit and return to foo" where
    "foo" is the container document name.  So even if the concept of a
    document name does not seem relevant, the container should still
    provide something there so that the menu item doesn't just say "Exit
    and return to".

  container-insert-menus (app :: <container-app>, shared-menu :: <HMENU>) 
	=> (n-file :: <integer>, n-edit :: <integer>, n-help :: <integer>)
								[Open GF]

    This function sets up the menu bar that is shared by the container
    application and an in-place UI active object by filling in the menus
    belonging to the container.  The application's method should call the
    Win32 function `AppendMenu' to add each of the menus that are to appear
    while an embedded object is active, and return the number of menus
    added.  Actually three numbers are returned, for the number of menus in
    each of three groups: file, edit, and help.  The default method does
    nothing and returns `values(0,0,0)'.

    For example, a method to insert just a single "File" menu might look
    like this:

	define method container-insert-menus(app :: <my-application>,
					     shared-menu :: <HMENU>)
	    => (nf :: <integer>, ne :: <integer>, nh :: <integer>)
	  AppendMenu(shared-menu, logior($MF-BYPOSITION, $MF-POPUP),
		     pointer-address(app.my-file-menu-handle),
	             TEXT("&File"));
	  values(1, 0, 0)
	end method;

    After this function intializes the menu bar, the server will be asked
    to insert its menus.

  container-request-border-space (app :: <container-app>,
	left-space :: <integer>, top-space :: <integer>,
	right-space :: <integer>, bottom-space :: <integer>)
	=> (ok? :: <boolean>)					[Open GF]

    This function is called when a server asks whether it can display its
    own tool bar(s) in the container frame.  The arguments are the number
    of pixels desired at the left, top, right, and bottom sides of the
    frame.  The function returns true if the container is able to make that
    space available, or false to deny the request.  Note that this function
    just asks whether it is possible to obtain the space; the container
    does not actually re-arrange its windows to make the space available
    until `container-set-border-space' is called.

    The default method returns true unless the request would use more than
    half of the frame size either vertically or horizontally.

  container-release-border-space (app :: <container-app>) => ()	[Open GF]

    This function is called to undo the effect of
    `container-set-border-space' (see below).  The container should
    re-adjust its windows to reclaim any space previously used by the
    server's tool bar(s) and restore its own tool bar(s), if any.

    The default method calls `container-set-border-space(app,0,0,0,0)',
    which is probably sufficient for a container that does not have any
    tool bar of its own.  Container applications that do have a tool bar
    will need to provide an override method.

  container-set-border-space (app :: <container-app>,
	left-space :: <integer>, top-space :: <integer>,
	right-space :: <integer>, bottom-space :: <integer>)
	=> (done? :: <boolean>)					[Open GF]

    This function is called when a server wants the container to make room
    for it to display its own tool bar(s) in the container frame.  The
    arguments are the number of pixels needed at the left, top, right, and
    bottom sides of the frame.  If possible, the function should remove any
    tool bars belonging to the container and adjust the size and position
    of the application's windows so that the requested space is vacant for
    the server to use, and return `#t'.  If that is not possible, the
    function should return `#f'.

    If all four numbers are 0, this means that the server does not need any
    tool bar space, but the container should still remove any tool bars of
    its own.

    The default method always returns `#f', which has the effect that
    no server status bars will displayed.

    Note the related function `container-release-border-space' (see above)
    which will be called to restore the previous configuration.

  container-set-status-text (app :: <container-app>, text :: <string>)
	 => (status :: <HRESULT>)				[Open GF]

    If the container application implements a status bar, it should provide
    a method on this function that will display the given string in the
    status bar, or erase the status bar if the string is empty.

    The string received will actually be an instance of `<LPOLESTR>' (an
    alias of `<C-unicode-string>'), not a `<byte-string>'.  It is suitable
    for passing directly to the "Win32-GDI" function `TextOutW', but some
    implementations may need to use `as' to convert to the desired type.
    Also, the received string object is only valid for the duration of the
    call, so the method should make a copy if it wants to remember it for
    later use.

    The value returned should be one of the following status codes:

	  $S-OK		-- whole text successfully displayed.
	  $S-TRUNCATED	-- displayed part of message too long to fit.
	  $E-FAIL	-- container does not support a status bar.

    The default method does nothing and returns `$E-FAIL'.

    This implements the OLE function `IOleInPlaceFrame/SetStatusText'.  If
    the embedded object is not in-place active, the library will return
    status code `$OLE-E-NOT-INPLACEACTIVE' to the server instead of calling
    this function.



Additional open generic functions
---------------------------------

Following (in alphabetical order) are some more generic functions which
the application may add methods to if desired, but won't usually need to.

  container-add-frame-ui (app :: <container-app>) => ()		[Open GF]

    This function is called when a server leaves the UI-active state; its
    purpose is to restore the container's own user interface.  The default
    method calls `IOleInPlaceFrame/SetMenu' to restore the menu bar and
    `container-release-border-space' to restore the tool bar.  Applications
    are unlikely to need to change this behavior but may want to add a
    method that calls `next-method()' in order to add additional
    bookkeeping.

  container-document-class (app :: <container-app>) => (class :: <class>)
								[Open GF]
    Returns the default class that will be be instantiated by the
    `insert-...' functions.  The default method returns
    `<contained-object>'.  If the application defines its own subclass of
    `<contained-object>', it should define a method on this function that
    returns that subclass.

  container-main-menu (app :: <container-app>) => (menu :: <HMENU>) [Open GF] 

    This function is called to obtain the menu that is to be used as the
    container's menu bar after a server leaves the UI active state.  The
    default method simply returns the same menu that was being used before
    the UI active state was entered. Usually that will be the right thing,
    but it is possible that an application might want to override this if
    it wanted to recompute the menu.
 
  note-active-object-name (app :: <container-app>, name :: <string>) => ()
								[Open GF]
    When a server becomes UI active, if it specifies a document name in its
    call to `IOleInPlaceUIWindow/SetActiveObject', then this function will
    be called to pass on that name.  It is called again with an empty
    string when the activation is ended.  The default method does nothing.
    A container could add a method that would incorporate the name into the
    title bar, but that is not encouraged.

  note-data-change (app :: <container-app>, obj :: <contained-object>,
	            format :: <FORMATETC>, medium :: <STGMEDIUM>) => ()
								[Open GF]
    This function is called by `IAdviseSink/OnDataChange' when the server
    reports that there has been a change in its persistent data.  The
    default method does nothing.

  note-document-close (app :: <container-app>, obj :: <contained-object>) => ()
								[Open GF]
    This function is called by `IAdviseSink/OnClose'.
    The default method does nothing.

  note-document-save (app :: <container-app>, obj :: <contained-object>) => ()
								[Open GF]
    This function is called by `IAdviseSink/OnSave'.
    The default method does nothing.

  note-enable-modeless (app :: <container-app>, enable? :: <boolean>) => ()
								[Open GF]

    Applications that have any modeless dialog boxes should provide a
    method on this function.  When called with a second argument of `#f',
    any modeless dialog boxes that are currently being displayed should be
    disabled because an embedded server is displaying a modal dialog.  When
    called with a second argument of `#t', any dialog boxes can be
    re-enabled.  The default method does nothing.

  note-view-change (app :: <container-app>, obj :: <contained-object>,
	            aspect :: <integer>) => ()			[Open GF]

    This function is called by `IAdviseSink/OnViewChange' when the server
    reports a change in its visual presentation.  The default method calls
    `InvalidateRect' to force a re-paint of the containing window if the
    modified aspect is the one being displayed.

  terminate (obj :: <IUnknown>)					[Open GF]

    For the application's subclasses of `<container-app>' and
    `<contained-object>' (if any), the application may define a method on
    `terminate' which will be called to perform any necessary cleanup when
    the use of the object is ended.  Be sure to call `next-method()'
    because the default method does some important work.



Access to lower-level
---------------------

The following functions are provided to allow access to the low-level
OLE API.  Containers are not required to use these, but they are available
to allow access to additional features not supported by the library.

  document-ole-object (obj :: <contained-object>)
	=> (interface :: <LPOLEOBJECT>)

    This function returns the server's IOleObject interface pointer.  This
    is just a slot accessor, it does not call `AddRef' on the returned
    value.  The pointer will be null during initialization and termination
    of the `<contained-object>' instance.  When not null, you could call
    `QueryInterface' on this to obtain other interfaces implemented by the
    server.

  document-in-place-ole-object (obj :: <contained-object>)
	=> (interface :: <LPOLEINPLACEOBJECT>)

    This function returns the server's IOleInPlaceObject interface pointer.
    This is just a slot accessor, it does not call `AddRef' on the returned
    value.  The pointer will be null if the object is not currently
    in-place active.

[more to be supplied]



Issues
------

While the functionality presented above is sufficient to be usable for
simple containers, there are a number of features that are missing or
incomplete.  These include:

 * Implementation of persistent storage is incomplete.
 * The handling of window resizing needs more consideration.
 * Doesn't support changing the aspect (e.g. to iconize an embedded
   object).
 * Doesn't yet support linked (as opposed to embedded) objects.
 * Support for context-sensitive help is incomplete.
 * May need more work for supporting multiple objects that are all
   in-place active but not UI-active.
 * More thought needs to be given to supporting extensibility through
   access to the low-level API.
 * Should support applications that can be used as either a container or
   server or both.
 * Doesn't yet support Undo state.
 * Support for Advise notifications is incomplete.
 * Some additional details would need to be considered in order to
   support MDI applications.

We might want to come up with a better naming convention.  Would it help
to have the names distinguish functions called by the application from
functions implemented by the application?

Additional libraries (not yet specified) will need to be provided for
supporting OLE/ActiveX Control containers and containers using DUIM.

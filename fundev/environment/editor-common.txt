DYLAN EDITOR-COMMON LIBRARY SPECIFICATION


* Introduction

 Author(s): Hugh Greene (also Jason Trenouth, Andrew Armstrong)
 Keywords: editor, editor-manager, external, IPC, backend, back-end
 Potential users: Only Dylan group members
 Date of last revision: 1997/05/23

This library provides a facility for sending commands (from a fixed set)
to (external) editor processes.  It is intended mainly to be used by the
Functional Developer development environment, but could be used by other
projects.

This library is somewhat misnamed.  It was originally to form the centre
of means to control external editors from the environment _and_
vice-versa.  However, controlling the environment from outside turned
out to require a similar but separate library (environment-server), so
only the "call-out" half of the functionality is provided by this
library.

Given the example usage below, most users of this library will have
little need to read any more than the design section, except for
information on the classes of condition which may be signalled and how
they are to be handled.


* Editor-common library design

** Library usage

This library provides the core of the "call-out" mechanism, without
supporting any particular editors. Instead, a number of "backend"
libraries use this one and extend some of its generic functions and
classes, as well as adding objects to tables within this library.

Libraries wishing to make use of this call-out facility should use a
number of these backend libraries in addition to the editor-common
library. (The editor-manager library is an example of this, for use by
the the Functional Developer development environment.  It re-exports all the
modules exported by editor-common.)

Note: It is possible that this library will be redesigned to have the
separate backends dynamically loaded, so that (a) support for unused
editors can be omitted, to save memory; and/or (b) support for more
editors can be shipped and installed easily after the main product is
released. However, this would require more compiler support and may not
prove to be neccessary.


*** Example usage

  // In the library and module definition file:
  define library my-project
    use dylan; // and others ...

    // Either
    use editor-common;
    use editor-gnuserv-backend; // and/or others ...
    // or
    use editor-manager;
  end library;

  define module my-project
    use dylan; // and others ...

    // Either
    use editor-common;
    // or
    use editor-manager;
  end module;


  // Within module "my-project":
  define method my-method ...
    // To get a list of names of available editor backends:
    let names = editor-factory-names();
    // Optional: to change the default editor backend for calls:
    editor-default-factory-name() := #"deuce";
    // To send a command to an editor:
    editor-call
      (#"show-location",
       file-name: "/u/dylan/lib/my-project/my-project.dylan",
       from-line: 163);
    // ...
  end method;

Other keywords which may be passed to EDITOR-CALL include "from-col:",
"to-line:" and "to-col:".  See the second subsection below for more
details.


** Library ontology

The EDITOR-CALL funtion is the main interface for clients of this
library.  It accepts a symbol naming the command to be sent, and a
number of keyword arguments, generally providing arguments to that
command.  (These arguments are handled in terms of <EDITOR-VARIABLE>s --
see the second subsection below for details.)  This function then calls
a series of generic functions in a fixed protocol, for which methods are
supplied for various types of editor.

The type of editor to which the command will be sent (the "editor
back-end") is goverened by the EDITOR-DEFAULT-FACTORY-NAME(), which may
be got and set as if it were a module variable (see the example above).
A list of acceptable values for setting this to can be got by calling
EDITOR-FACTORY-NAMES; this list may differ between platforms.  Setting
it to a value which is not one of these names will not cause an error,
but later calls to EDITOR-DEFAULT-FACTORY-NAME will return #F, and calls
to EDITOR-CALL will signal an <EDITOR-ERROR-FACTORY-UNAVAILABLE> (until
the default factory name is set to an accepted name).

See the next section for a description of the currently available
commands and the section after that for details of the arguments
accepted by various commands.


*** Editor commands

Some commands may re-use windows, if the backend supports it.  (For
details of which backends do, see the file "D-doc-environment!
editor-backends.txt".)

Any call of a command may raise certain <CONDITION>s, described in the
reference section.  Some are <WARNING>s, but all _must_ be handled by
handlers which do not attempt to return.  (In the future, a recovery
protocol may be added for <EDITOR-WARNING-COMMAND-FAILED>.)


#"OPEN-EDITOR"						  Editor command

  Arguments:		none

  May re-use windows?:	Yes

  Meaning:
    Open an editor window, not necessarily displaying any file or
    buffer.


#"SHOW-LOCATION"					  Editor command

  Arguments:		file-name:, from-line:, from-col:,
			to-line:, to-col:

  May re-use windows?:	Yes

  Meaning:
    Display the file specified by 'file-name:' in an editor window.
    Move the editor's cursor to line 'from-line:' and column
    'from-col:'.  Highlight from the cursor to line 'to-line:' and
    column 'to-col:'.


*** Editor command arguments

The "keyword form" is used to pass in a value to EDITOR-CALL, as shown
above.  The "value type" heading indicates the type of object which
should be passed in with the keyword.

The corresponding <SYMBOL> form (prefixed with '$', so #"$from-line"
corresponds to from-line:) will by default be used as the key with
<EDITOR-TABLE-BASED-COMMANDS>. 

The "string form" will be replaced with the value (coerced to a <STRING>
usign AS) within <EDITOR-STRING-BASED-COMMANDS>, after variable
substitution.  (Less importantly for users, the "symbol form" (prefixed
with '$', so #"$from-line" corresponds to from-line:) will by default be
used as the key with <EDITOR-TABLE-BASED-COMMANDS>.)



FILE-NAME					 Editor command argument

  Keyword form:		file-name:

  String form:		$file-name

  Value type:		<string>

  Default value:	""

  Meaning:
    This argument specifies the name of a file on which the command is
    to act.  The format of the string will depend on the platform's file
    name format.


FROM-LINE, FROM-COL				 Editor command argument

  Keyword form:		from-line:, from-col:

  String form:		$from-line, $from-col

  Value type:		<integer>

  Default value:	0

  Meaning:
    Together, these two arguments specify a "start" position in a file.
    The caller assumes that 0 indicates the first line in a file; some
    editor backends might have to, say, add 1 to the value if the
    corresponding editor treats things differently.


TO-LINE, TO-COL					 Editor command argument

  Keyword form:		to-line:, to-col:

  String form:		$to-line, $to-col

  Value type:		<integer>

  Default value:	Values of from-line: and from-col: respectively.

  Meaning:
    These two are similar to "from-line:" and "from-col:" but are
    intended to specify an "end" position for some command.



*** Editor factories

Different types of editor are described by instances of <EDITOR-
FACTORY>, rather than by different <CLASS>es, for historical reasons.
This library was designed to allow dynamic addition of new types of
editor, as mentioned in the introduction.  However, dynamic creation of
classes has never been supported in the emulator and was for some time
unsupported in the various DFMC-based compilers.  Once we move away from
the emulator altogether, it is likely that this library will replace
these "factories" with classes.


* Editor-common library definition

  define library editor-common
    use functional-dylan;
    use threads;
  
    export environment-to-editor-hacker,
           environment-to-editor-user,
           environment-to-editor-implementor;
  end library editor-common;

The THREADS library is used to protect internal data structures against
simultaneous calls from multiple threads.

The ENVIRONMENT-TO-EDITOR-USER module exports a fairly large number of
basic bindings, only a few of which are required for common use.  The
-IMPLEMENTOR module exports a slightly different set of bindings, for
use by backend modules. Lastly, the -HACKER module exports all bindings
within the library, for testing use.


* Editor-common library interfaces

All of the following bindings are exported from modules in the
EDITOR-COMMON library, so the "Library" section is not included for each
one. The ENVIRONMENT-TO-EDITOR-HACKER module exports (almost) all
available bindings. The "Module" field will contain "-USER" and/or
"-IMPLEMENTOR" for those also exported from the corresponding modules,
or "-HACKER only".

Certain operations are available from only one of the modules, though
the class they apply to is available from both. Therefore all operations
are preceded by "U" and/or "I" to indicate where they are exported.

The existence of a setter method is shown by adding "/-SETTER" to the
getter name.


** Editors

<EDITOR>					     Open abstract class

  Summary:	The class of objects storing information about an
		instance of an external editor, during and perhaps
		between calls to that editor (using EDITOR-CALL).

  Module:	-USER, -IMPLEMENTOR

  Superclasses: <SIMPLE-LOCK>

  Init-keywords:

    EDITOR-NAME:	An instance of <SYMBOL>.
    EDITOR-TITLE:	An instance of <STRING>.
    EDITOR-COMMANDS:	An instance of
			LIMITED(<TABLE>, OF: SUBCLASS(<EDITOR-COMMAND>))
    EDITOR-ORIGIN:	An instance of FALSE-OR(<EDITOR-FACTORY>).

  Description:

  Concrete subclasses of this class represent different kinds of editor
  application (or possibly different configurations of communication
  with the same kind of editor).  Instances of this class are used to
  represent instances of "remote" editor applications (i.e., normally,
  separate OS processes).

  Instances may be created during a call to EDITOR-CALL, if no other
  suitable instance can be found in the internal $EDITOR-INSTANCES
  cache, or they may be separately created and passed in to EDITOR-CALL.

  <EDITOR> instances may be cached for one of two reasons: if they
  contain no information applying only to a particular editor process,
  it is because there is no need to remove them; if they _are_ closely
  related to one process, it is because there is useful information to
  be retained between calls.

  Operations:

  U I  EDITOR-NAME						    Slot

	Returns a symbolic name for the editor, which may also be used
	to refer to the <EDITOR-FACTORY> which produced the <EDITOR>, if
	any.  A typical use is as the argument to EDITOR-DEFAULT-
	FACTORY-NAME-SETTER.

  U I  EDITOR-TITLE						    Slot

	Returns a printable string describing the editor, for displaying
	to a user, for example.

  U I  EDITOR-COMMANDS						    Slot

	Returns a table of <EDITOR-COMMAND> objects used in controlling
	the editor to which this <EDITOR> object refers.  The mapping
	from higher-level command symbols to <EDITOR-COMMAND> objects
	may not be one-to-one, so this slot is mostly for internal use,
	by EDITOR-TRANSLATE-COMMAND and by backend libraries.

  U I  EDITOR-FACTORY-OF-ORIGIN					    Slot

	Returns the <EDITOR-FACTORY> whose MAKE-INSTANCE function
	created this <EDITOR>, or #F if the <EDITOR> was created in some
	other way.

  U I  EDITOR-SUPPORTED-COMMAND-NAMES		   Open generic function

	Accepts a single argument, an <EDITOR>.

	Returns a LIMITED(<VECTOR>, OF: <SYMBOL>) containing the
	symbolic names of all the high-level commands which the <EDITOR>
	object will accept in an EDITOR-CALL.


** Editor commands

<EDITOR-COMMAND>				     Open abstract class

  Summary:	The class representing individual commands sent to an
		editor.

  Module:	-USER, -IMPLEMENTOR

  Superclasses: <OBJECT>

  Init-keywords:

    NAME:	(Required) An instance of <SYMBOL>.

  Description:

  Instances of this class represent individual commands to be sent to an
  editor.  Commands generally (although not necessarily) somehow contain
  "parameters" which are replaced during the callout procedure with
  values supplied to EDITOR-CALL.  Subclasses of <EDITOR-COMMAND>
  represent kinds of command in which this substitution is performed
  differently (e.g., string-based versus table-based, or in some way
  peculiar to a particular backend).

  See also:

  The substition parts of the "callout mechanism" section detail how
  substitution is performed for each subclass of <EDITOR-COMMAND> in
  this library.

  Documentation on the various editor backends (a separate document)
  describes how instances of subclasses of this class represent
  particular commands.

  Operations:

  U I  EDITOR-COMMAND-NAME					    Slot

	Returns a symbolic name for the editor command.  This may or may
	not be one of the high-level commands supported by the <EDITOR>
	to which this command object belongs.

  U I  COPY-EDITOR-COMMAND			   Open generic function

	Accepts one argument, an <EDITOR-COMMAND>.

	Returns (normally) a "deep-copy" of its argument.  For the
	purposes of this function, the deep-copy of an object which
	contains other objects (e.g., in a slot or as collection
	elements) is an object of the same class containing
	corresponding deep-copies of its contents.  The deep-copy of an
	object which does not contain others is an object = to the
	original but == only if it is immutable.

	Note: Certain subclasses of <EDITOR-COMMAND> may choose to
	return an object which is (or contains objects) not strictly
	deep-copied, in that it may contain objects which are mutable
	and == to the original.  This may only be done if it is known
	that the object is always treated as immutable, since it may be
	copied many times and those copies destructively modified.


<EDITOR-STRING-BASED-COMMAND>				      Open class

  Summary:	The class of editor commands represented as strings.

  Module:	-USER, -IMPLEMENTOR

  Superclasses: <EDITOR-COMMAND>

  Init-keywords:

    STRING:	(Required) An instance of <STRING>.

  Description:

  Instances of this class represent editor commands by containing a
  <STRING> to be sent to the editor by some means.  When calling an
  editor, certain substrings within the string will be replaced by
  values supplied by the caller.  See the subsection on "The callout
  mechanism" below for details.

  Operations:

  U I  EDITOR-COMMAND-STRING/-SETTER				    Slot

	Returns or sets the <STRING> of the command.


<EDITOR-TABLE-BASED-COMMAND>				      Open class

  Summary:	The class of editor commands whose arguments are placed
		in a <TABLE>.

  Module:	-USER, -IMPLEMENTOR

  Superclasses: <EDITOR-COMMAND>

  Init-keywords:

    TABLE:	An instance of <TABLE>.  Defaults to an empty <TABLE>.

  Description:

  Instances of this class have command arguments placed into a <TABLE>.
  How the instances represent particular commands is unspecified -- it
  might depend on their class (being a subclass of this), or on one of
  the arguments, or something else.  See the subsection on "The callout
  mechanism" below for details.

  Operations:

  U I  EDITOR-COMMAND-VARIABLE-TABLE/-SETTER			    Slot

	Returns or sets the <TABLE> of values in the command.  Normally
	only used in initialisation -- at other times it is the elements
	of the <TABLE> which will be of interest.


** Factories

These interfaces are exported mainly because users of this library may
receive and wish to manipulate <FACTORY> objects within conditions
signalled by some of its other functions.  They will not normally be
needed for calling external editors.


<FACTORY>						  Abstract class

  Summary:	A class of objects with which to make other objects.

  Module:	-USER, -IMPLEMENTOR

  Superclasses: <OBJECT>

  Init-keywords:

    MAKER:	An instance of <FUNCTION>.

  Description:

  This class has been created only because I anticipated possibly having
  to dynamically create subclasses of <EDITOR>, and have heard that
  dynamic class creation may not be well-supported for Kansas.  (Indeed,
  it is not supported at all for the Emulator or Webster.)  The possible
  need would arise if editor backend libraries were to be dynamically
  added or removed, or created by users, as is expected eventually.

  This class should perhaps be in a separate (tiny) library and should
  certainly be removed when dynamic class creation is well supported.

  Operations:

  U I  MAKE-INSTANCE						    Slot

	This slot holds a function which should, when called with no
	arguments, return a single <OBJECT>.  It is intended that all
	such objects returned from the MAKE-INSTANCE of a given factory
	will be similar, at least in <CLASS>.

	Note: There is a MAKE-INSTANCE-SETTER but this is not exported
	from the library.  It is only used by subclasses of <FACTORY>
	within this library.


<EDITOR-FACTORY>

  Summary:	A class of objects for making <EDITOR>s.

  Module:	-USER, -IMPLEMENTOR

  Superclasses: <FACTORY>

  Init-keywords:

    EDITOR-CLASS:	An instance of SUBCLASS(<EDITOR>)

  Description:

  This class is used to make new <EDITOR> objects during EDITOR-CALLs
  (though they may be cached between calls in $EDITOR-INSTANCES). If the
  EDITOR-CLASS: keyword is provided with a non-#F value in a call to
  MAKE on this class, a function will be created for the MAKE-INSTANCE
  slot, which creates <EDITOR>s by applying MAKE to the given class (and
  supplies this factory as the EDITOR-FACTORY: keyword).

  Related functions:

  U    EDITOR-ADD-FACTORY!					Function

	Accepts a LIMITED(<TABLE>, OF: <EDITOR-FACTORY>) and an
	<EDITOR-FACTORY>.

	Returns the table with the factory inserted, using as a key the
	EDITOR-NAME of the <EDITOR> which the factory produces with its
	MAKE-INSTANCE function.


<EDITOR-COMMAND-FACTORY>					   Class

  Summary:	A class of objects for making <EDITOR-COMMAND>s.

  Module:	-IMPLEMENTOR

  Superclasses: <FACTORY>

  Init-keywords:

    EDITOR-COMMAND:	An instance of <EDITOR-COMMAND>, or #F.

	Warning: Exactly one of MAKER: and EDITOR-COMMAND: should have a
	non-#F value in a call to MAKE.  If both are non-#F, MAKER: will
	take precedence; if both are #F, a runtime <TYPE-ERROR> will
	occur.

  Description:

  This class is used to make new <EDITOR-COMMAND> objects during each
  EDITOR-CALL.  If the EDITOR-COMMAND: keyword is provided with a non-#F
  value in a call to MAKE on this class, a function will be created for
  the MAKE-INSTANCE slot, which creates editor commands by applying
  COPY-EDITOR-COMMAND to the supplied <EDITOR-COMMAND>.

  Related Functions:

    I  EDITOR-ADD-COMMAND-FACTORY!				Function

	Accepts a LIMITED(<TABLE>, OF: <EDITOR-COMMAND-FACTORY>) and an
	<EDITOR-COMMAND-FACTORY>

	Returns the table with the factory inserted, using as a key the
	EDITOR-COMMAND-NAME of the <EDITOR-COMMAND> which the factory
	produces with its MAKE-INSTANCE function.


$EDITOR-FACTORIES						Constant

  Summary:	An internal table of <EDITOR-FACTORY> objects.

  Module:	-HACKER only

  Type:		<TABLE>

  Initial value: An empty <TABLE>.

  Description:

  This table is provided to hold <EDITOR-FACTORY> objects provided by
  backend libraries, which use EDITOR-REGISTER-FACTORY to insert them at
  initialisation time.  Users may add other <EDITOR-FACTORY> objects by
  calling EDITOR-REGISTER-FACTORY.

  Related functions:

  U    EDITOR-DEFAULT-FACTORY					Function

	Accepts no arguments.

	Returns the factory object from $EDITOR-FACTORIES which is
	associated with the result of EDITOR-DEFUALT-FACTORY-NAME().
	May return #F if the defualt name is also set to #F, or if no
	editor with that name exists in the table.

  U    EDITOR-DEFAULT-FACTORY-NAME/-SETTER			Function

	Respectively accepts or returns a <SYMBOL>.

	Returns or sets an internally stored symbol, which is the name
	of the <EDITOR-FACTORY> which EDITOR-CALL will use if it is
	passed no <EDITOR> object.  May be set to #F, in which case an
	<EDITOR> object must be provided with each call.

  U    EDITOR-ADD-FACTORY!					Function

	Accepts a LIMITED(<TABLE>, OF: <EDITOR-FACTORY>) and an <EDITOR-
	FACTORY>.

	Inserts the factory into the table using as a key the EDITOR-
	NAME of	the editor produced by the factory.

  U I  EDITOR-REGISTER-FACTORY					Function
  U    EDITOR-DEREGISTER-FACTORY				Function

	Both accept one <EDITOR-FACTORY> argument.  -DEREGISTER- will
	also accept a <SYMBOL> instead.

	Respectively adds to or removes from $EDITOR-FACTORIES an
	<EDITOR-FACTORY> object.  Factories may be deregistered by
	passing the name of the editor they make, or by passing the
	factory object itself.

  U    EDITOR-FACTORY-NAMES					Function

	Accepts no arguments.  Returns a <SEQUENCE> of <SYMBOL>s naming
	editor backends, suitable for passing to EDITOR-DEFAULT-FACTORY-
	NAME-SETTER.


$EDITOR-INSTANCES						Constant

  Summary:	An internal cache of <EDITOR> objects.

  Module:	-IMPLEMENTOR

  Type:		<STRETCHY-VECTOR>

  Initial value: An empty <STRETCHY-VECTOR>.

  Description:

  This cache holds <EDITOR> objects between EDITOR-CALLs, with the idea
  that there may be inter-call state which can usefully be remembered.
  It is normally added to only by EDITOR-GET-INSTANCE but may be
  freely manipulated by editor backend libraries as necessary.

  Related functions:

  U I  EDITOR-GET-INSTANCE					Function

	Accepts one argument, an <EDITOR-FACTORY>.

	Returns an <EDITOR> produced by the factory, possibly by
	retrieving it from the above cache, rather than using the
	factory's MAKE-INSTANCE function slot.  The resulting object
	will be locked in the current thread; if it cannot be locked,
	the warning <EDITOR-WARNING-CANNOT-GET-CONTEXT> will be
	signalled.

  U    EDITOR-DEFAULT-INSTANCE					Function

	Accepts no arguments.

	Returns an <EDITOR> from the EDITOR-DEFAULT-FACTORY(), or #F if
	that default factory is #F.  It calls EDITOR-GET-INSTANCE, so
	may signal the same conditions.

  U I  EDITOR-UNCACHE-INSTANCES					Function

	Accepts a <SYMBOL>.

	Returns nothing but removes from the above cache all <EDITOR>
	obejcts whose EDITOR-NAME equals the <SYMBOL>.


** The callout mechanism

EDITOR-CALL						Generic function

  Summary:	The top-level interface for calling editors.

  Module:	-USER

  Signature:	EDITOR-CALL _command-name_ #key _editor_ #all-keys
		 => #rest _objects_

  Arguments:

    _command-name_	An instance of <SYMBOL>, the name of the command
			to be sent.  Different backends may support
			different command sets, though they normally
			support at least a fixed set -- use EDITOR-
			SUPPORTED-COMMANDS to be sure.

    _editor_		An instance of <EDITOR>, a context for the call.

    other keys		These primarily supply arguments for the
			command, passed to EDITOR-SUBSTITUTE-VARIABLES!
			(see below).  All keys are also passed to all
			the other functions in this section, so some
			backends may use them for other information,
			e.g., graphics context.

  Values:

    _objects_		Zero or more objects, the meaning of which is
			defined by the backend in use.

  THREAD-SAFETY NOTE:
  An <editor> call-context object should never be returned because if it
  was not supplied by the caller then it may be in a cache for re-use
  by later calls, possibly by other threads, so its contents are
  unreliable.

  Exceptions:	See the "Conditions" section below.

  Description:

  This closed g.f. is the mechanism for sending commands to external
  editors.  Calls are synchronous with respect to the command being
  sent to the external editor; the editor's receiving and acting upon
  the command are likely to happen asynchronously.

  A default "kind of editor to call" (i.e., back-end) is maintained
  through the editor-default-factory[-name[-setter]]() interface.
  This is used to generate a context object for the call, unless (a)
  a context object is explicitly supplied with the "editor:" keyword;
  or (b) an internally cached context object matching this "kind" can
  be found.

  If no <editor> is explicitly provided, the caller can rely on this
  calling mechanism to store inter-call context information (e.g.,
  process IDs or IPC handles) internally.  Otherwise the caller must
  pass in the same object later, if s/he wishes to use the same context.

  THREAD-SAFETY NOTE:
  If an <editor> is explicitly provided, the caller must guarantee that
  it will not be modified (by another thread) during the editor-call.
  If not, this function may signal a <warning> if two threads attempt
  to call it for the same "kind of editor" at the same time.


<EDITOR-FRONTEND-COMMAND>					   Class

  Summary:	A class of <EDITOR-COMMAND> which can be passed in to
		EDITOR-CALL in place of the <SYMBOL> name argument.

  Module:	-USER

  Superclasses: <EDITOR-COMMAND>

  Init-keywords: None.

  Description:

  This class was created in case it turns out to be useful to create an
  object representing a "command name plus arguments" (i.e., all the
  information necessary to make an EDITOR-CALL), rather than passing in
  the name and arguments on each call to EDITOR-CALL.

  This class will likely either disappear or take over from the "name
  plus arguments" once the editor-environment integration matures and
  the requirements are better understood.


EDITOR-CALL-INITIALIZE				   Open generic function

  Summary:	Hook to prepare for an editor command.

  Module:	-USER, -IMPLEMENTOR

  Signature:	EDITOR-CALL-INITIALIZE
		    _editor_ _editor-factory_ #key #all-keys
		 => _editor_

  Arguments:

    _editor_		#F or an instance of <EDITOR>, in relation to
			which class-specific preparations can be made.

    _editor-factory_	#F or an instance of <EDITOR-FACTORY> with which
			to make an <EDITOR>, if _editor_ is #F.

  Values:

    _editor_		#F (if no <EDITOR> can be got from the _editor-
			factory_) or a prepared instance of <EDITOR>.

  Exceptions:

  None.  Methods on this g.f. should _not_ signal <EDITOR-WARNING-
  CANNOT-GET-CONTEXT> or <EDITOR-ERROR-FACTORY-UNAVAILABLE> -- he
  caller will do that if necessary.

  Description:

  A hook for specific editor classes to prepare for a command, e.g.,
  by launching an editor process and storing some related state in the
  _editor_ object.  Methods for particular subclasses should normally
  call next-method as their first action, as with methods on initialize.

  The _editor_ argument will be bound to #F or a valid instance of
  <editor> but that instance may not refer to a running editor process
  on entry.  If it is bound to #F, it should be re-bound to an instance
  of <EDITOR>, which will normally be achieved through the next-method
  call.  In any case, _editor_ should be the return value, or #F if the
  next-method call returns #F.  All keywords which were passed to
  to EDITOR-CALL are passed to this function.


EDITOR-TRANSLATE-COMMAND			   Open generic function

  Summary:	Hook for translating frontend commands to backend ones.

  Module:	-IMPLEMENTOR

  Signature:	EDITOR-TRANSLATE-COMMAND
		    _editor_ _editor-command_ #key #all-keys
		 => _editor-command_

  Arguments:

    _editor_		An instance of <EDITOR>.

    _editor-command_	An instance of <EDITOR-FRONTEND-COMMAND>.

  Values:

    _editor-command_	#F or an instance of <EDITOR-COMMAND>.

  Exceptions:

  None.  Methods on this g.f. should _not_ signal <editor-error-
  unsupported-command> if the command cannot be translated -- they
  should return #F and the caller will signal an error if necessary.

  Description:

  A hook for specific editor classes to translate frontend commands to
  backend command objects in specific ways.  The default method is to
  look up the command name in the editor's table of <COMMAND-FACTORY>s,
  and use that factory to make an <EDITOR-COMMAND> (or return #F if no
  factory can be found).  Other methods could introduce mappings between
  frontend names and backend names which are not direct (e.g., if two
  different frontend commands are implemented by the same backend
  command).  Such methods would not necessarily call next-method.
  However, most classes of editor can probably use the default method.

  All keywords which were passed to EDITOR-CALL are passed to this
  function.

EDITOR-SUBSTITUTE-VARIABLES!					Function

  Summary:	Hook for substituting values for variables in commands.

  Module:	-IMPLEMENTOR

  Signature:	EDITOR-SUBSTITUTE-VARIABLES!
		    _command_ #rest _args_
		 => _command_

  Arguments:

    _command_	An instance of <EDITOR-COMMAND>.

    _args_	Zero or more instances or <OBJECT>.

  Values:

    _command_	An instance of <EDITOR-COMMAND>.

  Exceptions:	None.

  Description:

  This function simply iterates over all <EDITOR-VARIABLES> (held in
  $EDITOR-VARIABLES), extracting values for them from the _args_ (using
  EDITOR-VARIABLE-VALUE) and then substituting them into the _command_
  (using EDITOR-SUBSTITUTE-ONE-VARIABLE!).


EDITOR-SUBSTITUTE-ONE-VARIABLE!			   Open generic function

  Summary:	The core substitution function for editor variables.

  Module:	-IMPLEMENTOR

  Signature:	EDITOR-SUBSTITUTE-ONE-VARIABLE!
		    _command_ _variable-name_ _variable-value_
		 => _command_

  Arguments:

    _command_		An instance of <EDITOR-COMMAND>.

    _variable-name_	An instance of <SYMBOL>.

    _variable-value_	An instance of <OBJECT>.

  Values:

    _command_		An instance of <EDITOR-COMMAND>.

  Exceptions:	None.

  Description:

  This function substitutes some representation of the value _variable-
  value_ for every occurrence of (a certain representation of)
  _variable-name_ within _command_ (the representation of the name
  being fixed per class of _command_).  It returns the same _command_
  object after substitution.

  Methods are provided for <EDITOR-STRING-BASED-COMMAND>s and <EDITOR-
  TABLE-BASED-COMMAND>s.  It is unlikely that implementors will have to
  provide more methods of their own, but they may do so.  If they do,
  they will probably _not_ want to call NEXT-METHOD.


EDITOR-CALL-MAIN				   Open generic function

  Summary:	Hook for the main part of the implementation of a
		command by a backend.

  Module:	-IMPLEMENTOR

  Signature:	EDITOR-CALL-MAIN
		    _editor_ _command_ #rest _args_ #key #all-keys
		 => #rest _objects_

  Arguments:

    _editor_		An instance of <EDITOR>.

    _command_		An instance of <EDITOR-COMMAND>.

    _args_		A <SEQUENCE> of alternating keywords and values.

  Values:

    _objects_		Zero or more instances of <OBJECT>.

  Exceptions:

  Methods on this g.f. may signal <editor-warning-command-failed> if
  they could not carry out the requested action.

  Description:

  A hook for specific editor classes to provide the main part of
  their command, typically by calling a function in another library or
  by launching or talking to an external process.

  The _command_ is the backend-specific command to invoke and the
  _editor_ is the context object, with respect to which to invoke it.
  (What that means is backend-specific.)  All keywords which were passed
  to EDITOR-CALL are passed to this function.

  The return values will be backend- and command-specific -- see
  documentation for each backend for details.


EDITOR-CALL-FINALIZE				   Open generic function

  Summary:	Hook for "tidying up" after a command has been invoked.

  Module:	-IMPLEMENTOR

  Signature:	EDITOR-CALL-FINALIZE _editor_ _command_
		 => No return values.

  Arguments:

    _editor_		An instance of <EDITOR>.

    _command_		#F or an instance of <EDITOR-COMMAND>.

  Values:	None.

  Exceptions:

  Methods on this g.f. may signal <editor-error-finalize-failed> if
  they encounter problems.

  Description:

  A hook for specific editor classes to, e.g., tidy up after their
  main command.  For example, one-shot editors might invalidate the
  state information in the "editor" argument, so that
  editor-call-initialize will build new state information next time.

  The _editor_ is the context object used in the call.  The _command_,
  if available, is the backend command translated from the frontend
  command.  All keywords which were passed to EDITOR-CALL are passed to
  this function.

  No editors use this yet but when any do, they should call next-method,
  normally as their last action.  There is a default method which does
  nothing, so it is always safe to call next-method.


** Conditions

<EDITOR-CONDITION>					  Abstract class

  Summary:	The root class for conditions signalled by EDITOR-CALL.

  Module:	-USER

  Superclasses: <CONDITION>

  Init-keywords:

    EDITOR-FACTORY:	#F or an instance of <EDITOR-FACTORY>.

    EDITOR-COMMAND:	#F or an instance of <EDITOR-COMMAND>.

    EDITOR-COMMAND-NAME: #F or an instance of <SYMBOL>.

    OTHER-VALUES:	An instance of <OBJECT>.

  Description:

  Subclasses of this <CONDITION> may be signalled if the editor-call
  fails in some way, so provision should be made to handle any of them.
  Conditions will contain useful values in certain slots, #F in others,
  as documented below.  Some are subclasses of <ERROR>, others of
  <WARNING>; all are also subclasses of <EDITOR-CONDITION>.

  Note: Backends only need to signal <EDITOR-ERROR-FINALIZE-FAILED>, so
  this is the only condition class exported from the -IMPLEMENTOR
  module.

  Note: Some backends could conceivably recover from <EDITOR-ERROR-
  COMMAND-FAILED>, but no recovery protocol has been designed yet.  All
  other <EDITOR-CONDITIONS> are signalled with ERROR and so handlers for
  them must _not_ return.

  THREAD-SAFETY NOTE:
  As with the return values of EDITOR-CALL, an <EDITOR-CONDITION> object
  should never contain an <EDITOR> call-context object (in its other-
  values, or referenced by objects in any other slot).

  Operations:

  Note: The setters for the following slots are exported from the
  -IMPLEMENTOR module but not from the -USER module.  The getters are
  exported form both.

  Note: The meaning of the slot's content depends on the concrete
  condition class.

  U I  EDITOR-CONDITION-FACTORY/-SETTER				    Slot
	#F or an instance of <EDITOR-FACTORY> which was used to create
	the <EDITOR> context object used in the call.

  U I  EDITOR-CONDITION-COMMAND/-SETTER				    Slot
	#F or an instance of <EDITOR-COMMAND> which was derived from the
	command name and keyword-value pairs passed to EDITOR-CALL.

  U I  EDITOR-CONDITION-COMMAND-NAME/-SETTER			    Slot
	#F or an instance of <SYMBOL> which was the command name passed
	as the first argument to EDITOR-CALL.

  U I  EDITOR-CONDITION-OTHER-VALUES/-SETTER			    Slot
	#F or an (other) instance of <OBJECT>, whose meaning depends on
	the condition class, the command and the backend.

  Related classes:

  U    <EDITOR-ERROR>					  Abstract class

	Superclasses: <EDITOR-CONDITION>, <ERROR>

  U    <EDITOR-WARNING>					  Abstract class

	Superclasses: <EDITOR-CONDITION>, <WARNING>

  U    <EDITOR-WARNING-CANNOT-GET-CONTEXT>			   Class

	Superclasses: <EDITOR-WARNING>

	Slots:	EDITOR-CONDITION-FACTORY is non-#F, other slots are #F.

	An <EDITOR-FACTORY> was available but an <EDITOR> could not be
	produced from it. If no specialised methods on EDITOR-CALL-
	INITIALIZE are involved, this indicates that a cached context
	object is in use by a call to EDITOR-CALL on another thread.
	Calling again "later" should succeed; alternatively the caller
	may use the factory to create a fresh <EDITOR> instance and pass
	that explicitly to another call to EDITOR-CALL, thus bypassing
	the cache. However, the caller will then have to keep track of
	the object, as described in the entry for EDITOR-CALL.

	If there are more specialised initialisation methods, there may
	be other reasons why this warning occurs.

	Despite being a <WARNING>, this <CONDITION> should always be
        signalled using ERROR, and so a handler must be in place which
        will not attempt to return.

  U    <EDITOR-ERROR-FACTORY-UNAVAILABLE>			   Class

	Superclasses: <EDITOR-ERROR>

	Slots:	All slots have the value #F.

	Currently means that EDITOR-DEFAULT-FACTORY() returns #F.  This
	means that either (a) no default factory is set (in which case
	EDITOR-DEFAULT-FACTORY-NAME() will be #F also); or (b) the
	default factory has been removed from $EDITOR-FACTORIES
	(...-NAME() is not #F).  Both are probably internal
	implementation errors; the first may be a runtime initialisation
	error.

  U    <EDITOR-ERROR-UNSUPPORTED-COMMAND>			   Class

	Superclasses: <EDITOR-ERROR>

	Slots:	editor-condition-factory and editor-condition-command-
		name are non-#F, others are #F.

	The command sent could not be interpreted by the editor.  This
	is probably an error (e.g., a typo) on the caller's part, since
	all editor back-ends should interpret a fixed set of standard
	commands, although they may ignore some.  It might also indicate
	that the backend is out of date with respect to the frontend
	and/or the caller.

  U I  <EDITOR-WARNING-COMMAND-FAILED>				   Class

	Superclasses: <EDITOR-WARNING>

	Slots:	editor-condition-factory, editor-condition-command and
		editor-condition-other-values are non-#F, others are #F.

	Note: Methods on EDITOR-CALL-MAIN which signal this error should
	only initialize the ...-OTHER-VALUES slot, as the other two will
	be overwritten within EDITOR-CALL-MAIN.)

	The command was interpreted but its execution failed.  This may
	be caused by (among other things) communication failure,
	environmental or other setup problems, non-existence of files,
	or some error from the editor application. 

  U I  <EDITOR-ERROR-FINALIZE-FAILED>				   Class

	Superclasses: <EDITOR-ERROR>

	Slots:	editor-condition-other-values is non-#F, others are #F.

	The finalization stage of the call failed.  This indicates some
	backend-specific problem, which may or may not be an internal
	implementation error.  The results of the main call, if any,
	will be unavailable.


** Utility functions

REPLACE-MATCHED-SUBSEQUENCE-ALL!				Function

  Summary:	Replace all occurrences of one sequence within another
		with some other sequence.

  Module:	-IMPLEMENTOR

  Signature:	REPLACE-MATCHED-SUBSEQUENCE-ALL!
		    _target-sequence_ _match-sequence_ _insert-sequence_
		    #key test
		 => _result-sequence_

  Arguments:

    _target-sequence_	An instance of <SEQUENCE>.

    _match-sequence_	An instance of <SEQUENCE>.

    _insert-sequence_	An instance of <SEQUENCE>.

    #key _test_		An instance of <FUNCTION>.

  Values:

    _result-sequence_	An instance of <SEQUENCE>.

  Exceptions:	None.

  Description:

  Replace all occurrences of _match-sequence_ within _target-sequence_
  by _insert-sequence_.  An occurrence of target-sequence within
  _match-sequence_ is a subsequence of _match-sequence_ which is
  element-for-element equal to match-sequence (as determined by the
  use of _test_ by SUBSEQUENCE-POSITION, which this function calls;
  I assume this means they must be the same length).

  This function avoids the infinite recursion which might occur if
  match-sequence were a subsequence of insert-sequence, but at some
  cost to efficiency.

  Related functions:

    I  REPLACE-MATCHED-SUBSTRING-ALL-NOCASE!			Function

	A simple "wrapper" for REPLACE-MATCHED-SUBSEQUENCE-ALL! which
	accepts and returns only <STRING>s, and forces _test_ to be
	a function which performs case-insensitive <STRING> comparison.
	(This function therefore has a similar signature to the above,
	with <STRING> replacing <SEQUENCE> and with no keyword arguments
	accepted.)


* Editor-common library implementation

** Editor variables:

<EDITOR-VARIABLE>						   Class

  Summary:	The class representing arguments to editor commands.

  Module:	-HACKER only

  Superclasses: <OBJECT>

  Init-keywords:

    NAME:	(Required) An instance of <SYMBOL>.

  Description:

  This class is used to coordinate internally the substitution of
  argument values into parameter "places" within <EDITOR-COMMAND>s.

  See the example usage in the introduction for a list of currently
  implemented variables.

  Note: This class and related operations are only documented for
  internal maintainers of the library.  All other users refer to these
  variables by their names, in keyword, symbol or string form, never
  directly referring to the <EDITOR-VARIABLE> objects.

  Operations:

       EDITOR-VARIABLE-NAME					    Slot

	Returns the name of an editor variable, a <SYMBOL>.

       EDITOR-VARIABLE-VALUE				Generic function

	Accepts one argument, a <SYMBOL>, the name of an editor
	variable, plus any keyword arguments.

	Returns an <OBJECT>, which is the value of that variable, in the
	context of the given keyword arguments.


$EDITOR-VARIABLES						Constant

  Summary:	A table of all variables recognised in substitution.

  Module:	-HACKER only

  Type:		<TABLE>

  Initial value: A <TABLE> containing one instance of <EDITOR-VARIABLE>
		for each of the above variables.

  Description:

  This table holds all the editor variables which the substitution
  mechanism will recognise.  It is not visible outside this library, and
  more variables can be recognised only by changing the source code of
  this library (in particular, substitute-variables.dylan).


EDITOR-VARIABLE-DEFINER						   Macro

  Summary:	A macro for creating and "registering" editor variables.

  Module:	-HACKER only

  Syntax:

    define editor-variable _name_ (_extracter_, _default-value_);

  Description:

  Defines a constant representing the editor variable _name_, and adds
  it to the $EDITOR-VARIABLES internal table.  Also defines a method on
  EDITOR-VARIABLE-VALUE which applies _extracter_ to the value of the
  keyword _name_, or returns _default-value_ if _name_ is #F (which is
  the default value).  If the means for extracting a variable's value
  from the supplied keyword arguments (originally from EDITOR-CALL) is
  more complex than this, this macro cannot be used.  Instead the
  creation, registration and method definition must be done separately.


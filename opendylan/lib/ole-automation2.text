
Title:  OLE Automation library for Dylan

Author: David N. Gray  <gray@harlequin.com>

Date:	June 13, 1996 - original release
	December 20, 1996 - update for evolving design
	January 16, 1997 - re-write to provide a more user-oriented view.
	January 28 and May 5, 1997 - minor updates.
	June 6, 1997 - clarify factory options.
	July 18, 1997 - fix handling of vectors.
	July 30, 1997 - James Kirsch re-vamp for a more user-oriented view.

Status: This describes what I have been implementing, but the design is
	still preliminary and subject to change.  Some of the identifier
	names are likely to change.

Copyright: 1997 Functional Objects, Inc.  All rights reserved.

Hope info: $Header:
/hope/menlo1/hope.1/compound/11/D-doc-lib/RCS/ole-automation.text,v 1.8
1997/07/21 22:42:09 gray Exp $

--------------

Preface
-------

This document describes how a Dylan program can use "OLE Automation"
through the use of the Dylan `ole-automation' library.  The library
provides both the low-level API, which is described near the end of this
document, and higher level utilities, which will be presented first.  
The high-level view is intended to be usable without needing any prior
knowledge of OLE and without needing to read any of the Microsoft
documentation for OLE Automation.  A tutorial introduction is provided
first, followed by more detailed reference information. 


Concepts and terminology
------------------------

Additions: What libraries do you use to make OLE run?
           Talk about the COM library?
           

OLE is a mechanism which builds on the idea of object oriented
programming. You can use the ole-automation library to build objects, "OLE
Server"s, which can be inserted into programs that are designed to use
them, "OLE Cleint"s. Using the ole-automation library you can build The OLE
interface is designed so that the components are independent of
implementation; the components can be written in different languages.

The Dylan OLE Automation library is designed to simplify the process of
building OLE components. It eliminates the overhead of learning the
Microsoft API, providing an simplified dylan interface, without reducing
functionality.

Communication between client and server is done through a "dispatch
interface" (also called "IDispatch"). Each interface can define any number
of "properties" (constants and variables) and methods which a client can
access. The methods may return a single result value. An OLE server has one
or more dispatch interfaces. When a OLE client connects to an OLE server it
can access the primary dispatch interface. If the server has multiple
interfaces, the client can query an interface to obtain any
additional interfaces.

Every OLE server and interface is identified by a unique "class ID", a
128-bit number called a "GUID" ("Globally Unique IDentifier", also
sometimes called a "UUID" -- "Universally Unique IDentifier").  Note that
the word "class" is being used here with a different meaning than a Dylan
`<class>'. An OLE client connects to an OLE server by creating a dispatch
interface with the server's UUID.

Before you invoke a OLE server for the first time, you must register its
class ID in the Windows System Registry. This is so Windows can associate
the class ID with the pathname of the server to be executed. 

You must create a "type library" to describe all the interfaces supported
by the server. You can also create an external copy of the type library,
which can be examined by a potential client or by various utility programs
without actually running the server program.  For example, the Microsoft
"OLE Viewer" utility can use the type library to display a detailed
description of the services provided by an Automation server, and the
Visual C++ wizards can use a type library to generate the skeleton for a
client program to use the server.

A OLE server does not actually create the OLE object when it is initially
invoked. Instead, it first creates a "class factory" object which is
available to all programs. When a client program requests an instance of a
OLE server, it will first make the class factory if it is not already
active. It will then connect to class factory and direct it to create an
instance of the OLE object.

Dylan Automation Controller
---------------------------

The first thing a client must do is call the function OLE-initialize() to
initialize the Microsoft OLE libraries. 

The client must have the class ID of the object it wants to create an
instance of. A class id is a UUID such as:
 
ef462960-bb53-11cf-89f8-02070119f639

The class ID can be defined as:

  define constant $class-id =
    make-GUID(#xEF462960, #xBB53, #x11CF,
              #x89, #xF8, #x02, #x07, #x01, #x19, #xF6, #x39);
 

It can also be converted from the string representation like this:

  define constant $class-id =
    as(<REFCLSID>, "{ef462960-bb53-11cf-89f8-02070119f639}");

A client invokes the OLE server with:

  let disp-interface = create-dispatch($class-id);

The method `create-dispatch' invokes the OLE-server, and tells the
object-factory to create an instance of its OLE object. You can now use
`disp-interface' to access the properties and methods of the object's
primary interface. Each property and method in the interface has a integer
id associated with it. The client uses the integer id to access its
property or method. You can use the method get-id-of-name to get an id:

  let disp-id = get-id-of-name(disp-interface, "an-integer");

This example gets the integer id of a property named "an-integer" from the
OLE object. To get the value of "an-integer":

  let value = get-property(disp-interface, disp-id);

In any OLE-Automation method that accepts a disp-id as an argument, you can
substitute the string name of the property/method you are referencing:

  let value = get-property(disp-interface, "an-integer");

If you are going to use the same property/method more than once, it is less
efficient to use its string name directly in a OLE Automation method. (need
more?)

Likewise, a variable can be set with:

  set-property(disp-interface, disp-id, 5);

This would set the variable named "an-integer" to 5.

A method can be called by using call-simple-method which takes a dispatch
interface, a disp-id/string name of method, and arguments to pass to the
function:

  let disp-id = get-id-of-name(disp-interface*, "multiply");
  let result = call-simple-method(disp-interface*, disp-id, 5, 3);

which is the same as:

  let result = call-simple-method(disp-interface*, "multiply", 5, 3)

When the client is finished with the dispatch interface, it must call:

  Release(disp-interface);

Finally, to stop OLE services, the client must call:

  OLE-uninitialize();

So a very simple example of an Automation Controller that uses a single
interface of an OLE server might look like:
  
  define constant $class-id =
    make-GUID(#xEF462960, #xBB53, #x11CF,
              #x89, #xF8, #x02, #x07, #x01, #x19, #xF6, #x39);  
  
  OLE-initialize();  // initialize OLE libraries
  let disp-interface = create-dispatch($class-id); // start server
  let disp-id = get-id-of-name(disp-interface, "multiply"); // lookup method
  let result = call-simple-method(disp-interface,       // call the method
	                          disp-id, 6, 7);
  Release(disp-interface); // release the server
  OLE-uninitialize();  // shut down OLE

To make it even simpler, an application that fits this model can use the
macro `with-dispatch-interface' like this:

  with-dispatch-interface disp-interface ($class-id)
    let disp-id = get-id-of-name(disp-interface, "multiply"); // lookup method
    let result = call-simple-method(disp-interface,       // call the method
	                            disp-id, 6, 7);
  end with-dispatch-interface;

  with-dispatch-interface disp-interface ($class-id)
    let result = call-simple-method(disp-interface, "multiply", 6, 7);
  end with-dispatch-interface;

If the server provides more than one interface, the additional interfaces
can be accessed the function QueryInterface:

  define constant $interface-id-2 =
    make-GUID(#xa7750270, #xfe31, #x11d0, #xb2, #xc1, #x00, #x00, 
	      #xc0, #x9a, #x70, #xb7);

  let (status, disp-interface-2) =
     QueryInterface(disp-interface-1, $interface-id-2)

QueryInterface returns a status value and the dispatch interface for the
requested interface. Use the OLE Automation FAILED? (or SUCCEEDED?)
to verify that QueryInterface returned the requested dispatch interface:

  if (FAILED?(status))
    error("requested interface not found");
  else
    .. // use disp-interface-2
    Release(disp-interface-2); // don't forget to do this when finished
  end;

There is a complete example program in directory
"~dylan/app/sample-automation-controller/"; note the "README.text" for an
outline of the program.

OLE Automation Server
---------------------

To create an Automation Server in Dylan, you need to provide four parts:

  A) The properties (constants and variables) and methods that are
     accessible through each interface.

  B) A description of what properties and methods are available in each
     interface so the server can create the interface and if desired a
     "type library". The type library can be used by OLE clients or other
     utilities to see what facilities are provided by the OLE server.

  C) A "class factory" which will be created on initialization of the
     server. When an OLE client requests an instance of the dispatch
     object, the class factory creates it.

  D) Code to register the server in the Windows system registry. 

A) Defining the object's properties and methods
-----------------------------------------------

Since the mechanisms of OLE Automation were designed for C and BASIC rather
than for Dylan, it does not support passing arbitrary Dylan objects for
properties and method arguments/results.  However, instances of the
following Dylan classes can be used:

  <integer>, <machine-word>, <byte-character>, <boolean>, <single-float>,
  <double-float>, and <string>

A <sequence>, subclasses of <sequence>, or <array> can be passed
provided that each element is of one of these types.  The elements do not
necessarily have to be of the same class (i.e. #(3, "hi", #f) can be
passed).

When a client passes a server a sequence, regardless of which subclass of
<sequence> was used, an OLE server will receive it as a vector. 

Arrays, sequences, and strings use memory space allocated by the Microsoft
libraries, so to reclaim the memory space, the function `destroy' needs to
be called on them when it is no longer being used.

An OLE interface can itself be passed. If an interface (such as an instance
of <LPUNKNOWN> or <LPDISPATCH>) is received as a method result or property
value, you will need to call `Release' on it when finished using it.

Additionally, the special value `$SQL-NULL' can be passed as an argument to
indicate an unspecified value for a property with an undefined type.

All properties that belong to a dispatch interface are grouped together in
a "COM interface". Each dispatch interface requires a separate COM
interface. The COM interface is modeled after the standard Dylan class
definition:

  define COM-Interface <dispatch-object-1> (<simple-dispatch>)
     slot integer-value :: <integer>;
     slot boolean-value :: <boolean>, init-value: #t;
  end COM-Interface <dispatch-object-1>;

You can define any slots that you want; they will be accessible to a client
only if they are enabled in the type library information.

All methods that belong to a dispatch interface must accept its COM
interface as its first argument, and return a <SCODE> (status code for the
function) as its first result. For example, the most basic (? ->) dispatch
method:

  define method do-nothing 
      (this :: <dispatch-object-1>) =>
      (status :: <SCODE>)
    $S-OK;
  end method do-nothing;

The constant $S-OK should be returned when there is no error. 
Here are a few general purpose error codes that might be of use:

  $E-UNEXPECTED	       Unexpected failure
  $E-NOTIMPL	       Not implemented
  $E-OUTOFMEMORY       Ran out of memory
  $E-INVALIDARG	       One or more arguments are invalid
  $E-POINTER	       Invalid pointer
  $E-HANDLE	       Invalid handle
  $E-ABORT	       Operation aborted
  $E-FAIL	       Unspecified error
  $E-ACCESSDENIED      General access denied error

If a client performs a call-simple-method on a method that returns one of
these error codes, call-simple-method will raise an <ole-error>.

Dispatch methods can accept multiple arguments, and can return a single
result in addition to the status code. Another example:

  define method multiply
      (this :: <dispatch-object-1>, arg1 :: <integer>, arg2 :: <integer>)
      => (status :: <SCODE>, result :: <integer>)
    values($S-OK, arg1 * arg2)
  end method multiply;

If you wanted to design a method that multiplied a passed integer by an
integer in the dispach-interface (using the COM interface
<dispatch-object-1> defined in a previous example):

  define method multiply-external-value-by-internal-value
      (this :: <dispatch-object-1>, arg :: <integer>)
      => (status :: <SCODE>, result :: <integer>)
    values($S-OK, arg * this.an-integer)
  end method multiply-external-value-by-internal-value;

B) Building a type library
--------------------------
  
A type library is built using a "coclass typeinfo" object, which is a
description of the dispatch interface(s) used in the OLE object. For each
dispatch interface, there must be a "dispatch typeinfo". This is a
description of the properties and methods to be included in a dispatch
interface. Therefore, a "coclass typeinfo" is basically a collection of the
"dispatch typeinfo". The OLE-Automation library provides the
<coclass-type-info> and <disp-type-info> classes, which are to be used to
create the type library for an OLE object. 

Every OLE server must have a unique UUID. You can use the Windows utility
"uuidgen" to generate a UUID. Type uuidgen at a command prompt, and it will
return a unique UUID. Store the OLE server's UUID in a constant for
convenienece: 

  define constant $class-id =
    make-GUID(#xEF462960, #xBB53, #x11CF,
              #x89, #xF8, #x02, #x07, #x01, #x19, #xF6, #x39);


Any methods or properties that you want a client be able to access in an
interface need to be described in a dispatch typeinfo. You need to
construct a <disp-type-info> for each interface.

A <disp-type-info> is primarily a container for two vectors; a vector
describing the interface properties, and a vector describing the interface
methods. Each property that is to be included in the <disp-type-info> needs
a <variable-description>. An example of a vector containing
<variable-description>s:

  let interface-1-property-descriptions =
    vector(make(<variable-description>,
	        name: "integer-value",
	        documentation: "an integer value",
	        getter: integer-value,
	        setter: integer-value-setter,
		type: <C-long>),
           make(<variable-description>,
                name: "boolean-value",
                documentation: "a boolean value",
                getter: boolean-value,
                setter: #f));

A <variable-description> is required to have the `name:', `getter:', and
`setter:' slots defined.  

The `name:' slot is a string which is used as a reference to the actual
variable described. When client uses the method `get-id-of-name', it passes
a string name of a property/method to the server. The server then attempts
to match the passed string with a `name:' slot string. If it finds a match,
the server returns the dispatch id of the matched property/method.

The `getter:' and `setter:' slots are used to reference the getter and
setter methods for the variable. Either the getter: or setter: may be #f if
that access is not to be provided. In the above example, a client cannot
set the value of the property boolean-value.

Note that 'setter: #f' just means that the value is not changeable by the
client, not necessarily that it is constant. A property that really is just
a constant value can be specified like this: 
           
           ...,
           make(<constant-description>, 
                name: "pi", 
                value: 3.1416),

Defining the `type:' slot is optional. It is used when creating the
external type library. It is a C designator type from the C-FFI library,
which is used to specify the data type to be used by a client written in C
or C++.  These are the legal values for the `type:' slot:

  <C-int>, <C-short>, <C-long>, <C-float>,
  <C-double>, <C-signed-char>, <C-character>, <CY>,
  <DATE>, <BSTR>, <LPDISPATCH>, <LPUNKNOWN>,
  <C-HRESULT>, <VARIANT-BOOL>, <VARIANT>
 
(talk more about meaning of C-classes?)

If the `type:' slot is not specified, a C designator type will be selected
automatically to most closely match the Dylan type declared for the result
value of the getter function.

An example of a vector containing the interface method descriptions: 

  let interface-1-method-descriptions =
    vector(make(<function-description>,
	        function: do-nothing,
                name: "do-nothing"),
           make(<function-description>,
                function: multiply,
                name: "multiply",
                argument-names: vector("arg1", "arg2"),
                argument-types: vector(<C-long>, <C-long>),
                result-type: <C-long>);

A <function-description> needs to have its `function:' and `name:' slots
defined. The `name:' slot is used in the same manner as in a
<variable-description>. 

The `argument-names:' slot is a vector that contains string names to
represent the names of the arguments that need to be passed to the
interface method. Defining the `argument-types:' and `result-type:' slots
is optional. They are used in the creation of an external type library,
similarly to the `type:' slot in a <variable-description>.

A constructed <disp-type-info> looks like this:

  let disp-type-info-1 =
    make(<disp-type-info>,
         name: "primary dispatch interface for OLE server",
         properties: interface-1-property-descriptions,
         methods: interface-1-method-descriptions);

The `properties:' and `methods:' should be assigned to vectors of
<variable-description>s and <function-descriptions>s respectively (if there
are any - it is legal to leave them blank). (name?) There is also a 'uuid:'
slot which is set to the UUID of the OLE server's primary interface by
default. If the interface that you are describing is not the primary
interface for the OLE server, you must also define the 'uuid:' slot:

 define constant $interface-2-id = 
   make-GUID(#xEF462960, #xBB53, #x11CF,
              #x89, #xF8, #x02, #x07, #x01, #x23, #x4E, #x1A);

 let disp-type-info-2 =
   make(<disp-type-info>,
        name: "second dispatch interface for OLE server",
	properties: interface-2-property-descriptions,
        methods: interface-2-method-descriptions,
        uuid: $interface-2-id);

Finally, a <coclass-type-info> must be constructed of the
<disp-type-infos>:

  let coclass-type-info =
    make(<coclass-type-info>,
         name: "the OLE server coclass-type-info",
	 uuid: $class-id,
	 interfaces: vector(make(<component-interface-description>,
				 class: <dispatch-object-1>,
				 typeinfo: disp-type-info-1),
			    make(<component-interface-description>,
				 class: <dispatch-object-2>,
				 typeinfo: disp-type-info-2)));

The `uuid:' slot should be defined as the UUID of the class. The
`interfaces:' slot should be defined as a vector of
<component-inteface-description>s. For each interface in the OLE server,
you need to make a <component-interface-description>. A
<component-interface-description> has a `class:' slot and a `typeinfo:'
slot which should be assined to an interface's COM-interface and its
<disp-type-info> respectively.

C) Creating a class-factory
---------------------------

Instead of directly instantiating the dispatch object when an OLE client
invokes an OLE server, it will make a class factory. In turn, the class
factory will make an instance of the OLE object for the client. This way,
when more than one OLE client wants to instantate the same OLE object, an
OLE server does not have to reload all its data. To make a class factory in
an OLE server, simply use the method `make-object-factory':

  make-object-factory(coclass-type-info);

D) Registering the OLE server
-----------------------------

Use the method `register-automation-server' to register an OLE server in
the Windows system registry:

  register-automation-server
    ($class-id, "HQNexamples.ExampleServer", "An example OLE server");

The first argument is the UUID of the OLE server. The second argument is a
program intenification string. The third argument is a string description
of the OLE server. 

You can use the method `register-type-library' to create an external type
library. The type library can be used by clients or other utilities that
want to see what facilities are provided by the OLE server without actually
executing it.

  register-type-library(coclass-type-info);

You only need to register the server and create the type library once. The
method `OLE-util-register-only?' can be used so that the OLE server
registers itself when the program is executed with the command-line 
argument "/RegServer":

  define method main-program () => ()
    if (OLE-util-register-only?())  
      register-automation-server
        ($class-id, "HQNexamples.ExampleServer", "An example OLE server");
      register-type-library(coclass-type-info);
    else
      ... // make class factory and rest of program
    end if;
  end method main-program;

The method `register-automation-server' can also unregister an OLE server
from the Windows system registry. If you run the program with the
command-line argument "/UnRegServer", the server will unregister
itself. The method `OLE-util-register-only?' will also return true for the
command-line argument "/UnRegServer".

You can use the program RegEdit to verify that an OLE server was
registered. You can launch RegEdit by using the `run' function in the
start-menu. Type "RegEdit" and click OK to start the program. Open the
folders HKEY_CLASSES_ROOT and CLSID. You should see a large list of folders
with UUIDs. You should be able to find the UUID of the server that you want
to verify. If you open that folder, you should be able to find the data
that you registered the server with.

Putting it all together:
------------------------

Here is an example shell of a two interface OLE-Server:

  define constant $class-id =
    make-GUID(#xEF462960, #xBB53, #x11CF,
              #x89, #xF8, #x02, #x07, #x01, #x19, #xF6, #x39);  

  define constant $interface-2-id = 
   make-GUID(#xEF462960, #xBB53, #x11CF,
              #x89, #xF8, #x02, #x07, #x01, #x23, #x4E, #x1A);

  define *object-factory* = #f;
  
  define *coclass-type-info* = #f;
  
  define COM-Interface <dispatch-object-1> (<simple-dispatch>)
     slot integer-value :: <integer>;
     slot string-value :: <string>;
  end COM-Interface <dispatch-object-1>;

  define COM-Interface <dispatch-object-2> (<simple-dispatch>)
     slot boolean-value :: <boolean>;
  end COM-Interface <dispatch-object-2>;

  define method do-nothing
      (this :: <dispatch-object-1>) => (status :: <SCODE>)
    $S-OK;
  end method do-nothing

  define method multiply
      (this :: <dispatch-object-2>, arg1 :: <integer>, arg2 :: <integer>)
      => (status :: <SCODE>, result :: <integer>)
    values($S-OK, arg1 * arg2)
  end method multiply;

  define method make-coclass-type-info ()
    let interface-1-property-descriptions =
      vector(make(<variable-description>,
	          name: "integer-value",
	          documentation: "an integer value",
	          getter: integer-value,
	          setter: integer-value-setter,
       		  type: <C-long>),
             make(<variable-description>,
                  name: "string-value",
                  documentation: "a string value",
                  getter: string-value,
                  setter: #f));
    let interface-1-method-descriptions =
      vector(make(<function-description>,
                  name: "do-nothing",
                  function: do-nothing));
    let disp-type-info-1 =
      make(<disp-type-info>,
           name: "primary dispatch interface for OLE server",
           properties: interface-1-property-description,
           methods: interface-1-method-description);
    let interface-2-property-descriptions =
      vector(make(<variable-description>,
                  name: "boolean-value",
                  documentation: "a boolean value",
                  getter: boolean-value,
                  setter: boolean-value-setter);
    let interface-2-method-descriptions =
      vector(make(<function-description>,
                  name: "multiply"
                  function: multiply,
                  argument-names: vector("arg1", "arg2"),
                  argument-types: vector(<C-long>, <C-long>),
                  result-type: <C-long>);
    let disp-type-info-2 =
      make(<disp-type-info>,
           name: "second dispatch interface for OLE server",
           properties: interface-2-property-description,
           methods: interface-2-method-description,
           uuid: $interface-2-id);
    *coclass-type-info* := 
      make(<coclass-type-info>,
           name: "the OLE server coclass typeinfo",
           uuid: $class-id,
           interfaces: 
             vector(make(<component-interface-description>,
                         class: <dispatch-object-1>,
                         typeinfo: disp-type-info-1),
                    make(<component-interface-description>,
                         class: <dispatch-object-2>,
                         typeinfo: disp-type-info-2)));
  end method make-coclass-type-info;
  
  define method main-program () => ()
    make-coclass-type-info();
    if (OLE-util-register-only?())
      register-automation-server
        ($class-id, "HQNexamples.ExampleServer", "An example OLE server");
      register-type-library(*coclass-type-info*);
    else
      make-object-factory(*coclass-type-info*);
      ... // rest of server program
    end if;
  end method main-program;
                    
There is a complete example of a server application in the directory
"~dylan/app/sample-automation-server/". See its "README.text" file for an
explanation.  

Class reference
---------------

Following is a more detailed specification of the data types provided by
the `OLE-Automation' library.

  <LPUNKNOWN>						Class

	Abstract super-class for all OLE interfaces.

  <LPDISPATCH>						Class

	A subclass of <LPUNKNOWN> which is the superclass for any objects
	that act as an Automation IDispatch interface.

  <BSTR>

	"BASIC String" -- this is a subclass of `<string>' that corresponds
	to the string representation used by OLE Automation property values
	and dispatch method arguments.  The elements are 16-bit Unicode
	characters. 

	Besides supporting the full <string> protocol, this class can also
	be regarded as a C pointer.  (It is a subclass of the C-FFI type
	`<C-unicode-string>'.) The constant `$NULL-BSTR' can be used to pass
	a NULL pointer in place of a string.  The function `null-pointer?'
	can be used to test a received `<BSTR>' to see if it is a NULL
	pointer.  However, a NULL pointer is treated the same as an empty
	string by the iteration protocol, so it may not be necessary to do
	this test.

	These strings are allocated memory space by the Microsoft OLE
	library, so space is not reclaimed by the Dylan garbage collector.
	Instead, the function `destroy' needs to be called on a `<BSTR>'
	when finished with it.

	Note that `as' may be used to convert between `<BSTR>' and other
	string types. The function `copy-as-BSTR' will copy any kind of
	`<string>' to a newly allocated `<BSTR>'; this should be used
	instead of `as' when returning a value that will be deallocated by
	the receiving program.  It returns `$NULL-BSTR' if the argument is
	`#f' or a NULL pointer.

  <ole-array>

	This is a subclass of both `<array>' and the C pointer type
	`<LPSAFEARRAY>'.  It allows the Dylan array protocol to be used on
	data that is actually allocated as a C `SAFEARRAY' structure.  The
	function `destroy' needs to be used to deallocate the storage when
	no longer needed.

	For arrays received by Dylan from an OLE Automation call, it will
	appear as an `<ole-vector>' if it is one-dimensional, otherwise as
	a an `<ole-array>'.

	Note: the dimensions in a SAFEARRAY specify both a lower and upper
	bound for the index, but since Dylan does not support alternate
	lower bounds, index 0 will always correspond to the first element
	when viewed as a Dylan array.
 
  <ole-vector>

	This is a subclass of both `<ole-array>', and `<vector>'.  It
	supports using the full Dylan vector protocol on one-dimensional
	vectors passed in an OLE Automation call.

	The function `ole-vector' can be used like `vector' to construct an
	`<ole-vector>' containing the function arguments.

	If you construct one of these, remember that `destroy' needs to be
	used to deallocate the storage.

 <class-factory>

	This class provides an implementation of the COM IClassFactory
	interface.  Making one causes it to automatically be registered
	with the system for use by potential clients.  The instance is not
	directly used by the program except that the function
	`revoke-registration' needs to be called on it before the program
	terminates. 

	The following initialization keywords are available:

	  clsid:	The class ID which identifies the service being
			provided.  Required.  This can be represented as
			either a `<REFCLSID>' (as from `make-GUID') or a
			string (containing 32 hexadecimal digits within
			braces).

	  class:	The Dylan class (usually a user-defined subclass of
			`<simple-dispatch>') which is to be instantiated
			when requested by the client.  Required.

	  args:		Optional sequence of initialization arguments to be
			passed to `make' when instantiating the object. The
			default is to pass the same arguments as for the
			`<class-factory>' (`<simple-dispatch>' accepts
			and ignores those that are only for the factory,
			and `<class-factory>' ignores any that it doesn't
			recognize.)   Note that `<simple-dispatch>'
			requires `typeinfo:' to be supplied.
 
	  server-context:  Indicates where the server is running.  See the
			description of `create-dispatch' below for a list
			of possible values.  Defaults to
			`$CLSCTX-LOCAL-SERVER'.  `$CLSCTX-INPROC-SERVER'
			may be used instead to suppress external
			registration of the factory.

	  connection-flags:  One of the following constants:
 		 $REGCLS-SINGLEUSE   - only one connection allowed (default)
		 $REGCLS-MULTIPLEUSE - multiple connections permitted
		 $REGCLS-MULTI-SEPARATE - multiple connect, separate control

	Any other keyword arguments are passed in the `make' call when the
	Dylan class is instantiated.  Note that `<simple-dispatch>'
	requires `typeinfo:' to be supplied.


  <simple-dispatch>

	Abstract subclass of `<LPDISPATCH>' which provides an
	implementation of the IDispatch interface.  User-defined subclasses
	of this will provide the actual properties and methods that are
	accessible through the interface.  Remember that `define
	COM-interface' needs to be used for defining subclasses.

	Note that this is usually instantiated by a `<class-factory>', rather
	than by calling `make' directly.

	The initialization keywords are:

	  typeinfo:	The ITypeInfo interface which describes the
			services being provided.  Usually this will be an
			instance of `<disp-type-info>'.  Required.

			For supporting multiple locales, the value may be a
			`<collection>' of `<disp-type-info>' which will be
			indexed by the locale code.
			[Issue: this needs more thought.]
 
	  controlling-unknown:  Designates the IUnknown interface if
			aggregation is being used to provide multiple
			interfaces from a single OLE object.  Optional.
			Note that this will be provided automatically if
			the aggregation is created by using
			`<coclass-type-info>' and `make-object-factory', so
			it should be rare that this needs to be
			explicitly specified.
 
  <disp-type-info>

	This class is instantiated to provide an implementation of the
	ITypeInfo interface describing a single IDispatch interface.
	Following are the init keywords:

	  name:		 name of the interface (a string).

	  uuid:		 GUID that identifies the interface.
			 (default is `$IID-IDispatch')
			 This is preferably an instance of `<REFGUID>' (from
			 `make-GUID') but it will also accept a string
			 representation (containing 32 hexadecimal digits
			 within braces).

	  properties:	 a <sequence> in which each element is an instance
			 of '<variable-description>' or
			 `<constant-description>' that specifies one
			 property.  (default is no properties)

	  methods:	 a <sequence> in which each element is an instance
			 of `<function-description>' that specifies a
			 member method.  (default is none)

	  documentation: documentation string. (called "helpstring" in ODL)

	  help-file:	 name of help file for WinHelp.  (default is none)

	  help-context:  position in WinHelp file where this interface is
			 documented.   Optional.

	  major-version: major version number (defaults to 0)

	  minor-version: minor version number (defaults to 0)

	  locale:	 internationalization locale 
			 (defaults to 0, meaning neutral)

  <variable-description>

	Describes one property of a dispatch interface.  Init options are:

	  name:		string that is the name of the property.  Required.

	  getter:	either
			  a Dylan function that takes the interface as the
			  sole argument and returns the value of the
			  property
			or
			  `#f' if the property is not externally readable.
			(default is #f)

	  setter:	a Dylan function that changes the value of the
			property, taking the new value and the interface as
			its arguments,  or `#f' if the value cannot be
			changed by the client.  (default is #f)

			Note special case: if the value of the property is
			an interface pointer (such as <LPUNKNOWN> or
			<LPDISPATCH>), then the setter method will need to
			call `AddRef' on the new value and call `Release'
			on the old value.

	  type:		The value is a C designator type from the C-FFI
			library, which is used to specify the data type to
			be used by a client written in C or C++.  Following
			are the legal values:

			  <C-int>, <C-short>, <C-long>, <C-float>,
			  <C-double>, <C-signed-char>, <C-character>, <CY>,
			  <DATE>, <BSTR>, <LPDISPATCH>, <LPUNKNOWN>,
			  <C-HRESULT>, <VARIANT-BOOL>, <VARIANT>
 
			If the `type:' is not specified, one will be
			selected automatically to most closely match the
			Dylan type declared for the result value of the
			getter function.  The type must be specified one
			way or the other.  Note that the default is the
			type declared for the generic function; it is not
			sufficient to just specify the type for a slot,
			since there isn't enough context here to know which
			method is applicable.

	  documentation: a string providing a description of the
			property. (This is called a "helpstring" in ODL.)
			Optional.

	  help-context: position in WinHelp file where this property is
			documented.  Optional.  (Note that the name of the
			help file is specified in the `<coclass-type-info>'.)

	[Issue: need an option for explicitly specifying the disp-id in
	order to implement stock properties.]


  <constant-description>

	Describes one constant-valued property of a dispatch interface.
	Init options are:

	  name:		string that is the name of the property.  Required.

	  value:	The value of the property.  Required.

	  type:		C type, like for `<variable-description>' above.
			Defaults from the class of the value.

	  documentation: documentation string.  Optional.

	  help-context:  position in WinHelp file.  Optional.


 <function-description>

	Describes one member method of a dispatch interface.
	Init options are:

	  name:		string that names the member method.  Required.

	  function:	The Dylan function or method that implements the
			functionality.  Required.  The function will be
			called with the dispatch instance as the first
			argument and the dispatch method arguments as the
			remaining function arguments.  It must return an
			`<SCODE>' as the first result value, and may
			optionally return a second result value which is
			the value returned from the dispatch member method.

			`#key' arguments may be used to correspond to OLE
			Automation named arguments.  `#all-keys' would not
			be useful.

			If the function uses `#rest' but not `#key', then
			it will be described to a C user as accepting a
			"safe array" as the value of an additional
			argument.

	  argument-names: a <sequence> giving the names of the dispatch
			method arguments.  The length must match the number
			of function arguments (including any `#key'
			arguments) after the dispatch interface.  Default
			is no arguments.  Note that even for `#key'
			arguments, these names that are exposed to the
			client don't have to match the Dylan identifiers;
			the correspondence is strictly by position order.
			A `#rest' arg does not have a name.

	  argument-types: a <sequence> giving the C types of the arguments,
			like for the `type:' option of
			`<variable-description>' above.  The default is to
			attempt to infer the types from the declared Dylan
			types of the function arguments.

	  result-type:	the C type of the result value, or `#f' if no
			result.  Defaults according to the declared result
			values of the Dylan function.

	  documentation: documentation string.  Optional.

	  help-context:  position in WinHelp file.  Optional.

	  scodes:	 <sequence> of error code values that might be
			 returned.  The default is an empty sequence.
			 This is for documentation purposes only -- there
			 is nothing to prevent the function from returning
			 other codes not listed here.

	  flags:	 `logior' of $FUNCFLAG-... values.  Default is 0.
			 (Refer to the Microsoft documentation for the
			 FUNCFLAGS enumeration.)  This is not likely to be
			 necessary; it just fine-tunes the appearance of the
			 function in browsers.


  <coclass-type-info>

	This class is instantiated to provide an implementation of the
	ITypeInfo interface describing a "component object class" which can
	contain any number of dispatch interfaces.  The init keywords are:

	  name:		 name of the OLE object class (a string).

	  uuid:		 GUID that identifies the OLE object class.  Required.

	  class:	 the instance of <class> which is to be
			 instantiated to implement the object.  Defaults to
			 `<simple-component-object>'.  Usually it would be
			 overridden only by a user-defined subclass of
			 `<simple-component-object>', but the only
			 requirement is that it implement the IUnknown
			 interface and that it accept a `typeinfo:' init
			 argument with the instance of
			 `<coclass-type-info>' as the value.
 
	  args:		 a <sequence> of initialization keyword arguments
			 for instantiating the class (in addition to
			 `typeinfo:').  Defaults to empty.  There are no
			 init arguments applicable to
			 `<simple-component-object>', so this would be used
			 only if `class:' is also specified.

	  interfaces:	 a <vector> in which each element is an instance of
			 `<component-interface-description>' describing an
			 interface that is supported by the compound object.

	  documentation: documentation string.  (This is what will appear
			 as the name of the type library in the Microsoft
			 OLE2VIEW utility, which assumes a single line that
			 will be truncated at about 45 characters.)

	  help-file:	 name of help file for WinHelp.  (default is none)

	  help-context:  position in WinHelp file.

	  major-version: major version number (defaults to 0)

	  minor-version: minor version number (defaults to 0)

	  locale:	 internationalization locale (defaults to neutral)


  <simple-component-object>

	This class provides an implementation of a "compound class object".
	It can be instantiated directly, or the user may define a subclass.
	It takes one required init keyword, `typeinfo:', whose value is an
	instance of `<coclass-type-info>' (see above) which specifies the
	component interfaces which will be automatically instantiated when
	the object is instantiated.  This is a subclass of `<IUnknown>', so
	the function `QueryInterface' may be called on an instance to
	obtain one of the component interfaces.

	Note that subclasses need to be defined by `define COM-interface'
	instead of `define class'.


  <component-interface-description>

	This class is directly instantiated to specify one interface in a
	"compound class object".  The init arguments are:

	  typeinfo:	an ITypeInfo interface which describes the
			interface.  Usually this will be an instance of
			`<disp-type-info>'.  Required.

	  class:	The Dylan <class> which will be instantiated to
			implement the interface.  Should be a user-defined
			subclass of `<simple-dispatch>'.

	  args:		<sequence> of initialization arguments for the
			Dylan class (besides the `typeinfo:' and
			`controlling-unknown:' arguments that are
			automatically supplied).  Default is empty.
			This would only be needed for keywords added by a
			user-defined subclass.

	  flags:	Implementation flags -- an <integer> formed by
			`logior' of $IMPLTYPEFLAG-... values.  (Refer to
			the Microsoft documentation for the IMPLTYPEFLAGS
			enumeration.)  The default is 0.  The meaningful
			values are:

			  $IMPLTYPEFLAG-FDEFAULT
				Designates this interface as the default.
				If none have this flag, the first one
				listed will be used as the default.

			  $IMPLTYPEFLAG-FSOURCE
				This is a "source" interface -- i.e., one
				that is called by the server and should be
				implemented by the controller.  [This
				functionality is not yet supported from Dylan.]

			  $IMPLTYPEFLAG-FRESTRICTED
				Designates a member that should not be
				visible or used externally.  (This is
				probably not useful in Dylan, since such a
				member could simply not be mentioned in the
				type info.)

			[Issue: maybe it would be simpler to not have this
			`flags:' option.  Source interfaces might be better
			specified as a separate sequence argument for
			`<coclass-type-info>'.]


  <ole-error>

	A subclass of `<error>' used to report OLE error codes.
	Use function `ole-error' or `check-ole-status' to create and signal
	one of these.
	The following accessor functions may be used on the error object:

	   ole-error-status	returns the low-level status code.
	   ole-error-context	name of the function that returned the code.
	   ole-error-instance   the interface that the function was acting on.
	   ole-error-args	a <sequence> of additional function
				arguments (not necessarily a complete list,
				just whatever else might be interesting).



Function reference
------------------

Many of the OLE Automation functions accept an optional `locale:' option
which can be used for internationalization.  Usually it would not be
specified, letting the locale default to the current user's default locale.
If you really need to specify a specific language, a locale value is
constructed by the function `MAKELCID' in the `win32-common' library.  See
also `MAKELANGID' and the associated `$LANG-...' and `$SUBLANG-...'
constants.  For example, you could do:

  define constant $British-english-locale =
    MAKELCID(MAKELANGID($LANG-ENGLISH,$SUBLANG-ENGLISH-UK),$SORT-DEFAULT);

[Issue: some more design work is probably needed before locales will really
be useful.]


Following is a more detailed specification of the functions provided by the
`OLE-Automation' library.

  OLE-initialize () => ()

	Ensure that the Microsoft OLE libraries have been initialized.  
	It doesn't hurt to call it more than once, but each call to this
	function should be balanced by a matching call to
	`OLE-UnInitialize'.

  OLE-uninitialize () => ()

	Release the Microsoft OLE libraries when finished using them.
	This should only be used to undo a matching call to
	`OLE-initialize'.  This allows freeing any resources used by the
	libraries, and ensures that any pending messages are handled and
	any open connections closed.

  with-OLE  ?body  end					[Macro]

	This convenience macro calls `OLE-initialize', executes the body
	forms, and calls `OLE-uninitialize' in a `cleanup' clause.

  make-GUID (l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) => (ID :: <REFGUID>)

	Creates a GUID ("Globally Unique IDentifier") object (class
	<REFGUID>, alias <REFCLSID> or <REFIID>) from the constituent
	integers.  This is used for specifying the OLE class ID of the
	server application, or the ID of an interface.  The utility program
	"UUIDGEN" from the Win32 SDK can be run at a DOS prompt to generate
	an ID for a new application.  For example, if "UUIDGEN" displays:

	  113f2c00-f87b-11cf-89fd-02070119f639

	this could be used directly in a registration file but needs to
	be formatted a little differently to become the arguments for this
	function:

	  define constant $my-class-ID =
		make-GUID(#x113f2c00, #xf87b, #x11cf,
			  #x89, #xfd, #x02, #x07, #x01, #x19, #xf6, #x39);

	The value returned is a C structure pointer, so the function
	`destroy' should be called on it if it is no longer needed.

	[Issue: Since not all users will have the SDK, DylanWorks will need
	to provide our own implementation of the "UUIDGEN" utility.  Note
	that this simply involves calling the COM library functions
	`CoCreateGuid' and `StringFromGUID2'.]

	[Temporary note: to avoid truncation, the current compiler (DFMC as
	of June 1997) requires that `as(<machine-word>, ...)' be wrapped
	around the first argument if the first digit is anything other than
	'0', '1', 'E', or 'F'.]

  as (class == <string>, guid :: <REFGUID>) => (s :: <byte-string>)  [Method]

	Converts the internal representation of a GUID to a representation
	as a string by calling the Microsoft library function
	`StringFromGUID2'.  The string has the form:
		"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
	where each `x' is a hexadecimal digit.

  as (class == <REFGUID>, s :: <string>) => (guid :: <REFGUID>)      [Method] 

	Calls the Microsoft library function `CLSIDFromString' to convert
	the string to a GUID.  The string may either represent the GUID in
	the form: 
		"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
	(the enclosing braces are a required part of the syntax; letters
	may be either upper or lower case), or else it will be looked up in
	the System Registry as a "ProgID" ("programatic identifier") string
	and the corresponding GUID will be returned.  An error is signalled
	if the string is not in the expected format and is not found in the
	Registry.
	
	The value returned is a C structure pointer, so the function
	`destroy' should be called on it if it is no longer needed.

  copy-automation-value (object) => (object)		[Generic Function]

	If the argument is an instance of <BSTR>, <ole-vector>, or
	<ole-array>, the returned value will be a corresponding Dylan
	object which has the same contents but does not use any C-allocated
	storage.  For example, the contents of an <ole-vector> will be
	copied into a <simple-vector>, with `copy-automation-value' being
	recursively called on each element.

	If the argument is of any other type, then it is returned unchanged.

	This function may be used by a dispatch method to ensure that a
	received argument value can be kept after the call returns, or by a
	client on a received property value or method result.

  QueryInterface(interface :: <LPUNKNOWN>, interface-id :: <REFGUID> )
		=> ( status :: <SCODE>, object :: <LPUNKNOWN> )

	Given one interface, find another interface supported by the
	server.  If an interface with the given GUID is found, the first
	value satisfies `SUCCEEDED?', and the interface is returned as the
	second value.  `Release' should be called on it when finished using
	it.  The first value will be `$E-NOINTERFACE' if the ID is not
	supported. 

  Release(interface :: <LPUNKNOWN>) => ( new-ref-count :: <integer> )

	When a client is finished with an interface, it should call
	`Release' on it to let the server know that the session is
	completed.  (The returned value is usually not useful.)

  get-id-of-name(disp-interface :: <LPDISPATCH>, name :: <string>,
	         #key locale = $LOCALE-USER-DEFAULT,
		      undefined-ok? :: <boolean> = #f)
	  => ( disp-id :: <integer> )

	Returns the dispatch ID for the member whose name for the given
	locale matches the given name string.  (Note that the comparison is
	not case-sensitive.)  This works for either methods or properties,
	but doesn't support mapping the names of the arguments of methods.

	If the name is not defined and the `undefined-ok?:' option is true,
	then the integer value `$DISPID-UNKNOWN' is returned instead of
	signalling an error.  [Or maybe it should be `#f'?]

  get-property(disp-interface :: <LPDISPATCH>, property,
	       #key default, locale = $LOCALE-USER-DEFAULT)
	   => ( value :: <object> )

	A simple way to obtain the value of a property of a dispatch
	interface.

	The _property_ argument is either the name of the property (a
	<string>), or the disp-id (an <integer>).  If the property will be
	referenced more than once, it is much more efficient to use
	`get-id-of-name' to map the name to a disp-id just once.

	If the designated property is not supported, if the `default:'
	option is specified, then that value is returned (useful for
	querying stock properties), otherwise an error is signalled.

	This can also be used on the left side of an assignment to set the
	value of a property.

  set-property(disp-interface :: <LPDISPATCH>, property,
 	       new-value :: <object>, #key locale = $LOCALE-USER-DEFAULT) => ()

	A simple way to set the value of a property of a dispatch
	interface.  As for `get-property', the _property_ argument is
	either a name or disp-id.

  call-simple-method(disp-interface :: <LPDISPATCH>, member,
 		     #rest args) => ( result :: <object> )

	A simple way to call a dispatch method.  This is limited to methods
	that have only positional arguments (as opposed to named arguments)
	and which don't need a locale to be specified.

	The _member_ argument is either the name of the method (a
	<string>), or the disp-id (an <integer>).  If the method will be
	called more than once, it is much more efficient to use
	`get-id-of-name' to map the name to a disp-id just once.

	[Issue: need to design high-level support for the cases excluded.]

  create-dispatch ( class-id, #key context = $CLSCTX-ALL )
	     => (disp-interface :: <LPDISPATCH>)

	Used by an Automation controller to invoke an automation server, as
	identified by its class ID.  The primary dispatch interface is
	returned.  `Release' should be called on it when finished.

	The _class-id_ argument may be either an instance of `<REFCLSID>'
	(such as returned by `make-GUID') or a <string> which can be
	converted to a GUID (see the `as' method above).

	The `context:' option takes one of the following values constraining
	which implementation of the server is to be used:

	    $CLSCTX-INPROC-SERVER	DLL running in same process.
	    $CLSCTX-LOCAL-SERVER	an EXE file in separate process.
	    $CLSCTX-REMOTE-SERVER	on a remote machine.
	    $CLSCTX-SERVER    		any of the above.
	    $CLSCTX-INPROC-HANDLER	an in-process handler.
	    $CLSCTX-ALL       		any of the above.  (default)
 
	If the class ID is not found in the registry, or there isn't a
	server that matches the requested `context:', an <ole-error> will
	be signalled with status code of `$REGDB-E-CLASSNOTREG'.

  make-object-factory ( typeinfo :: <coclass-type-info>, #rest other-args )
	 => ( factory :: <class-factory> )

	Creates, registers, and returns a class factory for the OLE object
	described by the given coclass type info.  The additional arguments
	are used as initialization keywords for either the <class-factory>
	or the object implementation class.  Call `revoke-registration' on
	the returned factory object before the program terminates.

  revoke-registration(factory :: false-or(<class-factory>)) => ()

	Un-registers a class factory, making it no longer available to
	potential clients.  It does nothing if the argument is `#f' or
	`$null-interface' or if it has already been called on the same
	factory instance.

  with-class-factory ( ?args ) ?body end 			[Macro]

	This convenience macro calls `make' for a `<class-factory>' with
	the given initialization keyword arguments, executes the body
	forms, and finally calls `revoke-registration' in a `cleanup'
	clause.

  ole-error( status, context, instance, #rest args )

	Signals an <ole-error> with the specified parameters.
	The _context_ argument is intended to be the name of the
	function that returned the status, the _instance_ argument is the
	interface the function was operating on, and additional relevant
	function arguments may be listed for information purposes.

  check-ole-status ( status :: <SCODE>, context, instance, #rest args ) => ()

	If the status code indicates an error, calls `ole-error' to signal
	an error condition. 

  HRESULT-FROM-WIN32 ( error-code :: <integer> ) => ( status :: <SCODE> )

	Given a Windows error code, such as returned by Windows function
	`GetLastError', return the corresponding `<SCODE>' value.

  OLE-util-automation? () => (automation? :: <boolean>)

	Returns #t if the program's command line has the "/Automation"
	option (case insensitive), indicating that execution was initiated
	by an Automation controller client, as opposed to being invoked
	directly by the user.

  OLE-util-file-arg () => (file-name :: false-or(<string>))

	This convenience function can be used by programs that want to
	accept a single file name as a command line argument.  If such an
	argument has been supplied, it will be returned as a string.

  OLE-util-register-only? () => (just-register? :: <boolean>)

	Returns `#f' unless the program's first command line argument is
	any of "/RegServer", "-RegServer", "/UnregServer" or "-UnregServer"
	(using case-insensitive comparison).  When a non-false value is
	returned, the program should just register itself (see
	`register-automation-server' and `register-type-library' below) and
	terminate without doing anything else.

  register-automation-server ( class-id :: type-union(<REFCLSID>,<string>),
			       prog-id :: <string>, title-string :: <string>,
			     #key versioned-prog-id :: false-or(<string>),
			          versioned-title :: false-or(<string>)) => ()

	This function will create the necessary system registry entries for
	the current program to be invoked by an Automation Controller, or if
	the program was invoked with "/UnregServer" or "-UnregServer", then
	it will attempt to delete any registry entries belonging to the
	program.

	class-id
		must have the same value as the `clsid:' argument for
		making the `<class-factory>' or the `uuid:' argument for
		making a `<coclass-type-info>'.  (See also `make-GUID'.)

		Note that if you want to be able to have two versions of a
		program installed at the same time, then the two versions
		need to have different class IDs, as well as specifying a
		`versioned-prog-id:' for each.

	prog-id
		The "ProgID" or "programatic identifier" is a unique name
		for the class; it is used for compatibility with Visual
		Basic and OLE1.  It must start with a letter, it cannot
		contain any spaces or punctuation except period, and it
		must not be more than 39 characters long.  In order to
		ensure uniqueness, the recommended format is:
		  <vendor-name>.<product-name>
		For example:
		  AcmeWidgets.FrobMaster
 
	title-string
		identifies the program in displays for the user.
		It should not include the version number.

	versioned-prog-id:
		(optional) is either `#f' or a string that is recommended
		to be the same as the `prog-id' with a version
		identification appended. For example: 
		  AcmeWidgets.FrobMaster.2.1

	versioned-title:
		(optional) is either `#f' or a title string that includes
		the program's version number.

  register-type-library( typeinfo :: <ITypeInfo> ) => ()

	Create a Type Library file from the given type information and
	record it in the System Registry, if that has not already been
	done.  The created file will be in the same directory as the ".EXE"
	file and will have the same name but with the extension ".TLB".
	The type library can be used by controllers or other utilities that
	want to see what facilities are provided by the Automation server
	without actually executing it.  Note that this is optional since
	the type library file is not used by the program itself, and a
	controller doesn't necessarily need it either, but it will be
	created automatically if a connected client asks for it.

	If the program was invoked with the command line option
	"/UnregServer" or "-UnregServer", then it will attempt to delete
	the type library from the registry.

	Normally the argument should be an instance of
	`<coclass-type-info>', although if there is just a single dispatch
	interface, it is also possible to pass a `<disp-type-info>'
	provided it was created with a unique `uuid:' (not just
	`$IID-IDispatch'); it will then act as both an interface ID and a
	class ID.

	The type library is identified by its version number and locale as
	well as its class ID (type info options `major-version:',
	`minor-version:', `locale:', and `uuid:', respectively) so
	different versions of a program can be installed at the same time,
	and one program can register multiple type libraries with different
	locales (but same class ID, version, and help directory).
	(However, there will still be only one call to
	`make-object-factory', since it does not depend on the locale.)

	[Issue: to really allow multiple type libraries, wouldn't the
	version and locale need to be reflected in the generated file
	name?]



Low-level API
-------------

Besides the high-level utilities described above, the `ole-automation'
library also provides an FFI interface to the low-level API for
OLE Automation, as described in the Microsoft documentation.

See the companion file "ole-user-doc.text" for some general information
about OLE support in Dylan.  It explains the correspondence between the
C/C++ names in the Microsoft documentation and the Dylan identifiers.
If you need to refer to the source code of the libraries, you will also
need to be acquainted with the facilities of the `C-FFI' library, which is
specified in another file in this directory.  Note that some of the source
files were generated by an automatic translation of the C/C++ header files
by running "make -f make-sources".

The following OLE Automation API names are not being supported because they
are considered obsolete: 
  INTERFACEDATA, METHODDATA, PARAMDATA, CreateDispTypeInfo




Implementation notes
--------------------

The remainder of this document is a collection of half-baked implementation
notes that may not be of any interest to users.

Much of the complexity of the OLE Automation interfaces IDispatch,
ITypeInfo, etc., concerns the data structure that are used.  Much of this
is a clumsy way to allow C to do things like run-time typing and
heterogeneous collections which are trivial for Dylan.  So just allowing
these data structures to be accessed as the corresponding Dylan abstractions
instead of the C structures should allow OLE Automation code in Dylan to be
much simpler than in C.

Following is a description of how I'm supporting various specific data
types.

Basic Strings

  The C pointer type `BSTR' corresponds directly to the Dylan class
  `<BSTR>', defined as:

    define C-subtype <BSTR> ( <C-unicode-string> ) end;

  Note that this can be used as both a <C-pointer> and a <string>.  Methods
  are provided for `size' and `empty?' which use the Win32 function
  `SysStringLen' to get the recorded length instead of scanning for a
  terminating null.  (`empty?' also returns `#t' for a NULL pointer.) 
  A `make' method is provided which uses `SysAllocStringLen', and a
  `destroy' method which calls `SysFreeString'.  Also, an `as' method
  converts from a <C-unicode-string> to a <BSTR> by calling
  `SysAllocString'.  (Conversion from other kinds of strings will happen by
  using the existing general-purpose sequence conversion methods.)

  For convenience, the constant $NULL-BSTR is a null pointer of type
  <BSTR>.

  The function `copy-as-BSTR' will copy any kind of <string> to a newly
  allocated <BSTR>; this should be used instead of `as' when returning a
  value that will be deallocated by the caller.  It returns $NULL-BSTR if
  the argument is `#f' or a NULL pointer.


Variants

  The Dylan class <LPVARIANT> is simply a pointer to a C VARIANT structure,
  but instead of using the slot accessors, the Dylan programmer can simply
  use `pointer-value' and `pointer-value-setter' to read or write the Dylan
  object corresponding to the value represented by the structure, with any
  necessary conversions being done automatically according to the type
  indicated by the `vt' field.

  A VARIANT structure representation of a Dylan value (limited to a <real>,
  <machine-word>, <boolean>, <character>, <string>, <Interface>, or an
  <array> or <sequence> thereof) can be constructed either by:
    make(<LPVARIANT>, value: object)
  or:
    as(<LPVARIANT>, object)

  An `empty?' method is provided which returns true if the C type code is
  VT_EMPTY.   `pointer-value' will signal an error if called on an empty
  variant. 

  The constant $SQL-NULL is the Dylan object corresponding to the C type
  code of VT_NULL.  A method is provided for `null?' which returns true if
  the pointer is null or if the type is VT_NULL.


Safe Arrays

  These are "safe" only from the perspective of C, so that name doesn't
  make much sense in Dylan.  Instead, the Dylan classes <ole-vector> and
  <ole-array> will be used to represent a pointer to a `SAFEARRAY'
  structure.  These classes are defined as:

    define constant <LPSAFEARRAY> = <SAFEARRAY>.pointer-type;

    define C-subtype <ole-array> ( <LPSAFEARRAY>, <array> )
    end;

    define C-subtype <ole-vector> ( <ole-array>, <vector> )
    end;

  An `import-value' method will map an <LPSAFEARRAY> to an <ole-vector> if
  it is one-dimensional, or else to an <ole-array>.

  Access methods are provided to support the full array and vector
  protocols so that Dylan code can treat these simply as Dylan collections,
  without ever needing to use the FFI structure slot accessors.  The
  elements of a SAFEARRAY are VARIANT structures, so `element' or `aref'
  both gets the designated element and uses `pointer-value' to convert it
  to a Dylan object.

  The function `ole-vector' is like the standard Dylan function `vector'
  except that it returns an <ole-vector> instead of a <simple-vector>, and
  a call to `destroy' will be needed to explicitly deallocate it.  If the
  elements are all of the same type, an appropriate representation will be
  chosen for the array, otherwise each argument is converted to a VARIANT
  structure as an element of the SAFEARRAY.

  Note: the dimensions in a SAFEARRAY specify both a lower and upper bound
  for the index, but since Dylan does not support alternate lower bounds,
  index 0 will always correspond to the first element when viewed as a
  Dylan array.


Dispatch member functions

  In order to fit into the assumptions of the IDispatch interface, Dylan
  functions which implement IDispatch operations need to conform to a few
  conventions:

    * The first argument of the function will always be the <IDispatch>
      instance.  The remaining arguments correspond to the dispatch
      arguments. 

    * `#key' arguments may be used to correspond to OLE Automation named
      arguments.   `#all-keys' would not be useful.

    * If the function uses `#rest' but not `#key', then it will be
      described to a C user as accepting a "safe array" as the value of an
      additional argument.

    * In order to be mappable between C and Dylan, the argument types and
      return type are limited to the following:

	 <integer>, <character>, <single-float>, <double-float>, <boolean>,
	 <PLARGE-INTEGER>, <BSTR>, <LPDISPATCH>, <LPUNKNOWN>, <machine-word>
 
      or a `limited' subtype or an array or vector of any of these types.

    * The first value returned by the function should be a status code
      ($S-OK if nothing wrong).  A second value may be returned as the
      result value of the operation.  More than two result values are not
      meaningful.


Dispatch Parameters

  The class <LPDISPPARAMS> is a pointer to a C DISPPARAMS structure, which
  designates the function arguments for an "Invoke" operation.

  A `size' method is provided which returns the number of arguments, and an
  `empty?' method is provided to return true if there are no arguments.

  An `element' method can be used to obtain an individual argument value,
  converted from a VARIANT to a Dylan object; the index is the actual
  argument order, which is reversed from the order in the DISPPARAMS
  structure.   This method does not distinguish named from positional
  arguments. 

  For use in implementing the method `IDispatch/Invoke', after selecting
  the appropriate function to call, the function `apply-to-dispparams' can
  be used to call the function, passing as arguments the Dylan objects
  corresponding to a DISPPARAMS structure, including converting the
  so-called "named" parameters to Dylan keyword arguments.

  For example, if the operation is implemented by a function with the
  signature:
      frob(this :: <my-dispatch>, a, b, #key x, y)
  then the Invoke method could be written like this:

    define method IDispatch/Invoke(this :: <my-dispatch>,
			dispidMember :: <integer>,
			riid :: <REFIID>,
			lcid :: <integer>,
			flags :: <integer>,
			params :: <LPDISPPARAMS>,
			pvarResult :: <LPVARIANT>,
			pexcepinfo :: <LPEXCEPINFO>)
     => ( status :: <SCODE>, ArgErr :: <integer> );

      // [... use dispidMember to pick function to be called ...]

      let ( status, result ) =
	apply-to-dispparams(frob, this, params);
      unless ( null-pointer?(pvarResult) )
	pointer-value(pvarResult) := result;
      end unless;
      values( status, 0 )
    end method;

  If there are named arguments, `apply-to-dispparams' uses function
  introspection to find the keyword symbols to be used to identify the
  arguments in the Dylan argument sequence.  Thus if the caller provides
  two positional arguments and one named argument with a disp id of 3
  [fourth argument, counting from 0], then the effect is: 
    frob(instance, arg1, arg2, y: arg3)

  Maybe we should also have some mechanism for catching Dylan errors and
  filling in the EXCEPINFO structure accordingly?

  For going the other direction, there should be a function for easily
  constructing a DISPPARAMS structure.  It could look something like this:

    make-dispparams( named-args :: <sequence>, named-arg-ids :: <sequence>,
	             #rest positional-args ) => params :: <LPDISPPARAMS>;


But this stuff is supposed to be done using ITypeInfo instead, which
involves some more data structures:

Function Description

  The Dylan class <LPFUNCDESC> is a pointer to a C FUNCDESC structure.  In
  order to create a type library, such as by calling
  `ICreateTypeInfo::AddFuncDesc', we want an easy way to construct one of
  these for a Dylan function.  So maybe we'll have something like:

    make-funcdesc(function :: <function>, 
		memid :: <integer>,	// Function member ID 
		argument-types :: <sequence>, // type of each argument
		result-type :: false-or(<type>), // type of result value
		scodes :: <sequence>,	// Legal SCODES for the function.
		flags :: <integer>	// logior of $FUNCFLAG-...
		) => result :: <LPFUNCDESC>;

  The argument-types here correspond to the arguments following the first
  argument, which is the interface instance.  The types of the arguments
  needs to be provided here because `function-specializers' doesn't provide
  the types of keyword arguments, and because the actual specializers may
  not be specific enough to be mapped unambiguously to C data types.

  Another function should be provided to create a FUNCDESC for a property
  getter or putter.  [Not yet sure what data is relevant there.]

  This also involves a TYPEDESC structure for specifying the type of an
  argument; we should be able to have a function that will create one of
  these given a Dylan class object.


Title:  OLE Automation library for Dylan

Author: David N. Gray  <gray@harlequin.com>

Date:	June 13, 1996 - original release
	December 20, 1996 - update for evolving design
	January 16, 1997 - re-write to provide a more user-oriented view.
	January 28 and May 5, 1997 - minor updates.
	June 6, 1997 - clarify factory options.
	July 18, 1997 - fix handling of vectors.
	August 19, 1997 - more fixes for vectors.
	September 12, 1997 - update minor details.
	October 3, 1997 - support implementing stock properties.
	October 17, 1997 - update details of type library registration.
	December 4, 1997 - support in-process servers;
			disp-id is not always an <integer>.
	January 8, 1998 - add indexed properties.
	January 20, 1998 - add support for by-reference arguments; clarify
			server side of indexed properties; add
			`<OLE-server-condition>' and `exit-invoke'.
	February 26, 1998 - add  `pass-as', `out-ref', etc.

Status: This describes what is currently implemented for release 1.0
	of Functional Developer.

Copyright: 1997,1998 Functional Objects, Inc.  All rights reserved.

Version:  $HopeName: D-doc-lib!ole-automation.text(trunk.15) $
	  $Date: 2004/03/12 00:12:06 $

--------------

Preface
-------

This document describes how a Dylan program can use "OLE Automation"
through the use of the Dylan `ole-automation' library.  The library
provides both the low-level API, which is described near the end of this
document, and higher level utilities, which will be presented first.  
The high-level view is intended to be usable without needing any prior
knowledge of OLE and without needing to read any of the Microsoft
documentation for OLE Automation.  A tutorial introduction is provided
first, followed by more detailed reference information.


Concepts and terminology
------------------------

"OLE Automation" is basically a mechanism by which two programs can
communicate with each other, using an interface that can be specified
independently of the implementation.  The two programs don't even need to
be written in the same language.  The communication is done by means of a
"dispatch interface" (also called "IDispatch") which is implemented by the
"server" program and used by the "client" program, also known as an
"Automation controller".  In the server, the dispatch interface is
represented as an instance of a Dylan class which has methods defined which
can be invoked by the client.  In the client, the dispatch interface is
represented by a Dylan object which supports methods for accessing the
server.

A dispatch interface can support two kinds of functionality: "properties",
which are like slots whose value can be read or written, and "methods",
which are functions that can be called on the interface implementation
object and can accept additional parameters and may return a single result
value.  (The terms "dispatch method" or "member method" will be used here
to try to distinguish this concept from a Dylan `method'.)  Each interface
can support any number of properties and methods; they are accessed using a
"disp-id" ("dispatch ID") which is an integer index.  (It should not be
assumed to be represented as a Dylan <integer> because some servers use
larger values.)  Each property or
method also has a name, which is a string (case insensitive).  The client
can query the server to look up the disp-id corresponding to a name.  Some
standard properties, called "stock properties", have a special reserved
disp-id, and so don't need to be looked up by name.

A program can implement more than one dispatch interface, but it will
normally implement a single "OLE object", which the client can connect to
and query to obtain the component interfaces.  The description of the
object as a whole is called a "coclass", which stands for "component object
model class".  Each such kind of object is identified by a "class ID",
which is a "GUID" ("Globally Unique IDentifier"), a 128-bit number.  (Also
sometimes called a "UUID" -- "Universally Unique IDentifier").  A client
program requests an instance of the class ID, which might either connect to
an already running server, or initiate execution of the appropriate server
program by looking up the class ID in the Windows System Registry to find
the pathname of the program to be run.  Note that the word "class" is being
used here with a different meaning than a Dylan `<class>'.

The registry information for a class ID may also include a "type library",
which provides a description of all of the interfaces supported by the
server.  The type library can be examined by a potential client or by
various utility programs without actually running the server program.  For
example, the Microsoft "OLE Viewer" utility can use the type library to
display a detailed description of the services provided by an Automation
server, and the Visual C++ wizards can use a type library to generate the
skeleton for a client program to use the server.  Each of the dispatch
interfaces in the type library is described by a "typeinfo", and there is
also a coclass typeinfo for the object as a whole.

When a server program starts up, it doesn't actually create the OLE object
right away.  Instead, it first creates a "class factory" object which is
made available to other programs to create an instance of a particular
class ID.  The client program then connects to the class factory and
directs it to instantiate the OLE object.

OLE Automation is a layer on top of "COM", which stands for "Component
Object Model", so some of the names used by Automation applications are
actually defined in the Dylan `COM' library instead of the `OLE-Automation'
library, but they are all re-exported by `OLE-Automation' so that the user
doesn't need to directly `use COM'.  By convention, functions from the
higher-level library are generally shown beginning with a lower case
letter, while lower-level function names begin with an upper case letter,
the same as in the Microsoft documentation for use from C or C++ (except
that "-" is used in place of "_" and a "$" or "?" may be added where
appropriate).  (Note that Automation applications do _not_ need to use the
Dylan `OLE' library, which is concerned with compound documents.)



Dylan Automation controller
---------------------------

First, let's look at what the client side looks like in Dylan, since it is
simpler than the server.  This section is a tutorial introduction; more
complete reference information follows later in this document.

For the simple case of a single dispatch interface, the client initiates
the connection by doing:

  let disp-interface = create-dispatch(class-id);

A class ID (or interface ID) is documented as a series of hexadecimal
digits such as:

  e90f09e0-43db-11d0-8a04-02070119f639

This can either be used directly as a string of the form 

  "{e90f09e0-43db-11d0-8a04-02070119f639}"

or (more efficiently) the internal representation can be constructed by the
function `make-GUID' described in the reference section.  The internal GUID
can also be converted from the string representation like this:

  define constant $class-id =
    as(<REFCLSID>, "{e90f09e0-43db-11d0-8a04-02070119f639}");

The dispatch interface returned by `create-dispatch' can then be
manipulated by doing

  let disp-id = get-id-of-name(disp-interface, name);

to get the disp-id of the property or method having the given name
string.  The value of a property can be read by

  let value = get-property(disp-interface, disp-id);

or set by

  set-property(disp-interface, disp-id, new-value);

A method can be called by:

  let result = call-simple-method(disp-interface, disp-id, args, ...);

When the client is finished with the dispatch interface, it must call 

  Release(disp-interface);

to allow the server to terminate.

Also, before using any OLE facilities, a controller application should call
function `OLE-initialize()', and before terminating, the program should
call `OLE-uninitialize()'.  (This is done automatically for a Dylan server
application, but the structure of a controller application doesn't provide
a suitable place for knowing when to un-initialize.)

So a very simple example of an Automation Controller might look like:

  OLE-initialize();  // initialize OLE libraries
  let disp-interface = create-dispatch(class-id); // start server
  let disp-id = get-id-of-name(disp-interface, "frob"); // lookup method
  let result = call-simple-method(disp-interface,       // call the method
	                          disp-id, "foo", "bar");
  Release(disp-interface); // release the server
  OLE-uninitialize();  // shut down OLE

To make it even simpler, an application that fits this model can use the
macro `with-dispatch-interface' like this:

  with-dispatch-interface disp-interface (class-id)
    let disp-id = get-id-of-name(disp-interface, "frob"); // lookup method
    let result = call-simple-method(disp-interface,       // call the method
	                            disp-id, "foo", "bar");
  end with-dispatch-interface;

Furthermore, if a disp-id will only be used once, the member name can just
be passed directly to `get-property' or `call-simple-method' instead.  So
we could do:

  with-dispatch-interface disp-interface (class-id)
    let result = call-simple-method(disp-interface, "frob", "foo", "bar");
  end with-dispatch-interface;

If the server provides more than one interface, the additional interfaces
can be found by calling the COM function `QueryInterface', passing the
dispatch interface and the ID (from `make-GUID') of the desired interface.
For example:

  let ( status, foo-interface ) =
    QueryInterface(disp-interface, interface-id);
  if ( FAILED?(status) )
    error(...);  // requested interface not found
  else
    ... // use foo-interface
    Release(foo-interface); // don't forget to do this when finished
  end;

There is a complete example program in directory
"~dylan/app/sample-automation-controller/"; note the "README.text" file
which explains it.



Error reporting
---------------

Most of the low-level COM and OLE functions return a status code as the
first result value; this value can be tested by the functions `FAILED?' or
`SUCCEEDED?' to determine whether an error is indicated, and the value can
be compared against various named constants to check for specific error
conditions.  These constants are defined in the source files
"lib/com/com-err.dylan" and "lib/ole-automation/auto-err.dylan".  The type
of OLE status codes is called either `<SCODE>' ("status code") or
`<HRESULT>' ("result handle") -- these are two names for the same thing.
(The Microsoft documentation says that SCODE is the preferred term and
HRESULT is obsolete, but HRESULT is still used extensively in their own
documentation and examples.)  Note that the status code should not be
assumed to be an `<integer>'.

In order to simplify the user code, the high-level functions do not require
the user to check a status code.  Instead, if an error occurs, it will be
signalled as an instance of class `<ole-error>' (a subclass of `<error>').

If you call a low-level function and want to turn the status code into an
error, do like this:

   let status = foo(interface, whatever);
   check-ole-status(status, "foo", interface, whatever);

The call to `check-ole-status' will signal an `<ole-error>' if the call to
`foo' failed.


Data types
----------

Since the mechanisms of OLE Automation were designed for C and BASIC rather
than for Dylan, it doesn't support passing arbitrary Dylan objects.
However, instances of the following Dylan classes can be used as method
arguments and results and property values:  

  <integer>, <machine-word>, <byte-character>, <boolean>,
  <single-float>, <double-float>, <string>

Also, an OLE interface can itself be passed as an argument, and a
<sequence> or <array> can be passed provided that each element is of one of
these types.  (The elements don't necessarily have to be of the same class
if the server is prepared to accept heterogeneous data; that will be true
automatically if the server is implemented in Dylan.)  For a <sequence>,
the server will receive the data as a vector, regardless of which subclass
of <sequence> was used in the client.

Additionally, the special value `$SQL-NULL' can be passed as an argument to
indicate an unspecified value; this is intended to correspond to the null
value of SQL, not a C NULL pointer.

Note that, in general, C pointers cannot be passed because the client and
server don't necessarily have access to the same address space.
Essentially, it is a copy of the value that is being passed across the
interface.  However, for implementing "by-reference" parameter passing, it
is permissible to pass certain types of C pointers as argument values, but
the server can only use the pointer to load or store a value during the
duration of the call.  Alternatively, a client can use the convenience
functions `out-ref' and `inout-ref' to implement by-reference parameters
without direct handling of C pointers.

If a string is received as a method result or property value, it will be
represented as an instance of class `<BSTR>' ("BASIC string"), which is a
subclass of <string> (but not a <byte-string>).  These values use memory
space allocated by the Microsoft libraries, so to reclaim the memory space,
the function `destroy' needs to be called on the string when it is no
longer being used.  Similarly, a sequence or array received as a result or
property value will be an instance of `<ole-array>' or `<ole-vector>', for
which `destroy' should be called when finished with the value.
[Issue: would it be better for these to be automatically copied instead?]

Similarly, if an interface (such as an instance of <LPUNKNOWN> or
<LPDISPATCH>) is received as a method result or property value, you will
need to call `Release' on it when finished using it.

[Issue: support for Dylan representations of the OLE Automation date and
currency types should be added.]

In some cases, a server in another language may require an argument to be
passed with a particular representation even though it can't be
unambiguously inferred from the actual value.  A Dylan client can use the
function `pass-as' to specify the representation.  For example, using
the expression `pass-as(<C-long>, 1)' as a method argument forces the value
`1' to be passed as a `long' value even though it could fit in a `short'.



Dylan Automation server
-----------------------

To create an Automation Server in Dylan, you need to provide four parts:

 * A class and methods on that class which implement the functionality to
   be provided.

 * A description of the functionality that is being made available, so that
   clients can make queries about the server's capabilities and dispatch to
   their implementations.  (This is the information for the "type library".)

 * A "class factory" which will instantiate the implementation class when
   requested by a client.

 * Code to register the server so that clients can invoke it.

(For simplicity, we'll consider first the case of a single dispatch
interface.) 

The dispatch implementation class should be defined as a subclass of
`<simple-dispatch>'.  For example:

  define COM-interface <my-dispatch-object> ( <simple-dispatch> )
    slot my-property;
 ...
  end;

The syntax and semantics of `define COM-interface' is the same as for
`define class'.  Ideally, this would use `define class', but implementation
considerations in the current compiler (DFMC as of early 1997) require
some special additional handling for OLE interface classes.

You can define any slots that you want; they will be accessible to the
client only if that is enabled in the type library information.  For the
example above, if you want the slot to be a "property" which the client can
read or write, then the type library information could be defined like
this:

  define constant $my-type-info =
    make(<disp-type-info>,
	 properties: vector(make(<variable-description>,
				 name: "value",
				 documentation: "the value of this thingy",
				 getter: my-property,
				 setter: my-property-setter))
	);

The `name:' option specifies the property name that will be known to the
client; the Dylan class and function names will not be visible externally.
Either the `getter:' or `setter:' may be `#f' if that access is not to be
provided.  The `documentation:' is optional; it corresponds what is called
a "helpstring" in ODL.  Note that a property doesn't have to correspond to
a slot; it just needs an accessor method specialized on the class.  Any
number of properties could be specified as elements of the vector.  The
disp-id values will be assigned automatically; you don't need to know what
they are because the client will query for them by name.

Note that `setter: #f' just means that the value is not changeable by the
client, not necessarily that it is constant.  A property that really is
just a constant value can be specified like this:

       ...
	properties: vector( ...
			   make(<constant-description>,
				name: "pi",
				value: 3.1416),
			   ...

In this case, the type information contains the complete implementation of
the property; no slot or accessor functions are needed.

Nothing special needs to be done to implement indexed properties; if the
value of a property is a <collection>, then indexed access from clients
will be supported automatically, invoking `element' for a single index, or
`aref' when two or more.  Note that indexing can be used to access
individual elements of a <collection> even if it is not a <sequence> or
<array> and hence can't be passed as a whole, and the indexes don't
necessarily have to be integers.

Now suppose we want to provide some methods for the dispatch interface.
The implementation might look something like this:

  define function foo( this :: <my-dispatch-object> ) => status :: <SCODE>;
 ...
  end;

  define function bar(this :: <my-dispatch-object>, name :: <BSTR>,
		#key color :: <BSTR>, size :: <integer>)
	 => (status :: <SCODE>, value :: <integer>);
 ...
  end;

The first argument must always be specialized on the dispatch
implementation class, and the remaining arguments correspond to the
dispatch arguments.  The first value returned must always be an OLE status
code.  The constant `$S-OK' should be returned when there is no error.
Here are a few general purpose error codes that might be of use:

  $E-UNEXPECTED	       Unexpected failure
  $E-NOTIMPL	       Not implemented
  $E-OUTOFMEMORY       Ran out of memory
  $E-INVALIDARG	       One or more arguments are invalid
  $E-POINTER	       Invalid pointer
  $E-HANDLE	       Invalid handle
  $E-ABORT	       Operation aborted
  $E-FAIL	       Unspecified error
  $E-ACCESSDENIED      General access denied error

A Windows error code, such as returned by Windows function `GetLastError',
can be converted to a corresponding `<SCODE>' value by the function
`HRESULT-FROM-WIN32'.

Instead of returning from the function, the function `exit-invoke' may be
called with a status code as its argument to immediately return the status
code.

If `<abort>' is signalled during execution of the method (or a property
getter or setter), a handler in the OLE-Automation library will catch it
and return `$E-ABORT' to the client.

A second value may be returned as the result value of the dispatch method;
more than two result values are not meaningful.  In order to be mappable
between C and Dylan, the argument types and return type are limited to the
following:

  <integer>, <character>, <single-float>, <double-float>, <boolean>,
  <PLARGE-INTEGER>, <BSTR>, <LPDISPATCH>, <LPUNKNOWN>, <machine-word>

Note that `pass-as' may be used if necessary to constrain the
representation of the result value.
 
The type information for these methods might look like:

    make(<disp-type-info>,
	 properties: vector(...),
 	 methods: vector(make(<function-description>,
			      function: foo,
			      name: "foo"),
			 make(<function-description>,
		 	      function: bar,
			      name: "bar",
			      argument-names: #["name", "color", "size"],
			      argument-types: vector(<BSTR>,<BSTR>,<C-long>),
			      result-type: <C-unsigned>)
			)
	   )

The `argument-types:' and `result-type:' options are the C type designators
if they can not be properly inferred from introspection of the designated
`function:'. 

See the reference description of `<disp-type-info>' later for other options
that can be used.

Alternatively, you can use the macro `define dispatch-interface' as a
high-level way to specify both an implementation class and its associated
type information.  For example:

  define dispatch-interface <my-dispatch-object> ( <simple-dispatch> )
    property my-property :: <integer>;
   ...

defines `my-property' as both a class slot and a dispatch property.
[Further documentation for the macro is yet to be supplied.]

When a string or array is received by an Automation server as a method
argument, it will be a temporarily allocated value (an instance of <BSTR>,
<ole-array>, or <ole-vector>) that will be deleted after the method
returns, so you will need to make a copy of the data if you want to keep
it.  The function `copy-automation-value' may be used for this.  (Copying
is done automatically when setting a property.)  Similarly, if an argument
is an interface (such as <LPUNKNOWN> or <LPDISPATCH>), you will need to
call `AddRef' on it if it will be kept for use after the call returns (and
later call `Release' when finished with it).

Besides the dispatch methods, your class will also probably need to provide a
method for the `terminate' function, which will be called when the client calls
`Release' when finished with the interface.  This can be used to clean up
data structures or to terminate the program.  (It may be thought of as
corresponding to a "destructor" in C++.)  For example:

  define method terminate (this :: <my-dispatch-object>) => ()
    next-method(); // don't forget this!
    // post ourselves a close message to end the program:
    PostMessage(this.my-window-handle, $WM-SYSCOMMAND, $SC-CLOSE, 0);
    values()
  end method terminate ;


It is also possible to create an OLE object which supports more than one
dispatch interface.  This can be done like this:

  define constant my-coclass-type-info =
    make(<coclass-type-info>,
	 uuid: make-GUID(...), // class ID
	 interfaces: vector(make(<component-interface-description>,
				 class: <my-dispatch-object1>,
				 typeinfo: make(<disp-type-info>, ...)),
			    make(<component-interface-description>,
				 class: <my-dispatch-object2>,
				 typeinfo: make(<disp-type-info>,
						uuid: make-GUID(...), ...),
				 ...)
			    ...
			    ));

Each element of the `interfaces:' sequence specifies an interface as a type
info and the Dylan class to be instantiated to implement it.  By default,
the first interface listed will be the default interface that will be
returned by `QueryInterface' for `$IID-IDispatch' (although it may specify
an alternate `uuid:' also); the remaining interfaces need to specify the
`uuid:' option for the ID that will be used to select them.  Also note that
each typeinfo will need to specify the `name:' option so that they have
distinguished names for the "type library".  By default, the class factory
will instantiate the class `<simple-component-object>', but you can specify
a user-defined subclass thereof by the `class:' initialization keyword for
`<coclass-type-info>'.  This is a subclass of `<IUnknown>', so its
`initialize' method could create additional interfaces using it as the
controlling unknown if you want your OLE object to support other interfaces
besides IDispatch.  Also, `<coclass-type-info>' accepts all of the same
optional keywords as `<disp-type-info>', which can be used to provide type
library documentation for the object as a whole.  This might be a reason to
use it even if there is only one interface.  For example:

       make(<coclass-type-info>,
	    name: "foo", documentation: "la de dah",
	    major-version: 1, minor-version: 2,
	   ...

Alternatively, the type information can be specified by using the macro
`define coclass'.  For example:

  define coclass my-coclass 
    name "foo";
    uuid make-GUID(...); // class ID
    default interface <interface-1>;
    interface <interface-2>;
   end;

where each interface class was defined by `define dispatch-interface'.
[Further documentation for `define coclass' is yet to be supplied.]

The remaining steps for handling registration and start-up of a server are
different for a "local server" (an EXE file running as a separate process)
and an "in-process server" (a DLL file that runs in the controller's
process), so they will be described in separate sections.

Local server initialization
---------------------------

Rather than using `make' to directly instantiate a dispatch object, this is
usually done by a "class factory" when requested by a client.  The class
`<class-factory>' is provided as a convenient way to implement this.  For
example:

   make(<class-factory>,
	class: <my-dispatch-object>,
	typeinfo: make(<disp-type-info>, ...),
	clsid: make-GUID(...))

will create and register a class factory so that the designated class will
be instantiated when a client tries to invoke a server for the designated
class ID.  Additional options which may be used include any additional
initialization keywords accepted by the class being instantiated, plus the
following class factory options:
  server-context:    defaults to `$CLSCTX-LOCAL-SERVER'.
  connection-flags:  defaults to `$REGCLS-SINGLEUSE'.

The function `revoke-registration' may be called on a class factory
instance to cancel the registration.  This should be done before the
program terminates.

As a convenience, making a `<class-factory>' and calling
`revoke-registration' can be combined by using the macro
`with-class-factory' like this:

   with-class-factory ( class: <my-dispatch-object>,
			typeinfo: make(<disp-type-info>, ...),
			clsid: make-GUID(...) )
     ... // body of application
   end with-class-factory;

When using a `<coclass-type-info>', it contains everything the class
factory needs, so the factory can be created by just doing:

  let factory = make-object-factory(my-coclass-type-info);

Finally, for an Automation Controller to be able to invoke an Automation
Server program that is not already running, the server must be registered
in the Windows System Registry.  This specifies which program to execute
for the class ID.  In order to do this, the main program of the server
should have code like this wrapped around it:

    if ( OLE-util-register-only?() ) // just [un]register and terminate
      register-automation-server(class-id, prog-id, title, ...);
      register-type-library(coclass-type-info);
    else
      ...  // do everything else here
    end if;

Then if the program is executed with the command-line argument "/RegServer"
(case insensitive) it will just record itself in the registry and
terminate.  The command-line argument "/UnregServer" may be used to remove
the registry entries.  The program's full pathname is recorded in the
registry, so it will need to be re-registered if it is moved to another
directory. 

After an automation server creates its class factory, it should enter a
normal Windows event loop like for any Windows program.  Requests from the
client will be automatically dispatched by the default message dispatch
mechanism.   So, putting it all together, the main program for an
automation server might look something like this:

  define constant $my-class-id = make-GUID(...);

  define method main-program () => ()

    if ( OLE-util-register-only?() ) // just [un]register and terminate
      register-automation-server($my-class-id, "Foo.Bar",
				 "a simple OLE Automation server example");
    else
      initialize-my-application(); // create window etc.
      // create and register the factory object:
      with-class-factory (clsid: $my-class-id,
			  class: <my-dispatch-object>,
 	                  typeinfo: make(<disp-type-info>, ...))
	// normal Windows event loop:
	with-stack-structure ( pmsg :: <PMSG> )
	  while( GetMessage(pmsg, $NULL-HWND, 0, 0) )
	    TranslateMessage(pmsg);
	    DispatchMessage(pmsg);
	  end while;
	end with-stack-structure;
      end with-class-factory;
      values()
    end if;
  end method main-program;

There is a complete example of a server application in directory
"~dylan/app/sample-automation-server/".  See its "README.text" file for an
explanation. 

However, if the program uses DUIM to implement its user interface, the
event loop will be provided by DUIM, so the main program will look
something like:

  define method main-program () => ()
    if ( OLE-util-register-only?() ) // just [un]register and terminate
      register-automation-server($my-class-id, "Foo.Bar",
				 "a simple OLE Automation server example");
    else
      let frame = make(<my-frame>);
      with-class-factory (clsid: $my-class-id,
			  class: <my-dispatch-object>,
 	                  typeinfo: ...))
        start-frame(frame);
      end with-class-factory;
    end if;
  end method main-program;

Some application programs can be used either interactively or by Automation
control.  In such a case, you might want to create a class factory only if
the program was actually initiated by an Automation controller.  For this
purpose, you can do something like this:

   ...
    let factory = #f;
    if ( OLE-util-automation?() )
      factory := make(<class-factory>, ...);
    end if;
   ... // body of program
    revoke-registration(factory); // does nothing if argument is #f
   ...


In-Process server initialization
--------------------------------

For a server that is built as a DLL file instead of an EXE file,
registration and start-up of the server is handled by code generated by the
following macro call, which should appear at the end of the last source
file:

  in-process-automation-server(typeinfo: make(<disp-type-info>, ...),
                               class-id: $my-class-id,
                               prog-id: "Foo.Bar",
                               class: <my-dispatch-object>,
                               title: "in-process Automation server example");

The event loop will be provided by the container application.
Any windows used by the server should be created in the server object's
`initialize' method and destroyed in the `terminate' method.

Do not call `ExitProcess' or `PostQuitMessage' from an in-process server
because that would terminate the container process.

To actually register the DLL file, pass it as the argument to the Window
utility program "REGSVR32".  It supports these options before the file
name:
  /s    Suppress the dialog box reporting completion.
  /c    Console output instead of dialog box.
  /u    Unregister instead of register.

There is a complete example of an in-process server in directory
"~dylan/app/inproc-automation-server/".  See its "README.text" file for an
explanation. 



Class reference
---------------

Following is a more detailed specification of the data types provided by
the `OLE-Automation' library.

  <LPUNKNOWN>						Class

	Abstract super-class for all OLE interfaces.

  <LPDISPATCH>						Class

	A subclass of <LPUNKNOWN> which is the superclass for any objects
	that act as an Automation IDispatch interface.

  <BSTR>

	"BASIC String" -- this is a subclass of `<string>' that corresponds
	to the string representation used by OLE Automation property values
	and dispatch method arguments.  The elements are 16-bit Unicode
	characters. 

	Besides supporting the full <string> protocol, this class can also
	be regarded as a C pointer.  (It is a subclass of the C-FFI type
	`<C-unicode-string>'.) The constant `$NULL-BSTR' can be used to pass
	a NULL pointer in place of a string.  The function `null-pointer?'
	can be used to test a received `<BSTR>' to see if it is a NULL
	pointer.  However, a NULL pointer is treated the same as an empty
	string by the iteration protocol, so it may not be necessary to do
	this test.

	These strings are allocated memory space by the Microsoft OLE
	library, so space is not reclaimed by the Dylan garbage collector.
	Instead, the function `destroy' needs to be called on a `<BSTR>'
	when finished with it.

	Note that `as' may be used to convert between `<BSTR>' and other
	string types. The function `copy-as-BSTR' will copy any kind of
	`<string>' to a newly allocated `<BSTR>'; this should be used
	instead of `as' when returning a value that will be deallocated by
	the receiving program.  It returns `$NULL-BSTR' if the argument is
	`#f' or a NULL pointer.

  <ole-array>

	This is a subclass of both `<array>' and the C pointer type
	`<LPSAFEARRAY>'.  It allows the Dylan array protocol to be used on
	data that is actually allocated as a C `SAFEARRAY' structure.  The
	function `destroy' needs to be used to deallocate the storage when
	no longer needed.

	For arrays received by Dylan from an OLE Automation call, it will
	appear as an `<ole-vector>' if it is one-dimensional, otherwise as
	an `<ole-array>'.

	Note: the dimensions in a SAFEARRAY specify both a lower and upper
	bound for the index, but since Dylan does not support alternate
	lower bounds, index 0 will always correspond to the first element
	when viewed as a Dylan array.
 
  <ole-vector>

	This is a subclass of both `<ole-array>', and `<vector>'.  It
	supports using the full Dylan vector protocol on one-dimensional
	vectors passed in an OLE Automation call.

	The function `ole-vector' can be used like `vector' to construct an
	`<ole-vector>' containing the function arguments.

	If you construct one of these, remember that `destroy' needs to be
	used to deallocate the storage.

 <class-factory>

	This class provides an implementation of the COM IClassFactory
	interface.  Making one causes it to automatically be registered
	with the system for use by potential clients.  The instance is not
	directly used by the program except that the function
	`revoke-registration' needs to be called on it before the program
	terminates. 

	The following initialization keywords are available:

	  clsid:	The class ID which identifies the service being
			provided.  Required.  This can be represented as
			either a `<REFCLSID>' (as from `make-GUID') or a
			string (containing 32 hexadecimal digits within
			braces).

	  class:	The Dylan class (usually a user-defined subclass of
			`<simple-dispatch>') which is to be instantiated
			when requested by the client.  Required.

	  args:		Optional sequence of initialization arguments to be
			passed to `make' when instantiating the object. The
			default is to pass the same arguments as for the
			`<class-factory>' (`<simple-dispatch>' accepts
			and ignores those that are only for the factory,
			and `<class-factory>' ignores any that it doesn't
			recognize.)   Note that `<simple-dispatch>'
			requires `typeinfo:' to be supplied.
 
	  server-context:  Indicates where the server is running.  See the
			description of `create-dispatch' below for a list
			of possible values.  Defaults to
			`$CLSCTX-LOCAL-SERVER'.  `$CLSCTX-INPROC-SERVER'
			may be used instead to suppress external
			registration of the factory.

	  connection-flags:  One of the following constants:
 		 $REGCLS-SINGLEUSE   - only one connection allowed (default)
		 $REGCLS-MULTIPLEUSE - multiple connections permitted
		 $REGCLS-MULTI-SEPARATE - multiple connect, separate control

	Any other keyword arguments are passed in the `make' call when the
	Dylan class is instantiated.  Note that `<simple-dispatch>'
	requires `typeinfo:' to be supplied.


  <simple-dispatch>

	Abstract subclass of `<LPDISPATCH>' which provides an
	implementation of the IDispatch interface.  User-defined subclasses
	of this will provide the actual properties and methods that are
	accessible through the interface.  Remember that `define
	COM-interface' needs to be used for defining subclasses.

	Note that this is usually instantiated by a `<class-factory>', rather
	than by calling `make' directly.

	The initialization keywords are:

	  typeinfo:	The ITypeInfo interface which describes the
			services being provided.  Usually this will be an
			instance of `<disp-type-info>'.  Required.

			For supporting multiple locales, the value may be a
			`<collection>' of `<disp-type-info>' which will be
			indexed by the locale code.
			[Issue: this needs more thought.]
 
	  controlling-unknown:  Designates the IUnknown interface if
			aggregation is being used to provide multiple
			interfaces from a single OLE object.  Optional.
			Note that this will be provided automatically if
			the aggregation is created by using
			`<coclass-type-info>' and `make-object-factory', so
			it should be rare that this needs to be
			explicitly specified.
 
  <disp-type-info>

	This class is instantiated to provide an implementation of the
	ITypeInfo interface describing a single IDispatch interface.
	Following are the init keywords:

	  name:		 name of the interface (a string).

	  uuid:		 GUID that identifies the interface.
			 (default is `$IID-IDispatch')
			 This is preferably an instance of `<REFGUID>' (from
			 `make-GUID') but it will also accept a string
			 representation (containing 32 hexadecimal digits
			 within braces).

	  properties:	 a <sequence> in which each element is an instance
			 of '<variable-description>' or
			 `<constant-description>' that specifies one
			 property.  (default is no properties)

	  methods:	 a <sequence> in which each element is an instance
			 of `<function-description>' that specifies a
			 member method.  (default is none)

	  documentation: documentation string. (called "helpstring" in ODL)

	  help-file:	 name of help file for WinHelp.  (default is none)

	  help-context:  position in WinHelp file where this interface is
			 documented.   Optional.

	  major-version: major version number (defaults to 0)

	  minor-version: minor version number (defaults to 0)

	  locale:	 internationalization locale 
			 (defaults to 0, meaning neutral)

	  inherit:	 Base type.  (Optional)  If specified, the value
			 should be another instance of <disp-type-info>
			 which the current type inherits from.  The current
			 type will support all of the properties and
			 methods of the base type in addition to its own.
			 Some of the other options will default from the
			 base type, where appropriate.  Note that type info
			 inheritance is implemented separately from the
			 Dylan class hierarchy.

  <variable-description>

	Describes one property of a dispatch interface.  Init options are:

	  name:		string that is the name of the property.  Required.

	  getter:	either
			  a Dylan function that takes the interface as the
			  sole argument and returns the value of the
			  property
			or
			  `#f' if the property is not externally readable.
			(default is #f)

	  setter:	a Dylan function that changes the value of the
			property, taking the new value and the interface as
			its arguments,  or `#f' if the value cannot be
			changed by the client.  (default is #f)

			Note special case: if the value of the property is
			an interface pointer (such as <LPUNKNOWN> or
			<LPDISPATCH>), then the setter method will need to
			call `AddRef' on the new value and call `Release'
			on the old value.

	  type:		The value is a C designator type from the C-FFI
			library, which is used to specify the data type to
			be used by a client written in C or C++.  Following
			are the legal values:

			  <C-int>, <C-short>, <C-long>, <C-float>,
			  <C-double>, <C-signed-char>, <C-character>, <CY>,
			  <DATE>, <BSTR>, <LPDISPATCH>, <LPUNKNOWN>,
			  <C-HRESULT>, <VARIANT-BOOL>, <VARIANT>
 
			It is also permissible to specify the corresponding
			Dylan type (such as <single-float>, <double-float>,
			<character>, or <boolean>).  <integer> is
			considered equivalent to <C-long>, and <string> is
			equivalent to <BSTR>.

			(Also, the low-level representation as an instance
			of `<LPTYPEDESC>' may be used here.)

			For an array, the element type must also be
			specified; this is done by using the function
			`ole-array-type' to construct a type description.
			For example, `ole-array-type(<C-float>)' for a
			vector or array of single floats, or
			`ole-array-type(<VARIANT>)' for a heterogeneous
			array.  Note that dimensions are not specified here.

			If the `type:' is not specified, one will be
			selected automatically to most closely match the
			Dylan type declared for the result value of the
			getter function.  The type must be specified one
			way or the other.  Note that the default is the
			type declared for the generic function; it is not
			sufficient to just specify the type for a slot,
			since there isn't enough context here to know which
			method is applicable.

	  documentation: a string providing a description of the
			property. (This is called a "helpstring" in ODL.)
			Optional.

	  help-context: position in WinHelp file where this property is
			documented.  Optional.  (Note that the name of the
			help file is specified in the `<coclass-type-info>'.)

	  disp-id:	An <integer> which is the disp-id by which the
			client will refer to this
			property.  Usually you would not specify this and
			the library will automatically assign a disp-id.
			This option needs to be specified when implementing
			a stock property.  For example:

			  make(<variable-description>,
			       name: "Value", disp-id: $DISPID-VALUE, ...)

  <constant-description>

	Describes one constant-valued property of a dispatch interface.
	Init options are:

	  name:		string that is the name of the property.  Required.

	  value:	The value of the property.  Required.

	  type:		C type, like for `<variable-description>' above.
			Defaults from the class of the value.

	  documentation: documentation string.  Optional.

	  help-context:  position in WinHelp file.  Optional.

	  disp-id:	Optional disp-id.


 <function-description>

	Describes one member method of a dispatch interface.
	Init options are:

	  name:		string that names the member method.  Required.

	  function:	The Dylan function or method that implements the
			functionality.  Required.  The function will be
			called with the dispatch instance as the first
			argument and the dispatch method arguments as the
			remaining function arguments.  It must return an
			`<SCODE>' as the first result value, and may
			optionally return a second result value which is
			the value returned from the dispatch member method.

			`#key' arguments may be used to correspond to OLE
			Automation named arguments.  `#all-keys' would not
			be useful.

			If the function uses `#rest' but not `#key', then
			it will be described to a C user as accepting a
			"safe array" as the value of an additional
			argument.

	  argument-names: a <sequence> giving the names of the dispatch
			method arguments.  The length must match the number
			of function arguments (including any `#key'
			arguments) after the dispatch interface.  Default
			is no arguments.  Note that even for `#key'
			arguments, these names that are exposed to the
			client don't have to match the Dylan identifiers;
			the correspondence is strictly by position order.
			A `#rest' arg does not have a name.

	  argument-types: a <sequence> giving the types of the arguments.
			Each element is either a C type like for the
			`type:' option of `<variable-description>' above,
			or an instance of `<ole-arg-spec>' returned by
			`out-ref' or `in-out-ref' to designate a
			"by-reference" parameter.

			The default is to attempt to infer the types from
			the declared Dylan types of the function arguments.

	  result-type:	the C type of the result value, or `#f' if no
			result.  Defaults according to the declared result
			values of the Dylan function.

	  documentation: documentation string.  Optional.

	  help-context:  position in WinHelp file.  Optional.

	  scodes:	 <sequence> of error code values that might be
			 returned.  The default is an empty sequence.
			 This is for documentation purposes only -- there
			 is nothing to prevent the function from returning
			 other codes not listed here.

	  flags:	 `logior' of $FUNCFLAG-... values.  Default is 0.
			 (Refer to the Microsoft documentation for the
			 FUNCFLAGS enumeration.)  This is not likely to be
			 necessary; it just fine-tunes the appearance of the
			 function in browsers.

	  disp-id:	 Optional disp-id.

  <coclass-type-info>

	This class is instantiated to provide an implementation of the
	ITypeInfo interface describing a "component object class" which can
	contain any number of dispatch interfaces.  The init keywords are:

	  name:		 name of the OLE object class (a string).

	  uuid:		 GUID that identifies the OLE object class.  Required.

	  class:	 the instance of <class> which is to be
			 instantiated to implement the object.  Defaults to
			 `<simple-component-object>'.  Usually it would be
			 overridden only by a user-defined subclass of
			 `<simple-component-object>', but the only
			 requirement is that it implement the IUnknown
			 interface and that it accept a `typeinfo:' init
			 argument with the instance of
			 `<coclass-type-info>' as the value.
 
	  args:		 a <sequence> of initialization keyword arguments
			 for instantiating the class (in addition to
			 `typeinfo:').  Defaults to empty.  There are no
			 init arguments applicable to
			 `<simple-component-object>', so this would be used
			 only if `class:' is also specified.

	  interfaces:	 a <vector> in which each element is an instance of
			 `<component-interface-description>' describing an
			 interface that is supported by the compound object.

	  documentation: documentation string.  (This is what will appear
			 as the name of the type library in the Microsoft
			 OLE2VIEW utility, which assumes a single line that
			 will be truncated at about 45 characters.)

	  help-file:	 name of help file for WinHelp.  (default is none)

	  help-context:  position in WinHelp file.

	  major-version: major version number (defaults to 0)

	  minor-version: minor version number (defaults to 0)

	  locale:	 internationalization locale (defaults to neutral)


  <simple-component-object>

	This class provides an implementation of a "compound class object".
	It can be instantiated directly, or the user may define a subclass.
	It takes one required init keyword, `typeinfo:', whose value is an
	instance of `<coclass-type-info>' (see above) which specifies the
	component interfaces which will be automatically instantiated when
	the object is instantiated.  This is a subclass of `<IUnknown>', so
	the function `QueryInterface' may be called on an instance to
	obtain one of the component interfaces.

	Note that subclasses need to be defined by `define COM-interface'
	instead of `define class'.


  <component-interface-description>

	This class is directly instantiated to specify one interface in a
	"compound class object".  The init arguments are:

	  typeinfo:	an ITypeInfo interface which describes the
			interface.  Usually this will be an instance of
			`<disp-type-info>'.  Required.

	  class:	The Dylan <class> which will be instantiated to
			implement the interface.  Should be a subclass of
			`<simple-dispatch>'.

	  args:		<sequence> of initialization arguments for the
			Dylan class (besides the `typeinfo:' and
			`controlling-unknown:' arguments that are
			automatically supplied).  Default is empty.
			This would only be needed for keywords added by a
			user-defined subclass.

	  flags:	Implementation flags -- an <integer> formed by
			`logior' of $IMPLTYPEFLAG-... values.  (Refer to
			the Microsoft documentation for the IMPLTYPEFLAGS
			enumeration.)  The default is 0.  The meaningful
			values are:

			  $IMPLTYPEFLAG-FDEFAULT
				Designates this interface as the default.
				If none have this flag, the first one
				listed will be used as the default.

			  $IMPLTYPEFLAG-FSOURCE
				This is a "source" interface -- i.e., one
				that is called by the server and should be
				implemented by the controller.

			  $IMPLTYPEFLAG-FRESTRICTED
				Designates a member that should not be
				visible or used externally.  (This is
				probably not useful in Dylan, since such a
				member could simply not be mentioned in the
				type info.)

			[Issue: maybe it would be simpler to not have this
			`flags:' option.  Source interfaces might be better
			specified as a separate sequence argument for
			`<coclass-type-info>'.]


  <ole-error>

	A subclass of `<error>' used to report OLE error codes.
	Use function `ole-error' or `check-ole-status' to create and signal
	one of these.
	The following accessor functions may be used on the error object:

	   ole-error-status	returns the low-level status code.
	   ole-error-context	name of the function that returned the code.
	   ole-error-instance   the interface that the function was acting on.
	   ole-error-args	a <sequence> of additional function
				arguments (not necessarily a complete list,
				just whatever else might be interesting).

  <OLE-server-condition>

	A subclass of `<condition>' which can be signalled to return a
	status code from a server method or property accessor.  See
	function `exit-invoke'.  The status code is set by the init keyword
	`status:' and accessed by the function `ole-server-status'.



Function reference
------------------

Many of the OLE Automation functions accept an optional `locale:' option
which can be used for internationalization.  Usually it would not be
specified, letting the locale default to the current user's default locale.
If you really need to specify a specific language, a locale value is
constructed by the function `MAKELCID' in the `win32-common' library.  See
also `MAKELANGID' and the associated `$LANG-...' and `$SUBLANG-...'
constants.  For example, you could do:

  define constant $British-english-locale =
    MAKELCID(MAKELANGID($LANG-ENGLISH,$SUBLANG-ENGLISH-UK),$SORT-DEFAULT);

[Issue: some more design work is probably needed before locales will really
be useful.]


Following is a more detailed specification of the functions provided by the
`OLE-Automation' library.

  OLE-initialize () => ()

	Ensure that the Microsoft OLE libraries have been initialized.  
	It doesn't hurt to call it more than once, but each call to this
	function should be balanced by a matching call to
	`OLE-UnInitialize'.

  OLE-uninitialize () => ()

	Release the Microsoft OLE libraries when finished using them.
	This should only be used to undo a matching call to
	`OLE-initialize'.  This allows freeing any resources used by the
	libraries, and ensures that any pending messages are handled and
	any open connections closed.

  with-OLE  ?body  end					[Macro]

	This convenience macro calls `OLE-initialize', executes the body
	forms, and calls `OLE-uninitialize' in a `cleanup' clause.

  make-GUID (l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) => (ID :: <REFGUID>)

	Creates a GUID ("Globally Unique IDentifier") object (class
	<REFGUID>, alias <REFCLSID> or <REFIID>) from the constituent
	integers.  This is used for specifying the OLE class ID of the
	server application, or the ID of an interface.  The utility program
	"UUIDGEN" from the Win32 SDK can be run at a DOS prompt to generate
	an ID for a new application.  For example, if "UUIDGEN" displays:

	  113f2c00-f87b-11cf-89fd-02070119f639

	this could be used directly in a registration file but needs to
	be formatted a little differently to become the arguments for this
	function:

	  define constant $my-class-ID =
		make-GUID(#x113f2c00, #xf87b, #x11cf,
			  #x89, #xfd, #x02, #x07, #x01, #x19, #xf6, #x39);

	The value returned is a C structure pointer, so the function
	`destroy' should be called on it if it is no longer needed.

	Since not all users will have the SDK, Functional Developer includes a
	"create-id" utility that can be used instead.

	[Temporary note: to avoid truncation, the compiler running under
	LispWorks requires that `as(<machine-word>, ...)' be wrapped around
	the first argument if the first digit is anything other than '0',
	'1', 'E', or 'F'.  This limitation is fixed in the native compiler.]

  as (class == <string>, guid :: <REFGUID>) => (s :: <byte-string>)  [Method]

	Converts the internal representation of a GUID to a representation
	as a string by calling the Microsoft library function
	`StringFromGUID2'.  The string has the form:
		"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
	where each `x' is a hexadecimal digit.

  as (class == <REFGUID>, s :: <string>) => (guid :: <REFGUID>)      [Method] 

	Calls the Microsoft library function `CLSIDFromString' to convert
	the string to a GUID.  The string may either represent the GUID in
	the form: 
		"{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"
	(the enclosing braces are a required part of the syntax; letters
	may be either upper or lower case), or else it will be looked up in
	the System Registry as a "ProgID" ("programatic identifier") string
	and the corresponding GUID will be returned.  An error is signalled
	if the string is not in the expected format and is not found in the
	Registry.
	
	The value returned is a C structure pointer, so the function
	`destroy' should be called on it if it is no longer needed.

  copy-automation-value (object) => (object)		[Generic Function]

	If the argument is an instance of <BSTR>, <ole-vector>, or
	<ole-array>, the returned value will be a corresponding Dylan
	object which has the same contents but does not use any C-allocated
	storage.  For example, the contents of an <ole-vector> will be
	copied into a <simple-vector>, with `copy-automation-value' being
	recursively called on each element.

	If the argument is of any other type, then it is returned unchanged.

	This function may be used by a dispatch method to ensure that a
	received argument value can be kept after the call returns, or by a
	client on a received property value or method result.

  QueryInterface(interface :: <LPUNKNOWN>, interface-id :: <REFGUID> )
		=> ( status :: <SCODE>, object :: <LPUNKNOWN> )

	Given one interface, find another interface supported by the
	server.  If an interface with the given GUID is found, the first
	value satisfies `SUCCEEDED?', and the interface is returned as the
	second value.  `Release' should be called on it when finished using
	it.  The first value will be `$E-NOINTERFACE' if the ID is not
	supported. 

  Release(interface :: <LPUNKNOWN>) => ( new-ref-count :: <integer> )

	When a client is finished with an interface, it should call
	`Release' on it to let the server know that the session is
	completed.  (The returned value is usually not useful.)

  get-id-of-name(disp-interface :: <LPDISPATCH>, name :: <string>,
	         #key locale = $LOCALE-USER-DEFAULT,
		      undefined-ok? :: <boolean> = #f)
	  => ( disp-id )

	Returns the dispatch ID for the member whose name for the given
	locale matches the given name string.  (Note that the comparison is
	not case-sensitive.)  This works for either methods or properties,
	but doesn't support mapping the names of the arguments of methods.

	If the name is not defined and the `undefined-ok?:' option is true,
	then the integer value `$DISPID-UNKNOWN' is returned instead of
	signalling an error.  [Or maybe it should be `#f'?]

  get-property(disp-interface :: <LPDISPATCH>, property,
	       #key default, locale = $LOCALE-USER-DEFAULT, index)
	   => ( value :: <object> )

	A simple way to obtain the value of a property of a dispatch
	interface.

	The _property_ argument is either the name of the property (a
	<string>), or the disp-id number.  If the property will be
	referenced more than once, it is much more efficient to use
	`get-id-of-name' to map the name to a disp-id just once.

	For accessing an indexed property, use the `index:' option to
	specify either a single index or a <sequence> of index values.

	If the designated property is not supported, if the `default:'
	option is specified, then that value is returned (useful for
	querying stock properties), otherwise an error is signalled.
	For some servers, the default value will also be used for an
	out-of-range index.

	This can also be used on the left side of an assignment to set the
	value of a property.

  set-property(disp-interface :: <LPDISPATCH>, property,
 	       new-value :: <object>, #key locale = $LOCALE-USER-DEFAULT) => ()

	A simple way to set the value of a property of a dispatch
	interface.  As for `get-property', the _property_ argument is
	either a name or disp-id.

  get-indexed-property (disp-interface, disp-id, #rest indexes)
	  => ( value :: <object> )

	This function is a simpler way to access an indexed property when
	the locale and default value options are not needed.  For example,
		get-indexed-property(intf, disp-id, x, y)
	is equivalent to:
		get-property(intf, disp-id, index: vector(x, y))

	This can also be used on the left side of an assignment to set an
	element of an indexed property.

  call-simple-method(disp-interface :: <LPDISPATCH>, member,
 		     #rest args) => ( result :: <object> )

	A simple way to call a dispatch method.  This is limited to methods
	that have only positional arguments (as opposed to named arguments)
	and which don't need a locale to be specified.

	The _member_ argument is either the name of the method (a
	<string>), or the disp-id.  If the method will be
	called more than once, it is much more efficient to use
	`get-id-of-name' to map the name to a disp-id just once.

	Each argument may be either the actual value to be passed or an
	instance of `<ole-arg-spec>' from function `pass-as', `out-ref', or
	`inout-ref'.

	[Issue: need to design high-level support for the cases excluded.]

  create-dispatch ( class-id, #key context = $CLSCTX-ALL,
                                   interface-id = $IID-IDispatch )
	     => (disp-interface :: <LPDISPATCH>)

	Used by an Automation controller to invoke an automation server, as
	identified by its class ID.  Normally, the primary dispatch
	interface is returned, but the `interface-id:' option may be used
	to select an alternate interface.  `Release' should be called on
	the returned interface when finished using it.

	The _class-id_ and `interface-id:' arguments may be either an
	instance of `<REFCLSID>' (such as returned by `make-GUID') or a
	<string> which can be converted to a GUID (see the `as' method
	above).

	The `context:' option takes one of the following values constraining
	which implementation of the server is to be used:

	    $CLSCTX-INPROC-SERVER	DLL running in same process.
	    $CLSCTX-LOCAL-SERVER	an EXE file in separate process.
	    $CLSCTX-REMOTE-SERVER	on a remote machine.
	    $CLSCTX-SERVER    		any of the above.
	    $CLSCTX-INPROC-HANDLER	an in-process handler.
	    $CLSCTX-ALL       		any of the above.  (default)
 
	If the class ID is not found in the registry, or there isn't a
	server that matches the requested `context:', an <ole-error> will
	be signalled with status code of `$REGDB-E-CLASSNOTREG'.
	If an interface matching the `interface-id:' is not found, an
	<ole-error> will be signalled with status `$E-NOINTERFACE'.

  make-object-factory ( typeinfo :: <coclass-type-info>, #rest other-args )
	 => ( factory :: <class-factory> )

	Creates, registers, and returns a class factory for the OLE object
	described by the given coclass type info.  The additional arguments
	are used as initialization keywords for either the <class-factory>
	or the object implementation class.  Call `revoke-registration' on
	the returned factory object before the program terminates.

  revoke-registration(factory :: false-or(<class-factory>)) => ()

	Un-registers a class factory, making it no longer available to
	potential clients.  It does nothing if the argument is `#f' or
	`$null-interface' or if it has already been called on the same
	factory instance.

  with-class-factory ( ?args ) ?body end 			[Macro]

	This convenience macro calls `make' for a `<class-factory>' with
	the given initialization keyword arguments, executes the body
	forms, and finally calls `revoke-registration' in a `cleanup'
	clause.

  ole-error( status, context, instance, #rest args )

	Signals an <ole-error> with the specified parameters.
	The _context_ argument is intended to be the name of the
	function that returned the status, the _instance_ argument is the
	interface the function was operating on, and additional relevant
	function arguments may be listed for information purposes.

  check-ole-status ( status :: <SCODE>, context, instance, #rest args ) => ()

	If the status code indicates an error, calls `ole-error' to signal
	an error condition. 

  exit-invoke ( status :: <SCODE>, #key arg-err :: <integer> = 0,
					excepinfo :: <LPEXCEPINFO> )

	This function may be called within the implementation of a server's
	dispatch method or property accessor to immediately return control
	to the client, passing back the argument as the status value
	returned from the Invoke operation.  The optional keyword arguments
	are seldom needed, but may be used to specify values for the
	corresponding output parameters of the low-level Invoke operation.

	This is implemented by signalling an <OLE-server-condition>, which
	will be handled by the invocation mechanism.  If this function is
	called in some other context that doesn't handle this condition, an
	error is signalled.

	Note that `ole-error' generally reports an error to the user, while
	`exit-invoke' reports an error to the client program.

  ole-array-type ( element-type :: <type> ) => array-type-description

	This function creates and returns a pseudo-type used to specify
	array types for the `type:', `argument-types:' or `result-type:'
	options when creating a type info.  The argument is the type
	descriptor (C type or Dylan class) of the elements of the array.
	If the argument is `<VARIANT>' or `<object>', then a heterogeneous
	array is indicated, in which each element will carry its own type
	information at run time.

  HRESULT-FROM-WIN32 ( error-code :: <integer> ) => ( status :: <SCODE> )

	Given a Windows error code, such as returned by Windows function
	`GetLastError', return the corresponding `<SCODE>' value.

  OLE-util-automation? () => (automation? :: <boolean>)

	Returns #t if the program's command line has the "/Automation"
	option (case insensitive), indicating that execution was initiated
	by an Automation controller client, as opposed to being invoked
	directly by the user.

	An application may want to make a class factory only if this is
	true.  For example:

	   ...
	    let factory = #f;
	    if ( OLE-util-automation?() )
	      factory := make(<class-factory>, ...);
	    end if;
	   ... // body of program
	    revoke-registration(factory); // does nothing if argument is #f
	   ...

	(This is not applicable to an in-process server.)

  OLE-util-file-arg () => (file-name :: false-or(<string>))

	This convenience function can be used by programs that want to
	accept a single file name as a command line argument.  If such an
	argument has been supplied, it will be returned as a string.

  OLE-util-register-only? () => (just-register? :: <boolean>)

	Returns `#f' unless the program's first command line argument is
	any of "/RegServer", "-RegServer", "/UnregServer" or "-UnregServer"
	(using case-insensitive comparison).  When a non-false value is
	returned, the program should just register itself (see
	`register-automation-server' and `register-type-library' below) and
	terminate without doing anything else.

	(This is not applicable to an in-process server.)

  register-automation-server ( class-id :: type-union(<REFCLSID>,<string>),
			       prog-id :: <string>, title-string :: <string>,
			     #key versioned-prog-id :: false-or(<string>),
			          versioned-title :: false-or(<string>)) => ()

	This function will create the necessary system registry entries for
	the current program to be invoked by an Automation Controller, or if
	the program was invoked with "/UnregServer" or "-UnregServer", then
	it will attempt to delete any registry entries belonging to the
	program.

	class-id
		must have the same value as the `clsid:' argument for
		making the `<class-factory>' or the `uuid:' argument for
		making a `<coclass-type-info>'.  (See also `make-GUID'.)

		Note that if you want to be able to have two versions of a
		program installed at the same time, then the two versions
		need to have different class IDs, as well as specifying a
		`versioned-prog-id:' for each.

	prog-id
		The "ProgID" or "programatic identifier" is a unique name
		for the class; it is used for compatibility with Visual
		Basic and OLE1.  It must start with a letter, it cannot
		contain any spaces or punctuation except period, and it
		must not be more than 39 characters long.  In order to
		ensure uniqueness, the recommended format is:
		  <vendor-name>.<product-name>
		For example:
		  AcmeWidgets.FrobMaster
 
	title-string
		identifies the program in displays for the user.
		It should not include the version number.

	versioned-prog-id:
		(optional) is either `#f' or a string that is recommended
		to be the same as the `prog-id' with a version
		identification appended. For example: 
		  AcmeWidgets.FrobMaster.2.1

	versioned-title:
		(optional) is either `#f' or a title string that includes
		the program's version number.

  register-type-library( typeinfo :: <ITypeInfo> ) => ()

	Create a Type Library file from the given type information and
	record it in the System Registry.  The created file will
	be in the same directory as the ".EXE"
	file and will have the same name, with the version and locale
	numbers appended and the extension changed to ".TLB".
	The type library can be used by controllers or other utilities that
	want to see what facilities are provided by the Automation server
	without actually executing it.  Note that this is optional since
	the type library file is not used by the program itself, and a
	controller doesn't necessarily need it either, but it will be
	created automatically if a connected client asks for it.

	If the program was invoked with the command line option
	"/UnregServer" or "-UnregServer", then it will attempt to delete
	the type library from the registry.

	Normally the argument should be an instance of
	`<coclass-type-info>', although if there is just a single dispatch
	interface, it is also possible to pass a `<disp-type-info>'
	provided it was created with a unique `uuid:' (not just
	`$IID-IDispatch'); it will then act as both an interface ID and a
	class ID.

	The type library is identified by its version number and locale as
	well as its class ID (type info options `major-version:',
	`minor-version:', `locale:', and `uuid:', respectively) so
	different versions of a program can be installed at the same time,
	and one program can register multiple type libraries with different
	locales (but same class ID, version, and help directory).
	(However, there will still be only one call to
	`make-object-factory', since it does not depend on the locale.)

  in-process-automation-server ( #key typeinfo, title, class-id, prog-id,
				  class, args,
				  versioned-prog-id, versioned-title)  [Macro] 

	For an in-process server, this macro needs to be called at
	top-level in order to set up some static initializations needed for
	DLL initialization and registration.  (It is not an executable
	expression.)  The macro expansion provides definitions for the
	Windows functions `DllRegisterServer', `DllUnregisterServer',
	`DllGetClassObject', and `DllCanUnloadNow'.  Without this, the
	container application will be unable to connect to the server.
	This macro cannot be used more than once in a DLL library.  The
	arguments are:

	typeinfo: 
		The ITypeInfo interface which describes the services being
		provided.  This should be an instance of `<disp-type-info>'
		or `<coclass-type-info>'.  Required.

	title:
		String to appear in a container's "insert object" dialog
		box to identify this server application.  Defaults to the
		typeinfo documentation string.

	prog-id:
		The "programatic identifier" string, as described for
		`register-automation-server'.  Required.

	class-id:
	 	The OLE class ID of the server object.  Optional; defaults
		from the typeinfo.

	class:
		The Dylan class which is to be instantiated when the server
		is invoked.  Optional; defaults from the `typeinfo' if it is
		a coclass; otherwise, the class defaults to
		`<simple-dispatch>'.

	args:
		Optional <sequence> of arguments to be passed to `make'
		when instantiating the `class'.  Defaults from the
		`typeinfo' if it is a coclass, otherwise, defaults to an
		empty sequence.

	versioned-prog-id:
		Optional string that is recommended to be the same as the
		`prog-id' with a version identification appended.

	versioned-title:
		Optional title string that includes the program's version
		number.

  pass-as ( type, value ) => ( representation :: <ole-arg-spec> )

	Use this in a client as an argument to functions such as
	`call-simple-method' or `set-property' or in a server as a return
	value from a property or method to specify passing the given
	_value_ using the representation designated by _type_.  The _type_
	may be specified either as one of the low-level VARIANTARG type
	codes, such as `$VT-I2' or `$VT-I4' or as a C-FFI type designator,
	such as `<C-short>' or `<C-long>'.

  out-ref ( type ) => (ref :: <ole-arg-spec>)

	This can be used in a client to construct an object that can be
	passed as an argument to `call-simple-method' and receive the value
	of a returned output parameter.  The _type_ of the value is
	specified as either one of the low-level VARIANTARG type
	codes (such as `$VT-I4') or as a C-FFI type designator, or as a
	corresponding Dylan type.  Use the accessor `arg-spec-value' to get
	the value after the call.

	For example, if a server defines a method that has a by-reference
	output parameter with C type `long', a Dylan client could receive
	the value like this:

	  // first make a place to hold the output parameter
	  let ref = out-ref(<C-long>);
	  // then call the server method
	  call-simple-method(disp-interface, disp-id, ref);
	  // now pick up the received value
	  let value = arg-spec-value(ref);

	(If the server is written in Dylan, it will simply receive an
	instance of `<C-long*>', and should use `pointer-value-setter' to
	store the value.)
 
  inout-ref (value, #key vt, type) => (ref :: <ole-arg-spec>)

	This is similar to `out-ref' above, except that it is for
	input-output parameters.  The _value_ argument is the value to be
	passed in (may be changed by `arg-spec-value-setter' if the
	reference is to be used for more than one call), and the type is
	specified by either the `vt:' option with a VARIANTARG type
	code or the `type:' option with a C or Dylan type designator.
	If neither `vt:' or `type:' is given, the type will be inferred
	from the _value_.

  arg-spec-value ( ref :: <ole-arg-spec> ) => (value :: <object>)

	Accessor to return the value from a reference object created by the
	`out-ref', `inout-ref', or `pass-as' functions.  May also be used
	on the left side of an assignment to change the value.
	


Low-level API
-------------

Besides the high-level utilities described above, the `ole-automation'
library also provides an FFI interface to the low-level API for
OLE Automation, as described in the Microsoft documentation.

See the companion file "ole-user-doc.text" for some general information
about OLE support in Dylan.  It explains the correspondence between the
C/C++ names in the Microsoft documentation and the Dylan identifiers.
If you need to refer to the source code of the libraries, you will also
need to be acquainted with the facilities of the `C-FFI' library, which is
specified in another file in this directory.  Note that some of the source
files were generated by an automatic translation of the C/C++ header files
by running "make -f make-sources".

The following OLE Automation API names are not being supported because they
are considered obsolete: 
  INTERFACEDATA, METHODDATA, PARAMDATA, CreateDispTypeInfo




Implementation notes
--------------------

The remainder of this document is a collection of half-baked implementation
notes that may not be of any interest to users.

Much of the complexity of the OLE Automation interfaces IDispatch,
ITypeInfo, etc., concerns the data structure that are used.  Much of this
is a clumsy way to allow C to do things like run-time typing and
heterogeneous collections which are trivial for Dylan.  So just allowing
these data structures to be accessed as the corresponding Dylan abstractions
instead of the C structures should allow OLE Automation code in Dylan to be
much simpler than in C.

Following is a description of how I'm supporting various specific data
types.

Basic Strings

  The C pointer type `BSTR' corresponds directly to the Dylan class
  `<BSTR>', defined as:

    define C-subtype <BSTR> ( <C-unicode-string> ) end;

  Note that this can be used as both a <C-pointer> and a <string>.  Methods
  are provided for `size' and `empty?' which use the Win32 function
  `SysStringLen' to get the recorded length instead of scanning for a
  terminating null.  (`empty?' also returns `#t' for a NULL pointer.) 
  A `make' method is provided which uses `SysAllocStringLen', and a
  `destroy' method which calls `SysFreeString'.  Also, an `as' method
  converts from a <C-unicode-string> to a <BSTR> by calling
  `SysAllocString'.  (Conversion from other kinds of strings will happen by
  using the existing general-purpose sequence conversion methods.)

  For convenience, the constant $NULL-BSTR is a null pointer of type
  <BSTR>.

  The function `copy-as-BSTR' will copy any kind of <string> to a newly
  allocated <BSTR>; this should be used instead of `as' when returning a
  value that will be deallocated by the caller.  It returns $NULL-BSTR if
  the argument is `#f' or a NULL pointer.


Variants

  The Dylan class <LPVARIANT> is simply a pointer to a C VARIANT structure,
  but instead of using the slot accessors, the Dylan programmer can simply
  use `pointer-value' and `pointer-value-setter' to read or write the Dylan
  object corresponding to the value represented by the structure, with any
  necessary conversions being done automatically according to the type
  indicated by the `vt' field.

  A VARIANT structure representation of a Dylan value (limited to a <real>,
  <machine-word>, <boolean>, <character>, <string>, <Interface>, or an
  <array> or <sequence> thereof) can be constructed either by:
    make(<LPVARIANT>, value: object)
  or:
    as(<LPVARIANT>, object)

  An `empty?' method is provided which returns true if the C type code is
  VT_EMPTY.   `pointer-value' will signal an error if called on an empty
  variant. 

  The constant $SQL-NULL is the Dylan object corresponding to the C type
  code of VT_NULL.  A method is provided for `null?' which returns true if
  the pointer is null or if the type is VT_NULL.


Safe Arrays

  These are "safe" only from the perspective of C, so that name doesn't
  make much sense in Dylan.  Instead, the Dylan classes <ole-vector> and
  <ole-array> will be used to represent a pointer to a `SAFEARRAY'
  structure.  These classes are defined as:

    define constant <LPSAFEARRAY> = <SAFEARRAY>.pointer-type;

    define C-subtype <ole-array> ( <LPSAFEARRAY>, <array> )
    end;

    define C-subtype <ole-vector> ( <ole-array>, <vector> )
    end;

  An `import-value' method will map an <LPSAFEARRAY> to an <ole-vector> if
  it is one-dimensional, or else to an <ole-array>.

  Access methods are provided to support the full array and vector
  protocols so that Dylan code can treat these simply as Dylan collections,
  without ever needing to use the FFI structure slot accessors.  The
  elements of a SAFEARRAY are VARIANT structures, so `element' or `aref'
  both gets the designated element and uses `pointer-value' to convert it
  to a Dylan object.

  The function `ole-vector' is like the standard Dylan function `vector'
  except that it returns an <ole-vector> instead of a <simple-vector>, and
  a call to `destroy' will be needed to explicitly deallocate it.  If the
  elements are all of the same type, an appropriate representation will be
  chosen for the array, otherwise each argument is converted to a VARIANT
  structure as an element of the SAFEARRAY.

  Note: the dimensions in a SAFEARRAY specify both a lower and upper bound
  for the index, but since Dylan does not support alternate lower bounds,
  index 0 will always correspond to the first element when viewed as a
  Dylan array.


Dispatch member functions

  In order to fit into the assumptions of the IDispatch interface, Dylan
  functions which implement IDispatch operations need to conform to a few
  conventions:

    * The first argument of the function will always be the <IDispatch>
      instance.  The remaining arguments correspond to the dispatch
      arguments. 

    * `#key' arguments may be used to correspond to OLE Automation named
      arguments.   `#all-keys' would not be useful.

    * If the function uses `#rest' but not `#key', then it will be
      described to a C user as accepting a "safe array" as the value of an
      additional argument.

    * In order to be mappable between C and Dylan, the argument types and
      return type are limited to the following:

	 <integer>, <character>, <single-float>, <double-float>, <boolean>,
	 <PLARGE-INTEGER>, <BSTR>, <LPDISPATCH>, <LPUNKNOWN>, <machine-word>
 
      or a `limited' subtype or an array or vector of any of these types.

    * The first value returned by the function should be a status code
      ($S-OK if nothing wrong).  A second value may be returned as the
      result value of the operation.  More than two result values are not
      meaningful.


Dispatch Parameters

  The class <LPDISPPARAMS> is a pointer to a C DISPPARAMS structure, which
  designates the function arguments for an "Invoke" operation.

  A `size' method is provided which returns the number of arguments, and an
  `empty?' method is provided to return true if there are no arguments.

  An `element' method can be used to obtain an individual argument value,
  converted from a VARIANT to a Dylan object; the index is the actual
  argument order, which is reversed from the order in the DISPPARAMS
  structure.   This method does not distinguish named from positional
  arguments. 

  For use in implementing the method `IDispatch/Invoke', after selecting
  the appropriate function to call, the function `apply-to-dispparams' can
  be used to call the function, passing as arguments the Dylan objects
  corresponding to a DISPPARAMS structure, including converting the
  so-called "named" parameters to Dylan keyword arguments.

  For example, if the operation is implemented by a function with the
  signature:
      frob(this :: <my-dispatch>, a, b, #key x, y)
  then the Invoke method could be written like this:

    define method IDispatch/Invoke(this :: <my-dispatch>,
			dispidMember :: <integer>,
			riid :: <REFIID>,
			lcid :: <integer>,
			flags :: <integer>,
			params :: <LPDISPPARAMS>,
			pvarResult :: <LPVARIANT>,
			pexcepinfo :: <LPEXCEPINFO>)
     => ( status :: <SCODE>, ArgErr :: <integer> );

      // [... use dispidMember to pick function to be called ...]

      let ( status, result ) =
	apply-to-dispparams(frob, this, params);
      unless ( null-pointer?(pvarResult) )
	pointer-value(pvarResult) := result;
      end unless;
      values( status, 0 )
    end method;

  If there are named arguments, `apply-to-dispparams' uses function
  introspection to find the keyword symbols to be used to identify the
  arguments in the Dylan argument sequence.  Thus if the caller provides
  two positional arguments and one named argument with a disp id of 3
  [fourth argument, counting from 0], then the effect is: 
    frob(instance, arg1, arg2, y: arg3)

  Maybe we should also have some mechanism for catching Dylan errors and
  filling in the EXCEPINFO structure accordingly?

  For going the other direction, there should be a function for easily
  constructing a DISPPARAMS structure.  It could look something like this:

    make-dispparams( named-args :: <sequence>, named-arg-ids :: <sequence>,
	             #rest positional-args ) => params :: <LPDISPPARAMS>;


But this stuff is supposed to be done using ITypeInfo instead, which
involves some more data structures:

Function Description

  The Dylan class <LPFUNCDESC> is a pointer to a C FUNCDESC structure.  In
  order to create a type library, such as by calling
  `ICreateTypeInfo::AddFuncDesc', we want an easy way to construct one of
  these for a Dylan function.  So maybe we'll have something like:

    make-funcdesc(function :: <function>, 
		memid :: <integer>,	// Function member ID 
		argument-types :: <sequence>, // type of each argument
		result-type :: false-or(<type>), // type of result value
		scodes :: <sequence>,	// Legal SCODES for the function.
		flags :: <integer>	// logior of $FUNCFLAG-...
		) => result :: <LPFUNCDESC>;

  The argument-types here correspond to the arguments following the first
  argument, which is the interface instance.  The types of the arguments
  needs to be provided here because `function-specializers' doesn't provide
  the types of keyword arguments, and because the actual specializers may
  not be specific enough to be mapped unambiguously to C data types.

  Another function should be provided to create a FUNCDESC for a property
  getter or putter.  [Not yet sure what data is relevant there.]

  This also involves a TYPEDESC structure for specifying the type of an
  argument; we should be able to have a function that will create one of
  these given a Dylan class object.

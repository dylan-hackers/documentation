<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_52.htm">
<LINK REL=PREV HREF="drm_55.htm">
<LINK REL=NEXT HREF="drm_57.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Exception Handling</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING56></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_57.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_55.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_52.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>7 Conditions</P>

</DIV>
<A NAME=HEADING56-0></A>
<A NAME=UID-Conditions-1884></A>
<H1 CLASS=H1.Heading1> Exception Handling</H1>
<P CLASS=T0.Text0>A set of classes, functions, and associated conventions extend the underlying condition handling capabilities to provide a complete exception handling facility.</P>
<P CLASS=T1.Text1>The classes are described in <A HREF="drm_95.htm#MARKER-9-1472" CLASS=T1.Text1>"Conditions" on page 244</A>, and the functions are described in <A HREF="drm_107.htm#MARKER-9-1917" CLASS=T1.Text1>"Signaling Conditions" on page 357</A>.</P>
<A NAME=HEADING56-3></A>
<A NAME=UID-Conditions-2155></A>
<H2 CLASS=H2.Heading2> Stack Model</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-925></A>Condition handlers are installed dynamically, with more recent handlers shadowing previously installed handlers. In addition, exception handling often involves the use of <A NAME=MARKER-2-926></A>nonlocal exits. For these reasons it is useful to describe the behavior of the exception system using the following terms from the stack model of function calling.</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1><B CLASS=B1.Bullet1><A NAME=MARKER-2-927></A>outside stack<BR></B>The state existing just before the handler was established.
<LI CLASS=B1.Bullet1><B CLASS=B1.Bullet1><A NAME=MARKER-2-928></A>signaling unit <BR></B>The conceptual program component that includes the expression that signaled the condition and does not include the expression that established the handler. This informal concept provides a notion of where the interface boundary between the signaler and the handler lies.
<LI CLASS=B1.Bullet1><B CLASS=B1.Bullet1><A NAME=MARKER-2-929></A>middle stack<BR></B>The state existing just before the signaling unit was called, minus the outside stack. In other words, the state between the handler and the signaling unit.
<LI CLASS=B1.Bullet1><B CLASS=B1.Bullet1><A NAME=MARKER-2-930></A>inside stack<BR></B>The state existing just before signaling occurred, minus the middle stack and outside stack. In other words, the portion of the signaling unit prior to the call to <CODE CLASS="Code B1.Bullet1">signal</CODE>.
</UL>
<P CLASS=Fg.Figure>Figure 7-1  <A NAME=MARKER-9-931></A><IMG ALIGN=TOP SRC=dr56ima1.gif>The Stack Model</P>
<P CLASS=T1.Text1>The handler in <A HREF="#MARKER-9-931" CLASS=T1.Text1>Figure 7-1</A> may either return normally, in which case execution resumes as the call to <CODE CLASS="cv T1.Text1">signal</CODE> returns normally, or the handler may make a nonlocal exit, such as calling the exit function from a dynamically active <CODE CLASS="cv T1.Text1">block</CODE> statement.<A NAME=MARKER-2-932></A></P>
<A NAME=HEADING56-11></A>
<A NAME=UID-Conditions-2820></A>
<H2 CLASS=H2.Heading2> Recovery and Exits</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-933></A>There are two ways to handle an exception: by recovery or by exit. Recovery involves making some repair to the program state and leaving control in the signaling unit. Exit involves <A NAME=MARKER-2-934></A>transferring control outside of the signaling unit through the use of a <A NAME=MARKER-2-935></A>nonlocal exit.</P>
<P CLASS=T1.Text1>The simplest way to handle an exception is to exit the signaling unit by taking a nonlocal exit to a target established in the outside stack. The <CODE CLASS=T1.Text1>exception</CODE> clause of the <CODE CLASS=T1.Text1><A NAME=MARKER-2-936></A>block</CODE> statement provides a convenient mechanism for accomplishing this.</P>
<P CLASS=T1.Text1>A less common handling style is to exit the signaling unit by taking a nonlocal exit to a target established in the middle stack, thus leaving the handler in force.</P>
<P CLASS=T1.Text1>Instead of exiting, a handler can recover by returning control to the signaling unit. This can be done either by returning values that the signaling unit will understand or by taking a nonlocal exit to a target established in the inside stack.</P>
<P CLASS=T1.Text1>The following examples show three ways of handling a copy-protection violation while copying a series of files. Note that the signaling code does not need to know how the condition will be handled. The only changes are in the code that handles the condition.</P>
<PRE CLASS=Cv.Code>
// Assume there is a class for file-system errors.
// We are interested in a special kind of file-system error
// that occurs when attempting to copy a copy-protected file,
// so we define a new class to indicate such errors.
define class &lt;copy-protection-violation&gt; (&lt;file-system-error&gt;)
  slot file, init-keyword: file:;    // Store the file name
end class;
// Define a function to copy a single file. This
// function signals a &lt;copy-protection-violation&gt; if
// the file is copy-protected.
define method copy-file (source, destination)
  if ( copy-protected?(source) )
    signal(make(&lt;copy-protection-violation&gt;, file: source));
  else
    // copy normally
    notify-user(&quot;Copying %s to %s.&quot;, source, destination);
  end if;
end method;
// The following function copies a sequence of files.
// If one of the files is copy-protected, the user is
// notified, and the remaining files are copied.
define method backup-all-possible (volume, archive)
  let handler &lt;copy-protection-violation&gt;
       = method (condition, next)
           // The handler just notifies the user and continues
           notify-user(&quot;The file %s could not be copied.&quot;,
                       condition.file);
         end method;
  // start copying files, with the handler in effect
  for (each-file in volume)
    copy-file(each-file, archive)
  end for;
end method;
// The following function stops copying as soon as it
// hits a copy-protected file
define method backup-exit (volume, archive)
  // set up a block so we can do a nonlocal exit
  block (exit)
   let handler &lt;copy-protection-violation&gt;
       = method (condition, next)
           // Notify the user and abort the backup
           notify-user(
    &quot;Backup interrupted: the file %s could not be copied.&quot;,
                       condition.file);
           exit(#f);
         end method;
  // start copying files, with the handler in effect
    for (each-file in volume)
      copy-file(each-file, archive)
    end for;
  end block;
end method;
// The following function uses the convenient exception clause of
// the block statement to achieve essentially the same effect as
// as backup-exit.
define method backup-block (volume, archive)
  // get ready to do backups   
  block ()
    // start copying files   
    for (each-file in volume)
      copy-file(each-file, archive)
    end for;
  exception (condition :: &lt;copy-protection-violation&gt;)
    notify-user(
   &quot;Backup interrupted: the file %s could not be copied.&quot;,
                condition.file);
  end block;
end method;<A NAME=MARKER-2-937></A>
</PRE>
<A NAME=HEADING56-22></A>
<A NAME=UID-Conditions-2199></A>
<H2 CLASS=H2.Heading2> Restarts</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-938></A><A NAME=MARKER-2-939></A>Recovering or exiting can be accomplished directly, or a more formal mechanism called <B CLASS="Bold T1.Text1">restarting</B> can be used. Using restarts provides more assurance that the handler and the signaling unit agree on the meaning of what they are doing and provides some isolation of the handler from names and data representations internal to the signaling unit.</P>
<P CLASS=T1.Text1>A handler restarts by signaling a restart. All restarts are instances of <CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-940></A>&lt;restart&gt;</CODE>. Any values needed for recovery are passed in the restart (that is, in initialization arguments that the restart remembers, typically in slots). The restart is handled by a <A NAME=MARKER-2-941></A>restart handler that either <A NAME=MARKER-2-942></A>returns or takes a <A NAME=MARKER-2-943></A>nonlocal exit. If the restart handler returns some values, <CODE CLASS="Code T1.Text1">signal</CODE> returns those values and the handler that called <CODE CLASS=T1.Text1>signal</CODE> also returns them. The call to <CODE CLASS=T1.Text1>signal</CODE> from the signaling unit that signaled the original condition returns the same values, and the signaling unit recovers as directed by those values.<A NAME=MARKER-2-944></A></P>
<A NAME=HEADING56-25></A>
<A NAME=UID-Conditions-1894></A>
<H2 CLASS=H2.Heading2> Recovery Protocols</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-945></A>For every condition class there should be a <B CLASS="Bold T1.Text1">recovery protocol</B> that defines the meaning of <A NAME=MARKER-2-946></A>handling by returning, the meaning of the <A NAME=MARKER-2-947></A>values returned, and which <A NAME=MARKER-2-948></A>restart handlers are supposed to be established by the signaling unit. The recovery protocol tells the handler what to expect from the signaler. For many condition classes, this is the empty protocol: handling by returning isn't allowed, and no particular restart handlers are provided. In this case only handling by exiting is possible. (Exiting might be accomplished by signaling a restart whose handler was established in the outside or middle stack and does a nonlocal exit back to where it was established, or by an ordinary nonlocal exit.)  The recovery protocol for a subclass should be compatible with the recovery protocol of a superclass. That is, a handler that applies a class's recovery protocol should operate correctly when the condition is an instance of some subclass of that class.</P>
<P CLASS=T1.Text1>An example recovery protocol for a hypothetical <CODE CLASS="Code T1.Text1">&lt;unbound-slot&gt;</CODE> condition could include the following:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>Returning is allowed. Returning a value uses that value as if it had been the contents of the slot.
<LI CLASS=B1.Bullet1>A restart handler for <CODE CLASS="Code B1.Bullet1">&lt;new-value&gt;</CODE> is available. <CODE CLASS="Code B1.Bullet1">&lt;new-value&gt;</CODE> has initialization arguments <CODE CLASS="Code B1.Bullet1">value:</CODE>, the value to use, and <CODE CLASS="Code B1.Bullet1">permanent:</CODE>, which indicates whether to store the value into the slot or leave the slot unbound.
<P CLASS=T1.Text1>No formal mechanism is provided for describing recovery protocols; they are left to the documentation of a condition class. Introspective functions are provided for discovering which recovery facilities are actually available, but this is different from (and sometimes is a superset of) the recovery facilities guaranteed by a recovery protocol always to be available.</P>
<P CLASS=T1.Text1>The <A NAME=MARKER-2-949></A>debugger is the condition handler of last resort. It receives control if no program-provided handler handles a serious condition. (This is true even if the debugger provided cannot analyze or intervene in the execution of programs but can only abort or restart them. The debugger might be merely a "core dumper," a "bomb box," or something similar.)  An interactive debugger ought to offer the user the ability to signal any restart for which a restart handler is applicable and to return if the condition's recovery protocol allows it. This could, for example, be done with a menu titled "Recovery."<A NAME=MARKER-2-950></A></P>
</UL>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_56.htm#HEADING56-3" CLASS=FOOTER><B CLASS=FOOTER></B>Stack Model</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_56.htm#HEADING56-11" CLASS=FOOTER><B CLASS=FOOTER></B>Recovery and Exits</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_56.htm#HEADING56-22" CLASS=FOOTER><B CLASS=FOOTER></B>Restarts</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_56.htm#HEADING56-25" CLASS=FOOTER><B CLASS=FOOTER></B>Recovery Protocols</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_57.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_55.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_52.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

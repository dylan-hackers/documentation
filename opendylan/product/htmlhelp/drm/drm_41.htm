<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_38.htm">
<LINK REL=PREV HREF="drm_40.htm">
<LINK REL=NEXT HREF="drm_42.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Classes</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING41></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_42.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_40.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_38.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>5 Types and Classes</P>

</DIV>
<A NAME=HEADING41-0></A>
<A NAME="UID-Types_and_Classes-361"></A>
<H1 CLASS=H1.Heading1> <A NAME=MARKER-2-561></A>Classes</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-562></A>Classes are used to define the inheritance, structure, and initialization of objects.</P>
<P CLASS=T1.Text1>Every object is a <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-563></A>direct instance</B> of exactly one class, and a general instance of  the <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-564></A>general superclasses</B> of that class.</P>
<P CLASS=T1.Text1>A class determines which <B CLASS=T1.Text1><A NAME=MARKER-2-565></A>slots</B> its instances have. Slots are the local storage available within instances. They are used to store the state of objects.</P>
<P CLASS=T1.Text1>Classes determine how their instances are initialized by using the <B CLASS="bold T1.Text1"><A NAME=MARKER-2-566></A>initialization protocol</B>.</P>
<A NAME=HEADING41-5></A>
<A NAME="UID-Types_and_Classes-5438"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-567></A>Features of Classes</H2>
<P CLASS=T1.Text1>There are four features of classes. These features relate to each other, but can be declared independently.</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>A class can be <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-568></A>abstract</B> or <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-569></A>concrete</B>. If the class is concrete, it can have direct instances. If it is abstract, it cannot have direct instances, but only indirect instances.
<LI CLASS=B1.Bullet1>A class can be <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-570></A>instantiable</B> or <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-571></A>uninstantiable</B>. If the class is instantiable, it can be used as the first argument to <CODE CLASS="cv B1.Bullet1">make</CODE>. If it is uninstantiable, it cannot be used as the first argument to <CODE CLASS="cv B1.Bullet1">make</CODE>.
<LI CLASS=B1.Bullet1>A class can be <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-572></A>primary</B> or <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-573></A>free</B>. This controls how a class can be used for multiple inheritance. For a full description of this feature, see <A HREF="drm_73.htm#MARKER-9-1106" CLASS=B1.Bullet1>"Declaring Characteristics of Classes" on page 134</A>.
<LI CLASS=B1.Bullet1>A class can be <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-574></A>sealed</B> or <B CLASS="bold B1.Bullet1"><A NAME=MARKER-2-575></A>open</B>. This controls whether a class can be subclassed outside the library where it is defined. For a full description of this feature, see <A HREF="drm_73.htm#MARKER-9-1106" CLASS=B1.Bullet1>"Declaring Characteristics of Classes" on page 134</A>.<A NAME=MARKER-2-576></A>
</UL>
<A NAME=HEADING41-11></A>
<A NAME="UID-Types_and_Classes-2532"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-577></A>Creating Classes</H2>
<P CLASS=T1.Text1>New classes may be created by calling <A NAME=MARKER-2-578></A><CODE CLASS="Code T1.Text1">make</CODE> on <CODE CLASS="Code T1.Text1">&lt;class&gt;</CODE>, or with the defini-<BR>tion <A NAME=MARKER-2-579></A><CODE CLASS=T1.Text1>define class</CODE>. In most programs the latter is more commonly used.</P>
<P CLASS=T1.Text1>When a class is created with <CODE CLASS="cv T1.Text1">make</CODE>, it is instantiated and returned just like any other object. The options available when creating a class with <CODE CLASS="cv T1.Text1">make</CODE> are described on <A HREF="drm_90.htm#MARKER-9-1372" CLASS=T1.Text1>page 191</A>.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-580></A>When a class is created with <CODE CLASS="Code T1.Text1">define class</CODE> it is used to initialize a new module binding. <CODE CLASS="cv T1.Text1">define class</CODE> allows the specification of superclasses, slots, initialization behavior, and options related to sealing. The complete syntax of <CODE CLASS="Code T1.Text1">define class</CODE> is given on <A HREF="drm_112.htm#MARKER-9-2013" CLASS=T1.Text1>page 378</A>.</P>
<P CLASS=T1.Text1>The following simple class definition creates a class named by the module binding <CODE CLASS="Code T1.Text1">&lt;new&gt;</CODE>. The class inherits from <CODE CLASS="Code T1.Text1">&lt;object&gt;</CODE> and does not specify any slots.</P>
<PRE CLASS=Cv.Code>
define class &lt;new&gt; (&lt;object&gt;)
end class &lt;new&gt;;
</PRE>
<P CLASS=T1.Text1>The following class definition illustrates the creation of a class with multiple superclasses. Again, there are no slots defined by the class.</P>
<PRE CLASS=Cv.Code>
define class &lt;color-window&gt; (&lt;palette&gt;, &lt;window&gt;)
end class &lt;color-window&gt;;<A NAME=MARKER-2-581></A>
</PRE>
<A NAME=HEADING41-19></A>
<A NAME="UID-Types_and_Classes-5460"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-582></A><A NAME=MARKER-9-583></A>Class Inheritance</H2>
<P CLASS=T1.Text1>When a class is created, its <B CLASS="bold T1.Text1"><A NAME=MARKER-2-584></A>direct superclasses</B> are specified. The new class directly inherits from these classes; it is a <B CLASS="bold T1.Text1"><A NAME=MARKER-2-585></A>direct subclass</B> of each of these classes. There can be no duplicates in the direct superclasses of a class.</P>
<P CLASS=T1.Text1>The subclass relationship is transitive. If a class <I CLASS="Parameter T1.Text1">C</I> is a direct subclass of <I CLASS="Parameter T1.Text1">C<EM CLASS="Subscript Parameter T1.Text1">1</EM></I>,  <I CLASS="Parameter T1.Text1">C<EM CLASS="Subscript Parameter T1.Text1">1</EM></I> is a direct subclass of <I CLASS="Parameter T1.Text1">C<EM CLASS="Subscript Parameter T1.Text1">2</EM></I>, and <I CLASS="Parameter T1.Text1">C<EM CLASS="Subscript Parameter T1.Text1">2</EM></I> is a direct subclass of <I CLASS="Parameter T1.Text1">C<EM CLASS="Subscript Parameter T1.Text1">3</EM></I>, then <I CLASS="Parameter T1.Text1">C</I> is an <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-586></A>indirect subclass</B> of <I CLASS="Parameter T1.Text1">C<EM CLASS="Subscript Parameter T1.Text1">2</EM></I> and <I CLASS="Parameter T1.Text1">C<EM CLASS="Subscript Parameter T1.Text1">3</EM></I>. A <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-587></A>general subclass</B> is a direct or indirect subclass.</P>
<P CLASS=T1.Text1>Inheritance cannot be <A NAME=MARKER-2-588></A>circular. A class cannot be its own general subclass.</P>
<P CLASS=T1.Text1>A class is a subtype of each of its general superclasses.</P>
<P CLASS=T1.Text1>Every class is a general subclass of <CODE CLASS="Code T1.Text1">&lt;object&gt;</CODE>.<A NAME=MARKER-2-589></A></P>
<A NAME=HEADING41-25></A>
<A NAME="UID-Types_and_Classes-7969"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-9-590></A><A NAME=MARKER-2-591></A>Computing the Class Precedence List</H2>
<P CLASS=T1.Text1>The definition of a class specifies a <A NAME=MARKER-2-592></A>total ordering on that class and its direct superclasses. This ordering is called the <B CLASS=T1.Text1><A NAME=MARKER-2-593></A>local precedence order</B>. In the local precedence order:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>The class precedes its direct superclasses.
<LI CLASS=B1.Bullet1>Each direct superclass precedes all other direct superclasses that follow it in the sequence of direct superclasses given in the class definition.
<P CLASS=T1.Text1>The <B CLASS=T1.Text1><A NAME=MARKER-2-594></A>class precedence list</B> for a class <I CLASS="Parameter T1.Text1">C</I> is a total ordering on <I CLASS="Parameter T1.Text1">C</I> and its superclasses that is consistent with the local precedence order of <I CLASS="Parameter T1.Text1">C</I> and with the class precedence lists of its superclasses. (Two lists are consistent if for every <I CLASS="Parameter T1.Text1">A</I> and <I CLASS="Parameter T1.Text1">B</I> that are each members of both lists, either <I CLASS="Parameter T1.Text1">A</I> precedes <I CLASS="Parameter T1.Text1">B</I> in both or <I CLASS="Parameter T1.Text1">B</I> precedes <I CLASS="Parameter T1.Text1">A</I> in both.) The class precedence list is used in determining the order of specificity of methods based on the types they are specialized on when dispatching;  for details, see <A HREF="drm_50.htm#MARKER-9-844" CLASS=T1.Text1>"Method Dispatch" on page 95</A>.</P>
<P CLASS=T1.Text1>Sometimes there are several such consistent total orderings on <I CLASS="Parameter T1.Text1">C</I> and its superclasses. Dylan uses a deterministic algorithm to compute the class precedence list, which chooses one of the consistent total orderings.</P>
<P CLASS=T1.Text1>Sometimes there is no possible total ordering on <I CLASS="Parameter T1.Text1">C</I> and its superclasses that is consistent with the local precedence orders for <I CLASS="Parameter T1.Text1">C</I> and with the class precedence lists of its superclasses. In this case, the class precedence list cannot be computed, and an error is signaled.</P>
<P CLASS=T1.Text1>Note that because the class precedence list for a class is consistent with the class precedence lists of its superclasses, inheritance in Dylan is <B CLASS="bold T1.Text1">monotonic</B>. That is, if a generic function call using a direct instance of <I CLASS="Parameter T1.Text1">C</I> dispatches to a method specialized in that parameter position on an indirect superclass of <I CLASS="Parameter T1.Text1">C</I>, then there is a direct superclass of <I CLASS="Parameter T1.Text1">C</I> that has the same behavior.</P>
<P CLASS=T1.Text1>To compute the class precedence list for class <I CLASS="Parameter T1.Text1">C</I>, merge the local precedence order of the class with the class precedence lists of the direct superclasses of the class. Computing the class precedence list for <I CLASS="Parameter T1.Text1">C</I> requires computing the class precedence lists for its superclasses. This does not lead to infinite recursion because circular class inheritance is prohibited.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-595></A>Note that because the class precedence lists of the direct superclasses are consistent with their local precedence orders and with the class precedence lists of their direct superclasses, and so on, the class precedence list  for <I CLASS="Parameter T1.Text1">C</I> is consistent with the local precedence orders and class precedence lists of all its superclasses and not just the direct superclasses.</P>
<P CLASS=T1.Text1>The merge of several sequences is a sequence that contains each of the elements of the several input sequences. An element that appears in more than one of the input sequences appears only once in the output sequence. If two elements appear in the same input sequence, their order in the output sequence is the same as their order in that input sequence.</P>
<P CLASS=T1.Text1>When there are several possible merges of the inputs, at each position in the output where there is a choice, pick the class that has a direct subclass closest to the end of the output sequence. (This is unambiguous because two candidates for a position cannot both be direct superclasses of the same class, since they would then be ordered by that class's local precedence order. This is easily computable because a class always follows its direct subclasses in the merge, therefore the most recently added direct subclass can be found by searching from the end to the beginning of the output sequence and the merge can be computed in one pass.)</P>
<P CLASS=T1.Text1>This algorithm can be implemented with the following Dylan program:</P>
</UL>
<PRE CLASS=Cv.Code>
define constant compute-class-linearization =
  method (c :: &lt;class&gt;) =&gt; (cpl :: &lt;list&gt;)
    local method merge-lists (reversed-partial-result :: &lt;list&gt;,
                              remaining-inputs :: &lt;sequence&gt;)
            if (every?(empty?, remaining-inputs))
              reverse!(reversed-partial-result)
            else
              local method candidate (c :: &lt;class&gt;)
                      // returns c if it can go in the result now,
                      // otherwise false
                      local method head? (l :: &lt;list&gt;)
                              c == head(l)
                            end method head?,
                            method tail? (l :: &lt;list&gt;)
                              member?(c, tail(l))
                            end method tail?;
                      any?(head?, remaining-inputs)
                        &amp; ~any?(tail?, remaining-inputs)
                        &amp; c
                    end method candidate,
                    method candidate-direct-superclass (c :: &lt;class&gt;)
                      any?(candidate, direct-superclasses(c))
                    end method candidate-direct-superclass;
              let next = any?(candidate-direct-superclass,
                              reversed-partial-result);
              if (next)
                local method remove-next (l :: &lt;list&gt;)
                        if (head(l) == next) tail(l) else l end
                      end method remove-next;
                merge-lists(pair(next, reversed-partial-result),
                            map(remove-next, remaining-inputs))
              else
                error(&quot;Inconsistent precedence graph&quot;);
              end if
            end if
          end method merge-lists;
    let c-direct-superclasses = direct-superclasses(c);
    local method cpl-list (c)
            as(&lt;list&gt;, all-superclasses(c))
          end method cpl-list;
    merge-lists(list(c),
                add(map(cpl-list, c-direct-superclasses),
                    as(&lt;list&gt;, c-direct-superclasses)));
  end method; // compute-class-linearization
</PRE>
<P CLASS=T0.Text0>Note that the selection rule from above is enforced because <CODE CLASS="cv T0.Text0">any?</CODE> uses the natural iteration order for sequences and returns the first true value it encounters when searching the reversed partially computed class precedence list.<A NAME=MARKER-2-596></A><A NAME=MARKER-2-597></A><A NAME=MARKER-2-598></A></P>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_41.htm#HEADING41-5" CLASS=FOOTER><B CLASS=FOOTER></B>Features of Classes</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_41.htm#HEADING41-11" CLASS=FOOTER><B CLASS=FOOTER></B>Creating Classes</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_41.htm#HEADING41-19" CLASS=FOOTER><B CLASS=FOOTER></B>Class Inheritance</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_41.htm#HEADING41-25" CLASS=FOOTER><B CLASS=FOOTER></B>Computing the Class Precedence List</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_42.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_40.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_38.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_76.htm">
<LINK REL=PREV HREF="drm_85.htm">
<LINK REL=NEXT HREF="drm_87.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Rewrite Rule Examples</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING86></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_87.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_85.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>10 Macros</P>

</DIV>
<A NAME=HEADING86-0></A>
<A NAME=UID-Macros-6935></A>
<H1 CLASS=H1.Heading1> Rewrite Rule Examples</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-1281></A>The following definitions of all of the built-in macros are provided as examples. This section is not intended to be a tutorial on how to write macros, just a collection of demonstrations of some of the tricks.</P>
<P CLASS=T1.Text1>The built-in macros cannot really be implemented this way; for example <CODE CLASS="cv T1.Text1">if</CODE> and <CODE CLASS="cv T1.Text1">case</CODE> cannot really both be implemented by expanding to the other. Certain built-in macros cannot be implemented with rewrite rules or necessarily rewrite into implementation-dependent code; in these cases the right-hand sides are shown as <I CLASS="Parameter T1.Text1">id</I>.</P>
<A NAME=HEADING86-3></A>
<A NAME=UID-Macros-6941></A>
<H2 CLASS=H2.Heading2> Statement Macros</H2>
<A NAME=HEADING86-4></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1282></A>Begin</H3>
<PRE CLASS=Cv.Code>
define macro begin
  { begin ?:body end } =&gt; { ?body }
end;
</PRE>
<A NAME=HEADING86-6></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1283></A>Block</H3>
<PRE CLASS=Cv.Code>
define macro block
  { block () ?ebody end }
   =&gt; { ?ebody }
  { block (?:name) ?ebody end }
   =&gt; { with-exit(method(?name) ?ebody end) }
 // Left-recursive so leftmost clause is innermost
 ebody:
  { ... exception (?type:expression, ?eoptions) ?:body }
   =&gt; { with-handler(method() ... end,
                     method(ignore) ?body end,
                     ?type, ?eoptions) }
  { ... exception (?:name :: ?type:expression, ?eoptions) ?:body }
   =&gt; { with-handler(method() ... end,
                     method(?name) ?body end,
                     ?type, ?eoptions) }
  { ?abody cleanup ?cleanup:body}
   =&gt; { with-cleanup(method() ?abody end, method () ?cleanup end) }
  { ?abody }
   =&gt; { ?abody }
 abody:
  { ?main:body }
   =&gt; { ?main }
  { ?main:body afterwards ?after:body }
   =&gt; { with-afterwards(method() ?main end, method () ?after end) }
 eoptions:
  { #rest ?options:expression, 
    #key ?test:expression = always(#t),
    ?init-arguments:expression = #() }
   =&gt; { ?options }
end;
</PRE>
<A NAME=HEADING86-11></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1284></A>Case</H3>
<PRE CLASS=Cv.Code>
define macro case
  { case ?:case-body end }            =&gt; { ?case-body }
 case-body:
  { }                                 =&gt; { #f }
  { otherwise ?:body }                =&gt; { ?body }
  { ?test:expression =&gt; ?:body; ... } =&gt; { if (?test) ?body
                                           else ... end if }
end;
</PRE>
<A NAME=HEADING86-13></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1285></A>For</H3>
<PRE CLASS=Cv.Code>
// This macro has three auxiliary macros, whose definitions follow
define macro for
 { for (?header) ?fbody end }       =&gt; { for-aux ?fbody, ?header end }
 // pass main body and finally body as two expressions
 fbody:
  { ?main:body }                     =&gt; { ?main, #f }
  { ?main:body finally ?val:body }   =&gt; { ?main, ?val }
 // convert iteration clauses to property list via for-clause macro
 header:
  { ?v:variable in ?c:expression, ... }
   =&gt; { for-clause(?v in ?c) ... }
  { ?v:variable = ?e1:expression then ?e2:expression, ... }
   =&gt; { for-clause(?v = ?e1 then ?e2) ... }
  { ?v:variable from ?e1:expression ?to, ... }
   =&gt; { for-clause(?v from ?e1 ?to) ... }
  { }                                =&gt; { }
  { #key ?while:expression }         =&gt; { for-clause(~?while stop) }
  { #key ?until:expression }         =&gt; { for-clause(?until stop) }
 // parse the various forms of numeric iteration clause
 to:
  { to ?limit:expression by ?step:expression }
                                     =&gt; { hard ?limit ?step }
  { to ?limit:expression }           =&gt; { easy ?limit 1   &gt; }
  { above ?limit:expression ?by }    =&gt; { easy ?limit ?by &lt;= }
  { below ?limit:expression ?by }    =&gt; { easy ?limit ?by &gt;= }
  { ?by }                            =&gt; { loop ?by }
 by:
  { }                                =&gt; { 1 }
  { by ?step:expression }            =&gt; { ?step }
end;
// Auxiliary macro to make the property list for an iteration clause.
// Each iteration clause is a separate call to this macro so the
// hygiene rules will keep the temporary variables for each clause
// distinct.
// The properties are:
//  init0: - constituents for start of body, outside the loop
//  var1:  - a variable to bind on each iteration
//  init1: - initial value for that variable
//  next1: - value for that variable on iterations after the first
//  stop1: - test expression, stop if true, after binding var1's
//  var2:  - a variable to bind on each iteration, after stop1 tests
//  next2: - value for that variable on every iteration
//  stop2: - test expression, stop if true, after binding var2's
define macro for-clause
  // while:/until: clause
  { for-clause(?e:expression stop) }
   =&gt; { , stop2: ?e }
  // Explicit step clause
  { for-clause(?v:variable = ?e1:expression then ?e2:expression) }
   =&gt; { , var1: ?v, init1: ?e1, next1: ?e2 }
  // Collection clause
  { for-clause(?v:variable in ?c:expression) }
   =&gt; { , init0: [ let collection = ?c;
                   let (initial-state, limit,
                        next-state, finished-state?,
                        current-key, current-element)
                       = forward-iteration-protocol(collection); ]
        , var1: state, init1: initial-state
        , next1: next-state(collection, state)
        , stop1: finished-state?(collection, state, limit)
       , var2: ?v, next2: current-element(collection, state) }
  // Numeric clause (three cases depending on ?to right-hand side)
  { for-clause(?v:name :: ?t:expression from ?e1:expression
               loop ?by:expression) }
   =&gt; { , init0: [ let init = ?e1;
                   let by = ?by; ]
        , var1: ?v :: ?t, init1: init, next1: ?v + by }
  { for-clause(?v:name :: ?t:expression from ?e1:expression
               easy ?limit:expression ?by:expression ?test:token) }
   =&gt; { , init0: [ let init = ?e1;
                   let limit = ?limit;
                   let by = ?by; ]
        , var1: ?v :: ?t, init1: init, next1: ?v + by
        , stop1: ?v ?test limit }
  { for-clause(?v:name :: ?t:expression from ?e1:expression
               hard ?limit:expression ?by:expression) }
   =&gt; { , init0: [ let init = ?e1;
                   let limit = ?limit;
                   let by = ?by; ]
        , var1: ?v :: ?t, init1: init, next1: ?v + by
        , stop1: if (by &gt;= 0) ?v &gt; limit else ?v &lt; limit end if }
end;
// Auxiliary macro to expand multiple for-clause macros and
// concatenate their expansions into a single property list.
define macro for-aux
  { for-aux ?main:expression, ?value:expression, ?clauses:* end }
   =&gt; { for-aux2 ?main, ?value ?clauses end }
 clauses:
  { } =&gt; { }
  { ?clause:macro ... } =&gt; { ?clause ... }
end;
// Auxiliary macro to assemble collected stuff into a loop.
// Tricky points:
// loop iterates by tail-calling itself.
// return puts the finally clause into the correct lexical scope.
// ??init0 needs an auxiliary rule set to strip off the shielding
// brackets that make it possible to stash local declarations in
// a property list.
// ??var2 and ??next2 need a default because let doesn't allow
// an empty variable list.
// ??stop1 and ??stop2 need a default because if () is invalid.
define macro for-aux2
  { for-aux2 ?main:expression, ?value:expression,
             #key ??init0:*, ??var1:variable,
                  ??init1:expression, ??next1:expression,
                  ??stop1:expression = #f,
                  ??var2:variable = x, ??next2:expression = 0,
                  ??stop2:expression = #f
    end }
   =&gt; { ??init0 ...
        local method loop(??var1, ...)
                let return = method() ?value end method;
                if (??stop1 | ...) return()
                else let (??var2, ...) = values(??next2, ...);
                     if(??stop2 | ...) return()
                     else ?main; loop(??next1, ...)
                     end if;
                end if;
              end method;
        loop(??init1, ...) }
 // strip off brackets used only for grouping
 init0:
  { [ ?stuff:* ] } =&gt; { ?stuff }
end;
</PRE>
<A NAME=HEADING86-30></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1286></A>If</H3>
<PRE CLASS=Cv.Code>
define macro if
  { if (?test:expression) ?:body ?elses end }
                                     =&gt; { case ?test =&gt; ?body;
                                          otherwise ?elses end }
 elses:
  { }                                =&gt; { #f }
  { else ?:body }                    =&gt; { ?body }
  { elseif (?test:expression) ?:body ... }
                                     =&gt; { case ?test =&gt; ?body;
                                          otherwise ... end }
end;
</PRE>
<A NAME=HEADING86-32></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1287></A>Method</H3>
<PRE CLASS=Cv.Code>
define macro method
  { method (?parameters:*) =&gt; (?results:*) ; ?:body end }     =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { method (?parameters:*) =&gt; (?results:*) ?:body end }       =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { method (?parameters:*) =&gt; ?result:variable ; ?:body end } =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { method (?parameters:*) ; ?:body end }                     =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { method (?parameters:*) ?:body end }                       =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-34></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1288></A>Select</H3>
<PRE CLASS=Cv.Code>
define macro select
  { select (?what) ?:case-body end } =&gt; { ?what; ?case-body }
 what:
  { ?object:expression by ?compare:expression }
                                    =&gt;  { let object = ?object;
                                          let compare = ?compare }
  { ?object:expression }            =&gt;  { let object = ?object;
                                          let compare = \== }
 case-body:
  { }
   =&gt; { error(&quot;select error, %= doesn't match any key&quot;, object) }
  { otherwise ?:body }              =&gt; { ?body }
  { ?keys =&gt; ?:body; ... }          =&gt; { if (?keys) ?body
                                         else ... end if }
 keys:
  { ?key:expression }               =&gt; { compare(object, ?key) }
  { (?keys2) }                      =&gt; { ?keys2 }
  { ?keys2 }                        =&gt; { ?keys2 }
 keys2:
  { ?key:expression }               =&gt; { compare(object, ?key) }
  { ?key:expression, ... }          =&gt; { compare(object, ?key) | ... }
end;
</PRE>
<A NAME=HEADING86-40></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1289></A>Unless</H3>
<PRE CLASS=Cv.Code>
define macro unless
  { unless (?test:expression) ?:body end }
   =&gt; { if (~ ?test) ?body end }
end;
</PRE>
<A NAME=HEADING86-42></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1290></A>Until</H3>
<PRE CLASS=Cv.Code>
define macro until
  { until (?test:expression) ?:body end }
   =&gt; { local method loop ()
                if (~ ?test)
                  ?body;
                  loop()
                end if;
              end method;
        loop() }
end;
</PRE>
<A NAME=HEADING86-44></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1291></A>While</H3>
<PRE CLASS=Cv.Code>
define macro while
  { while (?test:expression) ?:body end }
   =&gt; { local method loop ()
                if (?test)
                  ?body;
                  loop()
                end if;
              end method;
        loop() }
end;
</PRE>
<A NAME=HEADING86-46></A>
<A NAME=UID-Macros-7223></A>
<H2 CLASS=H2.Heading2> Definition Macros</H2>
<A NAME=HEADING86-47></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1292></A>Define Class</H3>
<PRE CLASS=Cv.Code>
define macro class-definer
  { define ?mods:* class ?:name (?supers) ?slots end }  =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 supers:
  { }                                                   =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ?super:expression, ... }                            =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 slots:
  { }                                                   =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { inherited slot ?:name, #rest ?options:*; ... }      =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { inherited slot ?:name = ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ?mods:* slot ?:name, #rest ?options:*; ... }        =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ?mods:* slot ?:name = ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ?mods:* slot ?:name :: ?type:expression,
    #rest ?options:*; ... }                             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ?mods:* slot ?:name :: ?type:expression = ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { required keyword ?key:expression,
    #rest ?options:*; ... }                             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { required keyword ?key:expression ?equals:token ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { keyword ?key:expression, #rest ?options:*; ... }    =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { keyword ?key:expression ?equals:token ?init:expression,
    #rest ?options:*; ... }                             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-51></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1293></A>Define Constant</H3>
<PRE CLASS=Cv.Code>
define macro constant-definer
  { define ?modifiers:* constant
    ?:name :: ?type:expression = ?init:expression }     =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { define ?modifiers:* constant
    (?variables:*) ?equals:token ?init:expression }     =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-53></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1294></A>Define Domain</H3>
<PRE CLASS=Cv.Code>
define macro domain-definer
  { define sealed domain ?:name ( ?types ) }            =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 types:
  { } =&gt; { }
  { ?type:expression, ... } =&gt; { ?type, ... }
end;
</PRE>
<A NAME=HEADING86-56></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1295></A>Define Generic</H3>
<PRE CLASS=Cv.Code>
define macro generic-definer
  { define ?mods:* generic ?:name ?rest:* }             =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 rest:
  { ( ?parameters:* ), #key }                           =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ( ?parameters:* ) =&gt; ?:variable, #key }             =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ( ?parameters:* ) =&gt; (?variables:*), #key }         =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-59></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1296></A>Define Library</H3>
<PRE CLASS=Cv.Code>
define macro library-definer
  { define library ?:name ?items end }                  =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 items:
  { }                                                   =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { use ?:name, #rest ?options:*; ... }                 =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { export ?names; ... }                                =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 names:
  { ?:name }                                            =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ?:name, ... }                                       =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-63></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1297></A>Define Method</H3>
<PRE CLASS=Cv.Code>
define macro method-definer
  { define ?mods:* method ?:name ?rest end }            =&gt;  <I CLASS="Parameter Cv.Code">id
</I> rest:
  { (?parameters:*) =&gt; (?results:*) ; ?:body }          =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { (?parameters:*) =&gt; (?results:*) ?:body }            =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { (?parameters:*) =&gt; ?result:variable ; ?:body }      =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { (?parameters:*) ; ?:body }                          =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { (?parameters:*) ?:body }                            =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-65></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1298></A>Define Module</H3>
<PRE CLASS=Cv.Code>
define macro module-definer
  { define module ?:name ?items end }                   =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 items:
  { }                                                   =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { use ?:name, #rest ?options:*; ... }                 =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { export ?names; ... }                                =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { create ?names; ... }                                =&gt;  <I CLASS="Parameter Cv.Code">id</I>
 names:
  { ?:name }                                            =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { ?:name, ... }                                       =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-69></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1299></A>Define Variable</H3>
<PRE CLASS=Cv.Code>
define macro variable-definer
  { define ?modifiers:* variable
    ?:name :: ?type:expression = ?init:expression }     =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { define ?modifiers:* variable
    (?variables:*) ?equals:token ?init:expression }     =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;
</PRE>
<A NAME=HEADING86-71></A>
<A NAME=UID-Macros-7337></A>
<H2 CLASS=H2.Heading2> Operator Function Macros</H2>
<A NAME=HEADING86-72></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1300></A>&amp;</H3>
<PRE CLASS=Cv.Code>
define macro \&amp;
  { \&amp;(?first:expression, ?second:expression) }
   =&gt; { if (?first) ?second else #f end }
end;
</PRE>
<A NAME=HEADING86-74></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1301></A>|</H3>
<PRE CLASS=Cv.Code>
define macro \|
  { \|(?first:expression, ?second:expression) }
   =&gt; { let temp = ?first;
        if (temp) temp else ?second end }
end;
</PRE>
<A NAME=HEADING86-76></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-1302></A>:=</H3>
<PRE CLASS=Cv.Code>
define macro \:=
  { \:=(?place:macro, ?value:expression) }              =&gt;  <I CLASS="Parameter Cv.Code">id
</I>  { \:=(?place:expression, ?value:expression) }         =&gt;  <I CLASS="Parameter Cv.Code">id
</I>end;<A NAME=MARKER-2-1303></A>
</PRE>
<A NAME=HEADING86-78></A>
<A NAME=UID-Macros-7361></A>
<H2 CLASS=H2.Heading2> Additional Examples</H2>
<P CLASS=T1.Text1>The following macros are not built-in, but are simply supplied as examples. Each is shown as a definition followed by a sample call.</P>
<A NAME=HEADING86-80></A>
<H3 CLASS=H3.Heading3> Test and Test-setter</H3>
<PRE CLASS=Cv.Code>
define macro test
  { test(?object:expression) }
   =&gt; { frame-slot-getter(?object, #&quot;test&quot;) }
end macro;
define macro test-setter
  { test-setter(?value:expression, ?object:expression) }
   =&gt; { frame-slot-setter(?value, ?object, #&quot;test&quot;) }
end macro;
test(foo.bar) := foo.baz;
</PRE>
<A NAME=HEADING86-84></A>
<H3 CLASS=H3.Heading3> Transform!</H3>
<PRE CLASS=Cv.Code>
define macro transform!
 // base case
 { transform!(?xform:expression) } =&gt; { ?xform }
 // the main recursive rule
 { transform!(?xform:expression, ?x:expression, ?y:expression,
              ?more:*) }
  =&gt; { let xform = ?xform;
       let (nx, ny) = transform(xform, ?x, ?y);
       ?x := nx; ?y := ny;
       transform!(xform, ?more) }
end macro;
transform!(w.transformation, xvar, yvar, w.pos.x, w.pos.y);
</PRE>
<A NAME=HEADING86-87></A>
<H3 CLASS=H3.Heading3> Formatting-table</H3>
<PRE CLASS=Cv.Code>
define macro formatting-table
  { formatting-table (?:expression,
                      #rest ?options:expression,
                      #key ?x-spacing:expression = 0,
                           ?y-spacing:expression = 0)
      ?:body end }
   =&gt; { do-formatting-table(?expression, method() ?body end,
                            ?options) }
end macro;
formatting-table (stream, x-spacing: 10, y-spacing: 12)
  foobar(stream)
end;
</PRE>
<A NAME=HEADING86-90></A>
<H3 CLASS=H3.Heading3> With-input-context</H3>
<PRE CLASS=Cv.Code>
define macro with-input-context
  { with-input-context (?context-type:expression,
                        #key ?override:expression = #f)
     ?bbody end }
   =&gt; { do-with-input-context(?context-type, ?bbody,
                              override: ?override) }
 bbody:
  { ?:body ?clauses }  =&gt; { list(?clauses), method() ?body end }
 clauses:
  { }                  =&gt; { }
  { on (?:name :: ?spec:expression, ?type:variable) ?:body ... }
   =&gt; { pair(?spec, method (?name :: ?spec, ?type) ?body end),
        ... }
end macro;
with-input-context (context-type, override: #t)
      // the body that reads from the user
      read-command-or-form (stream);
    // the clauses that dispatch on the type
    on (object :: &lt;command&gt;, type) execute-command (object);
    on (object :: &lt;form&gt;, type) evaluate-form (object, type);
end;
</PRE>
<A NAME=HEADING86-95></A>
<H3 CLASS=H3.Heading3> Define Command</H3>
<PRE CLASS=Cv.Code>
define macro command-definer
 { define command ?:name (?arguments:*) (#rest ?options:expression)
     ?:body end }
  =&gt; { define-command-1 ?name (?arguments) ?body end;
       define-command-2 ?name (?arguments) (?options) end }
end macro;
// define the method that implements a command
// throws away the &quot;stuff&quot; in each argument used by the command parser
define macro define-command-1
 { define-command-1 ?:name (?arguments) ?:body end }
  =&gt; { define method ?name (?arguments) ?body end }
 // map over ?arguments, reducing each to a parameter-list entry
 // but when we get to the first argument that has a default, put
 // in #key and switch to the key-arguments loop
 arguments:
  { } =&gt; { }
  { ?:variable = ?default:expression ?stuff:*, ?key-arguments }
   =&gt; { #key ?variable = ?default, ?key-arguments }
  { ?argument, ... } =&gt; { ?argument, ... }
 // map over keyword arguments the same way, each must
 // have a default
 key-arguments:
  { } =&gt; { }
  { ?key-argument, ... } =&gt; { ?key-argument, ... }
 // reduce one required argument spec to a parameter-list entry
 argument:
  { ?:variable ?stuff:* } =&gt; { ?variable }
 // reduce one keyword argument spec to a parameter-list entry
 key-argument:
  { ?:variable = ?default:expression ?stuff:* }
   =&gt; { ?variable = ?default }
end macro;
// generate the datum that describes a command and install it
define macro define-command-2
 { define-command-2 ?:name (?arguments) (#rest ?options:*) end }
  =&gt; { install-command(?name, list(?arguments), ?options) }
 // map over ?arguments, reducing each to a data structure
 arguments:
  { } =&gt; { }
  { ?argument, ... } =&gt; { ?argument, ... }
 // reduce one argument specification to a data structure
 argument:
  { ?:name :: ?type:expression = ?default:expression ?details }
   =&gt; { make(&lt;argument-info&gt;, name: ?&quot;name&quot;, type: ?type,
             default: ?default, ?details) }
  { ?:name :: ?type:expression ?details }
   =&gt; { make(&lt;argument-info&gt;, name: ?&quot;name&quot;, type: ?type, ?details) }
 // translate argument specification to &lt;argument-info&gt; init keywords
 details:
  { } =&gt; { }
  { ?key:name ?value:expression ... } =&gt; { ?#&quot;key&quot; ?value, ... }
end macro;
define command com-show-home-directory
       (directory :: &lt;type&gt; provide-default #t,
        before :: &lt;time&gt; = #() prompt &quot;date&quot;,
        after  :: &lt;time&gt; = #() prompt &quot;date&quot;)
       // Options
       (command-table: directories,
        name: &quot;Show Home Directory&quot;)
    body()
end command com-show-home-directory;
</PRE>
<A NAME=HEADING86-107></A>
<H3 CLASS=H3.Heading3> Get-resource</H3>
<PRE CLASS=Cv.Code>
// The idea is that in this application each library has its own
// variable named $library, which is accessible to modules in that
// library. Get-resource gets a resource associated with the library
// containing the call to it. Get-resource-from-library is a function.
// The get-resource macro is a device to make programs more concise.
define macro get-resource
  { get-resource(?type:expression, ?id:expression) }
   =&gt; { get-resource-from-library(?=$library, ?type, ?id) }
end macro;
show-icon(get-resource(ResType(&quot;ICON&quot;), 1044));
</PRE>
<A NAME=HEADING86-110></A>
<H3 CLASS=H3.Heading3> Completing-from-suggestions</H3>
<PRE CLASS=Cv.Code>
// The completing-from-suggestions macro defines a lexically visible
// helper function called &quot;suggest,&quot; which is only meaningful inside
// of calls to the completer. The &quot;suggest&quot; function is passed as an
// argument to the method passed to complete-input; alternatively it
// could have been defined in a local declaration wrapped around the
// method.
define macro completing-from-suggestions
  { completing-from-suggestions (?stream:expression,
                                 #rest ?options:expression)
      ?:body end }
   =&gt;{ complete-input(?stream,
                      method (?=suggest) ?body end,
                      ?options) }
end macro;
completing-from-suggestions (stream, partial-completers: #(' ', '-'))
  for (command in commands)
    suggest (command, command-name (command))
  end for;
end completing-from-suggestions;
</PRE>
<A NAME=HEADING86-113></A>
<H3 CLASS=H3.Heading3> Define Jump-instruction</H3>
<PRE CLASS=Cv.Code>
define macro jump-instruction-definer
  { define jump-instruction ?:name ?options:* end }
   =&gt; { register-instruction(&quot;j&quot; ## ?#&quot;name&quot;,
                             make(&lt;instruction&gt;,
                                  debug-name: &quot;j&quot; ## ?&quot;name&quot;,
                                  ?options)) }
end macro;
define jump-instruction eq cr-bit: 2, commutative?: #t end;
</PRE>
<P CLASS=T1.Text1><A NAME=MARKER-2-1304></A><A NAME=MARKER-2-1305></A></P>
<A NAME=LINK-Macros-lastpage></A><A NAME="LINK-Built-in_ClassesTOC-firstpage"></A><!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<A NAME="UID-Built-in_ClassesTOC-2080"></A>
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<A NAME="LINK-Built-in_ClassesTOC-lastpage"></A>
</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-3" CLASS=FOOTER><B CLASS=FOOTER></B>Statement Macros</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-4" CLASS=FOOTER><B CLASS=FOOTER></B>Begin</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-6" CLASS=FOOTER><B CLASS=FOOTER></B>Block</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-11" CLASS=FOOTER><B CLASS=FOOTER></B>Case</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-13" CLASS=FOOTER><B CLASS=FOOTER></B>For</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-30" CLASS=FOOTER><B CLASS=FOOTER></B>If</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-32" CLASS=FOOTER><B CLASS=FOOTER></B>Method</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-34" CLASS=FOOTER><B CLASS=FOOTER></B>Select</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-40" CLASS=FOOTER><B CLASS=FOOTER></B>Unless</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-42" CLASS=FOOTER><B CLASS=FOOTER></B>Until</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-44" CLASS=FOOTER><B CLASS=FOOTER></B>While</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-46" CLASS=FOOTER><B CLASS=FOOTER></B>Definition Macros</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-47" CLASS=FOOTER><B CLASS=FOOTER></B>Define Class</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-51" CLASS=FOOTER><B CLASS=FOOTER></B>Define Constant</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-53" CLASS=FOOTER><B CLASS=FOOTER></B>Define Domain</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-56" CLASS=FOOTER><B CLASS=FOOTER></B>Define Generic</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-59" CLASS=FOOTER><B CLASS=FOOTER></B>Define Library</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-63" CLASS=FOOTER><B CLASS=FOOTER></B>Define Method</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-65" CLASS=FOOTER><B CLASS=FOOTER></B>Define Module</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-69" CLASS=FOOTER><B CLASS=FOOTER></B>Define Variable</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-71" CLASS=FOOTER><B CLASS=FOOTER></B>Operator Function Macros</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-72" CLASS=FOOTER><B CLASS=FOOTER></B>&amp;</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-74" CLASS=FOOTER><B CLASS=FOOTER></B>|</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-76" CLASS=FOOTER><B CLASS=FOOTER></B>:=</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-78" CLASS=FOOTER><B CLASS=FOOTER></B>Additional Examples</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-80" CLASS=FOOTER><B CLASS=FOOTER></B>Test and Test-setter</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-84" CLASS=FOOTER><B CLASS=FOOTER></B>Transform!</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-87" CLASS=FOOTER><B CLASS=FOOTER></B>Formatting-table</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-90" CLASS=FOOTER><B CLASS=FOOTER></B>With-input-context</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-95" CLASS=FOOTER><B CLASS=FOOTER></B>Define Command</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-107" CLASS=FOOTER><B CLASS=FOOTER></B>Get-resource</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-110" CLASS=FOOTER><B CLASS=FOOTER></B>Completing-from-suggestions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_86.htm#HEADING86-113" CLASS=FOOTER><B CLASS=FOOTER></B>Define Jump-instruction</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_87.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_85.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_52.htm">
<LINK REL=PREV HREF="drm_52.htm">
<LINK REL=NEXT HREF="drm_54.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Background</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING53></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_54.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_52.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_52.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>7 Conditions</P>

</DIV>
<A NAME=HEADING53-0></A>
<A NAME=UID-Conditions-2630></A>
<H1 CLASS=H1.Heading1> Background</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-887></A><A NAME=MARKER-2-888></A>A long-standing problem of software engineering is the need to develop an organized way to deal with exceptions, situations that must be handled gracefully but that are not conceptually part of the normal operation of the program.</P>
<P CLASS=T1.Text1>Of course it is possible to program exception handling without using special linguistic features. For example, all functions could return an extra result that indicates whether they succeeded or failed, functions could take an extra argument that they consult if an exception occurs, or a designated exception-handling function could be called whenever a problem arises. All of these approaches have been used in one real-life system or another, but they are deficient in two ways. First, they are too informal and don't provide enough structure to allow an organized, systematic approach to exception handling. Second, and more importantly, the first two approaches do not provide textual separation between "normal code" and "code for dealing with exceptions"; exception-related code is sprinkled throughout the program. This leads to two problems: one is the well-known mistake of forgetting to test error codes and thus failing to detect an exception (perhaps because the programmer believed the error could never occur); the other is that program clarity is lost because it isn't easy to think about the main flow of the program while temporarily ignoring exceptions.</P>
<P CLASS=T1.Text1>All exception systems involve the concept of "<A NAME=MARKER-2-889></A>signal" (sometimes with a different name, such as "<A NAME=MARKER-2-890></A>raise" or "<A NAME=MARKER-2-891></A>throw") and the concept of "<A NAME=MARKER-2-892></A>handle" (sometimes with a different name such as "<A NAME=MARKER-2-893></A>on-unit" or "<A NAME=MARKER-2-894></A>catch"). <A NAME=MARKER-2-895></A>Most exception systems dynamically match signalers with handlers, first invoking the most recently established matching handler still active, and then, if that matching handler declines to handle the exception, invoking the next most recent matching handler, and so on.</P>
<P CLASS=T1.Text1>In addition, it is necessary to have a way to clean up when execution of a function is terminated by a nonlocal exit initiated either by the function itself or by something it explicitly or implicitly called.</P>
<P CLASS=T1.Text1>Exception systems may be name-based or object-based, they may be exiting or calling, and they may or may not provide formal recovery mechanisms.</P>
<P CLASS=T1.Text1>In a <A NAME=MARKER-2-896></A>name-based exception system a program signals a name, and a handler matches if it handles the same name or "any."  The name is a constant in the source text of the program, not the result of an expression.</P>
<P CLASS=T1.Text1>In an <A NAME=MARKER-2-897></A>object-based exception system a program signals an object, and a handler matches if it handles a type that object belongs to. Object-based exceptions are more powerful, because the object can communicate additional information from the signaler to the handler, because the object to be signaled can be chosen at run-time rather than signaling a fixed name, and because type inheritance in the handler matching adds abstraction and provides an organizing framework.</P>
<P CLASS=T1.Text1>In an <A NAME=MARKER-2-898></A>exiting exception system, all dynamic state between the handler and the signaler is unwound before the handler receives control, as if signaling were a nonlocal goto from the signaler to the handler.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-899></A>In a <A NAME=MARKER-2-900></A>calling exception system the signaler is still active when a handler receives control. Control can be returned to the signaler, as if signaling were a function call from the signaler to the handler.</P>
<P CLASS=T1.Text1>Exiting exception systems are acceptable for errors. However, they do not work for an exception that is not an error and doesn't require an exit, either because there is a default way to handle it and recover or because it can safely be ignored by applications that don't care about it. <A NAME=MARKER-2-901></A>Non-error exceptions are quite common in networked environments, in computers with gradually expiring resources (such as batteries), in complex user interfaces, and as one approach for reflecting hardware exceptions such as page protection violations or floating-point overflow to the application.</P>
<P CLASS=T1.Text1>Most languages have not formalized how to recover from exceptions, leaving programmers to invent ad hoc mechanisms. However, a <A NAME=MARKER-2-902></A>formal recovery mechanism is useful for several reasons: it ensures that recovery is implemented correctly;  it allows options for recovery to be categorized just as exceptions are categorized;  and it allows <A NAME=MARKER-2-903></A>introspection on the options for recovery, for example, by a debugger.</P>
<P CLASS=T1.Text1>The Dylan exception facility is object-based. It uses calling semantics but also provides exiting handlers. It provides formal recovery.<A NAME=MARKER-2-904></A></P>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC -->

</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_54.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_52.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_52.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

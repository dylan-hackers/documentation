<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_70.htm">
<LINK REL=PREV HREF="drm_74.htm">
<LINK REL=NEXT HREF="drm_76.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Define Sealed Domain</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING75></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_74.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_70.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>9 Sealing</P>

</DIV>
<A NAME=HEADING75-0></A>
<A NAME=UID-Sealing-2976></A>
<H1 CLASS=H1.Heading1> <A NAME=MARKER-9-1123></A>Define Sealed Domain</H1>
<P CLASS=T1.Text1><CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-1124></A><A NAME=MARKER-2-1125></A>define sealed domain</CODE> is used to make specific portions of a generic function and of the class hierarchy invariant without disallowing all future changes. The arguments to <CODE CLASS="cv T1.Text1">define sealed domain</CODE> are an explicitly known generic function and a series of types, one for each required argument of the generic function.</P>
<P CLASS=T1.Text1>The complete syntax of <CODE CLASS="cv T1.Text1">define</CODE> <CODE CLASS="cv T1.Text1">sealed domain</CODE> is given on <A HREF="drm_112.htm#MARKER-9-2024" CLASS=T1.Text1>page 388</A>.</P>
<P CLASS=T1.Text1>A <CODE CLASS="Code T1.Text1">define sealed domain</CODE> definition in a library <I CLASS="Parameter T1.Text1">L</I> for a generic function <I CLASS="Parameter T1.Text1">G</I> with types <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">1...Tn</EM></I> imposes the following <A NAME=MARKER-2-1126></A>constraints on programs:</P>
<P CLASS="N/.NList=1">A method <I CLASS="Parameter N/.NList=1">M</I> that is congruent to <I CLASS="Parameter N/.NList=1">G</I> and that is not an explicitly known method in <I CLASS="Parameter N/.NList=1">L</I> may be added to <I CLASS="Parameter N/.NList=1">G</I> only if at least one of the specializers for <I CLASS="Parameter N/.NList=1">M</I> is disjoint from the corresponding <I CLASS="Parameter N/.NList=1">T</I>.</P>
<P CLASS=N.NList>A method <I CLASS="Parameter N.NList">M</I> may be removed from <I CLASS="Parameter N.NList">G</I> only if at least one of the specializers for <I CLASS="Parameter N.NList">M</I> is disjoint from the corresponding <I CLASS="Parameter N.NList">T</I>.</P>
<P CLASS=N.NList>A class <I CLASS="Parameter N.NList">C</I> (with direct superclasses <I CLASS="Parameter N.NList">D<EM CLASS="Subscript Parameter N.NList">1</EM></I>...<I CLASS="Parameter N.NList">D<EM CLASS="Subscript Parameter N.NList">m</EM></I>) that is not explicitly known in <I CLASS="Parameter N.NList">L</I> may be created only if no method in <I CLASS="Parameter N.NList">G</I> actually blocks <I CLASS="Parameter N.NList">C</I>.</P>
<UL CLASS=B2.Bullet2>
<UL CLASS=B2.Bullet2>
<LI CLASS=B2.Bullet2>A method <I CLASS="Parameter B2.Bullet2">M</I> (with specializers <I CLASS="Parameter B2.Bullet2">S<EM CLASS="Subscript Parameter B2.Bullet2">1</EM></I>...<I CLASS="Parameter B2.Bullet2">S<EM CLASS="Subscript Parameter B2.Bullet2">n</EM></I>) in <I CLASS="Parameter B2.Bullet2">G</I> potentially blocks <I CLASS="Parameter B2.Bullet2">C</I> at argument position <I CLASS="Parameter B2.Bullet2">i</I> if there exist <I CLASS="Parameter B2.Bullet2">j</I> and <I CLASS="Parameter B2.Bullet2">k</I> such that <I CLASS="Parameter B2.Bullet2">D<EM CLASS="Subscript Parameter B2.Bullet2">j</EM></I> is a pseudosubtype of <I CLASS="Parameter B2.Bullet2">S<EM CLASS="Subscript Parameter B2.Bullet2">i</EM></I>, <I CLASS="Parameter B2.Bullet2">D<EM CLASS="Subscript Parameter B2.Bullet2">k</EM></I> is a pseudosubtype of <I CLASS="Parameter B2.Bullet2">T<EM CLASS="Subscript Parameter B2.Bullet2">i</EM></I>, and <I CLASS="Parameter B2.Bullet2">D<EM CLASS="Subscript Parameter B2.Bullet2">k</EM></I> is not a pseudosubtype of <I CLASS="Parameter B2.Bullet2">S<EM CLASS="Subscript Parameter B2.Bullet2">i</EM></I>.
<LI CLASS=B2.Bullet2>A method <I CLASS="Parameter B2.Bullet2">M</I> actually blocks <I CLASS="Parameter B2.Bullet2">C</I> if <I CLASS="Parameter B2.Bullet2">M</I> potentially blocks <I CLASS="Parameter B2.Bullet2">C</I> at some argument position, and for every argument position <I CLASS="Parameter B2.Bullet2">i</I> where <I CLASS="Parameter B2.Bullet2">S<EM CLASS="Subscript Parameter B2.Bullet2">i</EM></I> and <I CLASS="Parameter B2.Bullet2">T<EM CLASS="Subscript Parameter B2.Bullet2">i</EM></I> are disjoint, <I CLASS="Parameter B2.Bullet2">M</I> potentially blocks <I CLASS="Parameter B2.Bullet2">C</I> at <I CLASS="Parameter B2.Bullet2">i</I>.
<P CLASS=T1.Text1>The third constraint is illustrated by the following example:</P>
</UL>
</UL>
<PRE CLASS=Cv.Code>
define generic m (x);
define class &lt;t&gt; (&lt;object&gt;) end class &lt;t&gt;;
define class &lt;s&gt; (&lt;object&gt;) end class &lt;s&gt;;
define method m (s :: &lt;s&gt;) end method m;
define sealed domain m (&lt;t&gt;);
define class &lt;c&gt; (&lt;s&gt;, &lt;t&gt;) end class &lt;c&gt;;
</PRE>
<P CLASS=T1.Text1>The definition of class <CODE CLASS="Code T1.Text1">&lt;c&gt;</CODE> would be valid if it appeared in the same library as the preceding definitions or in a library used by them, but invalid if it appeared in a different library. The reason is that without the definition of <CODE CLASS="Code T1.Text1">&lt;c&gt;</CODE>, the method defined on <CODE CLASS="Code T1.Text1">m</CODE> is not within the domain declared by the <CODE CLASS="Code T1.Text1">define sealed domain</CODE>, but with the definition of <CODE CLASS="Code T1.Text1">&lt;c&gt;</CODE> the method is within that domain.</P>
<A NAME=HEADING75-13></A>
<A NAME=UID-Sealing-2154></A>
<H2 CLASS=H2.Heading2> Rationale</H2>
<P CLASS=T1.Text1><CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-1127></A>define sealed domain</CODE> permits the compiler to assume certain properties of the program that can be computed based on explicitly known classes and methods, with a guarantee that an attempt to violate any of those assumptions will be detected.</P>
<P CLASS=T1.Text1>The goal of rule 3 is that the creation of the class <I CLASS="Parameter T1.Text1">C</I> must not make any method <I CLASS="Parameter T1.Text1">M</I> applicable to a part of the sealed domain to which it was not previously applicable.</P>
<P CLASS=T1.Text1>The "potentially blocks" concept describes the mechanism for testing whether the set of objects that are instances of both <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> and <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> (i.e., to which the method is applicable at the <I CLASS="Parameter T1.Text1">i</I>th argument position and that are within the sealed domain at that argument position) would change as a result of creating <I CLASS="Parameter T1.Text1">C</I>. By specifying what valid programs are allowed to do, rule 3 implicitly specifies the assumptions a compiler can make. A <CODE CLASS="Code T1.Text1">define sealed domain</CODE> definition accomplishes this by permitting the compiler to eliminate some of the known methods on a generic function from the set of methods that might be applicable to a particular call at runtime. For example, if this leaves exactly one applicable method, the compiler can eliminate a run-time method dispatch and consider additional optimizations such as inlining.</P>
<P CLASS=T1.Text1>Specifically, suppose the compiler is compiling a call to <I CLASS="Parameter T1.Text1">G</I> and has determined that the argument at position <I CLASS="Parameter T1.Text1">i</I> is an instance of some type <I CLASS="Parameter T1.Text1">U</I> (where <I CLASS="Parameter T1.Text1">U</I> is not necessarily a standard Dylan type, but could instead be a compiler-internal extension to the type system, such as a difference of two types). For the compiler to be able to rely on the <CODE CLASS="Code T1.Text1">define sealed domain</CODE> definition, <I CLASS="Parameter T1.Text1">U</I> must be a subtype of <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>. For the compiler to determine that <I CLASS="Parameter T1.Text1">M</I> is not applicable, <I CLASS="Parameter T1.Text1">U</I> must be disjoint with <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>. Creating <I CLASS="Parameter T1.Text1">C</I> can't change whether <I CLASS="Parameter T1.Text1">U</I> is a subtype of <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>, but it can change whether <I CLASS="Parameter T1.Text1">U</I> is disjoint with <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>. If there could be an object that is simultaneously an instance of <I CLASS="Parameter T1.Text1">U</I>, <I CLASS="Parameter T1.Text1">C</I>, and <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>, it would violate the compiler's assumption that <I CLASS="Parameter T1.Text1">M</I> is not applicable in the call to <I CLASS="Parameter T1.Text1">G</I>, and therefore creating <I CLASS="Parameter T1.Text1">C</I> would be a sealing violation. If there can't be such an object, then creating <I CLASS="Parameter T1.Text1">C</I> is allowed.</P>
<P CLASS=T1.Text1>This maps onto rule 3 as follows (ignoring for the moment the added complication of limited types that lead to the use of the pseudosubtype relationship rather than subtype):</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">U</I> is a subtype of <I CLASS="Parameter T1.Text1">D<EM CLASS="Subscript Parameter T1.Text1">k</EM></I> and therefore is a subtype of <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>, because subtype is transitive.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">D<EM CLASS="Subscript Parameter T1.Text1">k</EM></I> is not a subtype of <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>, because if it were then <I CLASS="Parameter T1.Text1">U</I> could not be disjoint from <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">D<EM CLASS="Subscript Parameter T1.Text1">j</EM></I> is a subtype of <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>.</P>
<P CLASS=T1.Text1>If <I CLASS="Parameter T1.Text1">U</I> and <I CLASS="Parameter T1.Text1">C</I> would have a nonempty intersection, then the creation of <I CLASS="Parameter T1.Text1">C</I> must be prevented, else <I CLASS="Parameter T1.Text1">U</I> would no longer be disjoint from <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>. One possible <I CLASS="Parameter T1.Text1">U</I> is the set of all general instances of <I CLASS="Parameter T1.Text1">D<EM CLASS="Subscript Parameter T1.Text1">k</EM></I> that are not also general instances of any of the explicitly known direct subclasses of <I CLASS="Parameter T1.Text1">D<EM CLASS="Subscript Parameter T1.Text1">k</EM></I>. That <I CLASS="Parameter T1.Text1">U</I> would indeed have a non-empty intersection with <I CLASS="Parameter T1.Text1">C</I>. The existence of this <I CLASS="Parameter T1.Text1">U</I> makes the proposed rule 3 necessary.</P>
<P CLASS=T1.Text1>Rule 3 does not need to address the possibility of multiple inheritance being used to combine classes involved in the element types of limited collection classes. Changes to the disjointness relationships between element types does not affect the relationships between collection types with those element types.<A NAME=MARKER-2-1128></A></P>
<A NAME=HEADING75-24></A>
<A NAME=UID-Sealing-2173></A>
<H2 CLASS=H2.Heading2> Pseudosubtype Examples</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-1129></A>Suppose <I CLASS="Parameter T1.Text1">A</I> and <I CLASS="Parameter T1.Text1">B</I> are disjoint subclasses of <CODE CLASS="cv T1.Text1">&lt;collection&gt;</CODE>, <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> is <CODE CLASS="cv T1.Text1">limited(<I CLASS="Parameter cv T1.Text1">A, of: T)</I></CODE>, and <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> is <CODE CLASS="cv T1.Text1">limited(<I CLASS="Parameter cv T1.Text1">B, of: T)</I></CODE>. Thus, <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> and <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> are disjoint and <I CLASS="Parameter T1.Text1">M</I> is outside the sealed domain. If <I CLASS="Parameter T1.Text1">C</I> inherits from <I CLASS="Parameter T1.Text1">A</I> and <I CLASS="Parameter T1.Text1">B</I> it should be potentially blocked by <I CLASS="Parameter T1.Text1">M</I>, because an instance of <CODE CLASS="cv T1.Text1">limited(<I CLASS="Parameter cv T1.Text1">C, of: T)</I></CODE> would be an instance of both <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> and <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>. Since <I CLASS="Parameter T1.Text1">B</I> is not a subtype of <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>, there would be no blockage if the constraints in rule 3 were defined in terms of <CODE CLASS="cv T1.Text1">subtype</CODE>. However, <I CLASS="Parameter T1.Text1">B</I> is a pseudosubtype of <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>, so specifying rule 3 using the pseudosubtype relationship correctly causes <I CLASS="Parameter T1.Text1">M</I> to potentially block <I CLASS="Parameter T1.Text1">C</I>.</P>
<P CLASS=T1.Text1>Suppose <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> is <CODE CLASS="cv T1.Text1">limited(&lt;stretchy-vector&gt;, of: &lt;integer&gt;)</CODE> and <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> is <CODE CLASS="cv T1.Text1">limited(&lt;sequence&gt;, of: &lt;integer&gt;)</CODE>. It should be possible to create <CODE CLASS="cv T1.Text1">&lt;stretchy-string&gt;</CODE>, a direct subclass of <CODE CLASS="cv T1.Text1">&lt;stretchy-vector&gt;</CODE> and <CODE CLASS="cv T1.Text1">&lt;string&gt;</CODE>. The element-type of <CODE CLASS="cv T1.Text1">&lt;stretchy-string&gt;</CODE> must be a subtype of <CODE CLASS="cv T1.Text1">&lt;character&gt;</CODE>, therefore, assuming <CODE CLASS="cv T1.Text1">&lt;integer&gt;</CODE> and <CODE CLASS="cv T1.Text1">&lt;character&gt;</CODE> are disjoint, <CODE CLASS="cv T1.Text1">&lt;stretchy-string&gt;</CODE> is disjoint from both <I CLASS="Parameter T1.Text1">S<EM CLASS="Subscript Parameter T1.Text1">i</EM></I> and <I CLASS="Parameter T1.Text1">T<EM CLASS="Subscript Parameter T1.Text1">i</EM></I>, and so is not blocked. This example shows the need for the non-disjointness requirement in the definition of pseudosubtype.<A NAME=MARKER-2-1130></A></P>
<A NAME=HEADING75-27></A>
<A NAME=UID-Sealing-1419></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-9-1131></A>Abbreviations for Define Sealed Domain</H2>
<P CLASS=T1.Text1><CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-1132></A><A NAME=MARKER-2-1133></A>define sealed method</CODE> defines a method on a generic function and also seals the generic function for the types that are the specializers of the method. </P>
<P CLASS=T1.Text1>The following two program fragments are equivalent: </P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>define sealed method insert (source :: &lt;list&gt;, i :: &lt;object&gt;)<BR>  =&gt; (result :: &lt;list&gt;)<BR>  ...<BR>end method insert;</CODE></P>
<P CLASS=T1.Text1>and</P>
<PRE CLASS=Cv.Code>
define method insert (source :: &lt;list&gt;, i :: &lt;object&gt;)
  =&gt; (result :: &lt;list&gt;)
  ...
end method insert;
define sealed domain insert (&lt;list&gt;, &lt;object&gt;);
</PRE>
<P CLASS=T1.Text1>The <CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-1134></A>sealed slot</CODE> option to <CODE CLASS="Code T1.Text1">define class</CODE> defines a slot and also makes the getter generic function sealed over the class, and the setter generic function, if there is one, sealed over the type of the slot and the class.</P>
<P CLASS=T1.Text1>The following two program fragments are equivalent:</P>
<PRE CLASS=Cv.Code>
define class &lt;polygon&gt; (&lt;shape&gt;)
  sealed slot sides :: &lt;integer&gt;, required-init-keyword: sides:;
end class &lt;polygon&gt;;
</PRE>
<P CLASS=T1.Text1>and</P>
<PRE CLASS=Cv.Code>
define class &lt;polygon&gt; (&lt;shape&gt;)
  slot sides :: &lt;integer&gt;, required-init-keyword: sides:;
end class &lt;polygon&gt;;
define sealed domain sides (&lt;polygon&gt;);
define sealed domain sides-setter (&lt;integer&gt;, &lt;polygon&gt;);<A NAME=MARKER-2-1135></A>
</PRE>
<A NAME=HEADING75-38></A>
<A NAME=UID-Sealing-1853></A>
<H2 CLASS=H2.Heading2> Implied Restrictions on Method Definitions</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-1136></A>To avoid potential <A NAME=MARKER-2-1137></A>sealing violations among separately developed libraries, one of the following conditions should be true for every method <I CLASS="Parameter T1.Text1">M</I> defined in a library <I CLASS="Parameter T1.Text1">L</I>:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>Either the generic function to which <I CLASS="Parameter B1.Bullet1">M</I> is added should be defined in the library <I CLASS="Parameter B1.Bullet1">L</I>, or
<LI CLASS=B1.Bullet1>One of the specializers of <I CLASS="Parameter B1.Bullet1">M</I> should be a subtype of a class defined in <BR>library <I CLASS="Parameter B1.Bullet1">L</I>.
<P CLASS=T1.Text1>The following example illustrates why this condition is necessary.</P>
<P CLASS=T1.Text1>Library <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">1</EM></I> defines and exports the following:</P>
</UL>
<PRE CLASS=Cv.Code>
define generic g (x)
define class &lt;c1&gt; (&lt;object&gt;) end class &lt;c1&gt;;<I CLASS="Parameter Cv.Code"></I>
</PRE>
<P CLASS=T1.Text1>Library <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">2</EM></I> uses <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">1</EM></I> and defines the following</P>
<PRE CLASS=Cv.Code>
define class &lt;c2&gt; (&lt;c1&gt;) end class &lt;c2&gt;;
define method g (x :: &lt;c2&gt;) end method;
define sealed domain g (&lt;c2&gt;)
</PRE>
<P CLASS=T1.Text1>Library <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">3</EM></I> uses <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">1</EM></I> and defines the following</P>
<PRE CLASS=Cv.Code>
define method g (x :: &lt;c&gt;) end method;
</PRE>
<P CLASS=T1.Text1>Libraries <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">2</EM></I> and <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">3</EM></I> are developed independently, and have no knowledge of each other. An application that attempts to use both <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">2</EM></I> and <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">3</EM></I> contains a sealing violation. <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">2</EM></I> is clearly valid. Therefore, <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">3</EM></I> is at fault for the sealing violation. Because the compiler cannot prove that use of <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">3</EM></I> will lead to an error (and indeed, it will only lead to an error in the presence of <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">2</EM></I>), it is appropriate to issue a warning but not disallow the compilation of <I CLASS="Parameter T1.Text1">L<EM CLASS="Subscript Parameter T1.Text1">3</EM></I>.<A NAME=MARKER-2-1138></A><A NAME=MARKER-2-1139></A></P>
<A NAME=LINK-Sealing-lastpage></A><A NAME=LINK-MacrosTOC-firstpage></A><!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<A NAME=UID-MacrosTOC-714></A>
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<!-- FM pgf ignored -->
<A NAME=LINK-MacrosTOC-lastpage></A>
</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_75.htm#HEADING75-13" CLASS=FOOTER><B CLASS=FOOTER></B>Rationale</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_75.htm#HEADING75-24" CLASS=FOOTER><B CLASS=FOOTER></B>Pseudosubtype Examples</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_75.htm#HEADING75-27" CLASS=FOOTER><B CLASS=FOOTER></B>Abbreviations for Define Sealed Domain</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_75.htm#HEADING75-38" CLASS=FOOTER><B CLASS=FOOTER></B>Implied Restrictions on Method Definitions</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_74.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_70.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_116.htm">
<LINK REL=PREV HREF="drm_117.htm">
<LINK REL=NEXT HREF="drm_119.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Phrase Grammar</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING118></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_119.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_117.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_116.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>A BNF</P>

</DIV>
<A NAME=HEADING118-0></A>
<A NAME="UID-BNF_Appendix-564"></A>
<H1 CLASS=H1.Heading1> Phrase Grammar</H1>
<A NAME=HEADING118-1></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2107></A>Program Structure</H2>
<P CLASS=T1.Text1><I CLASS=T1.Text1>source-record:<BR> body<EM CLASS="Subscript T1.Text1">opt</EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">body:<BR> constituents  <CODE CLASS="italics T1.Text1">;<EM CLASS="Subscript italics T1.Text1">opt</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">constituents:<BR> constituent  <CODE CLASS="italics T1.Text1">; ...</CODE></I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>constituent:<BR> definition<BR> local-declaration<BR> expression</I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>macro:<BR> definition-macro-call<BR> statement<BR> function-macro-call</I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1> parsed-macro-call</I></P>
<A NAME=HEADING118-8></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2108></A>Property Lists</H2>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">comma-property-list:<BR><CODE CLASS="italics T1.Text1"> , property-list</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">property-list:<BR> property  <CODE CLASS="italics T1.Text1">, ...</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">property:<BR><EM CLASS="italics T1.Text1"> symbol value</EM></I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>value:<BR> basic-fragment</I></P>
<A NAME=HEADING118-13></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2109></A>Fragments</H2>
<P CLASS=T1.Text1><I CLASS=T1.Text1>body-fragment:<BR> non-statement-body-fragment<BR> statement   non-statement-body-fragment<EM CLASS="Subscript T1.Text1">opt</EM></I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>list-fragment:<BR> non-statement-list-fragment<BR> statement   non-statement-list-fragment<EM CLASS="Subscript T1.Text1">opt</EM></I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>basic-fragment:<BR> non-statement-basic-fragment<BR> statement   non-statement-basic-fragment<EM CLASS="Subscript T1.Text1">opt</EM></I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>non-statement-body-fragment:<BR> definition   semicolon-fragment<EM CLASS="Subscript T1.Text1">opt<BR> local-declaration   semicolon-fragmentopt<BR></EM></I> simple-fragment   body-fragment<EM CLASS="Subscript T1.Text1">opt<BR><CODE CLASS="Subscript T1.Text1"> , </CODE></EM> body-fragment<EM CLASS="Subscript T1.Text1">opt<BR><CODE CLASS="Subscript T1.Text1"> ; </CODE></EM> body-fragment<EM CLASS="Subscript T1.Text1">opt</EM></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">semicolon-fragment:<BR><CODE CLASS="italics T1.Text1"> ; body-fragment<EM CLASS="Subscript italics T1.Text1">opt</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">non-statement-list-fragment:<BR> simple-fragment   list-fragment<EM CLASS="Subscript italics T1.Text1">opt<BR><CODE CLASS="Subscript italics T1.Text1"> , list-fragmentopt</CODE></EM></I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>non-statement-basic-fragment:<BR> simple-fragment   basic-fragment<EM CLASS="Subscript T1.Text1">opt</EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">simple-fragment:<BR> variable-name<BR> constant-fragment<BR> <EM CLASS="italics T1.Text1">binary-operator<BR> unary-operator<BR> bracketed-fragment<BR> function-macro-call<BR> #-word<BR> one of <CODE CLASS="italics T1.Text1"> . :: =&gt; ? ?? ?= ... ## otherwise<BR></CODE></EM></I> <I CLASS="Parameter T1.Text1">parsed-function-call<BR></I> <I CLASS="Parameter T1.Text1">parsed-macro-call</I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">bracketed-fragment:<BR><CODE CLASS="italics T1.Text1"> (  body-fragment<EM CLASS="Subscript italics T1.Text1">opt  )<BR> [  body-fragmentopt  ]<BR> {  body-fragmentopt  }</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">constant-fragment:<BR></I> <EM CLASS=T1.Text1>number<BR></EM> <EM CLASS=T1.Text1>character-literal<BR></EM> <EM CLASS=T1.Text1>string</EM> <BR> <EM CLASS=T1.Text1>symbol<BR><CODE CLASS=T1.Text1> #(<I CLASS=T1.Text1>  constants  .  constant  )<BR> #(  constantsopt  )<BR> #[  constantsopt  ]<BR> parsed-list-constant<BR> parsed-vector-constant</I></CODE></EM></P>
<A NAME=HEADING118-24></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2110></A>Definitions</H2>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">definition:<BR></I> <I CLASS="Parameter T1.Text1">definition-macro-call<BR><CODE CLASS="Parameter T1.Text1"> define  macro  macro-definition<BR> parsed-definition</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">definition-macro-call:<BR><CODE CLASS="italics T1.Text1"> define  modifiers<EM CLASS="Subscript italics T1.Text1">opt define-body-word body-fragmentopt definition-tail<BR> define  modifiersopt define-list-word list-fragmentopt</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">modifier:<BR></I> <EM CLASS=T1.Text1>unreserved-name</EM></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">modifiers:<BR></I> <I CLASS="italics T1.Text1">modifier</I> ...</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">definition-tail:<BR> <EM CLASS="italics T1.Text1">end<BR> end macro-name<BR><CODE CLASS="italics T1.Text1"> end define-body-word macro-name</CODE></EM></I></P>
<A NAME=HEADING118-30></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2111></A>Local Declarations</H2>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">local-declaration:<BR><CODE CLASS="italics T1.Text1"> let  bindings<BR> let  handler  condition  =  handler<BR> local  local-methods<BR> parsed-local-declaration</CODE></I></P>
<P CLASS=T1i.Text1italic>condition:<BR> type<BR><CODE CLASS=T1i.Text1italic> (</CODE>  type  comma-property-list <CODE CLASS=T1i.Text1italic>)</CODE></P>
<P CLASS=T1i.Text1italic>handler:<BR> expression</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">local-methods:<BR> <CODE CLASS="italics T1.Text1">method<EM CLASS="Subscript italics T1.Text1">opt  method-definition  , ...</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">bindings:<BR> variable  <CODE CLASS="italics T1.Text1">=  expression<BR> (  variable-list  )  =  expression</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">variable-list:<BR> variables<BR> variables  <CODE CLASS="italics T1.Text1">,  #rest  variable-name <BR> #rest  variable-name  </CODE></I></P>
<P CLASS=T1i.Text1italic>variables:<BR> variable  <CODE CLASS=T1i.Text1italic>,</CODE> ...</P>
<P CLASS=T1i.Text1italic>variable:<BR> variable-name <BR> variable-name  <CODE CLASS=T1i.Text1italic>::</CODE>  type</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">variable-name:<BR></I> <EM CLASS=T1.Text1>ordinary-name</EM></P>
<P CLASS=T1i.Text1italic>type:<BR> operand</P>
<A NAME=HEADING118-41></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2112></A>Expressions</H2>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">expressions:<BR> expression  <CODE CLASS="italics T1.Text1">, ...</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">expression:<BR> binary-operand <EM CLASS="italics T1.Text1">binary-operator ...</EM></I></P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">expression-no-symbol</I>:<BR> <I CLASS="Parameter T1.Text1">binary-operand-no-symbol<BR> binary-operand-no-symbol</I> <EM CLASS=T1.Text1>binary-operator <I CLASS="Parameter T1.Text1">expression</I></EM></P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">binary-operand-no-symbol</I>:<BR> <EM CLASS=T1.Text1>unary-operator<I CLASS=T1.Text1>opt</I></EM> <I CLASS="Parameter T1.Text1">operand</I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">binary-operand:<BR></I> <EM CLASS=T1.Text1>symbol<BR> unary-operator<I CLASS=T1.Text1>opt  operand</I></EM></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">operand:<BR> operand  <CODE CLASS="italics T1.Text1">(  arguments<EM CLASS="Subscript italics T1.Text1">opt  )<BR> operand  [ argumentsopt ]<BR> operand  .  variable-name <BR></EM></CODE></I> <I CLASS="Parameter T1.Text1">leaf</I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>function-macro-call:<BR><EM CLASS=T1.Text1> function-word</EM></I> <CODE CLASS=T1.Text1>(</CODE> body-fragment<EM CLASS="Subscript T1.Text1">opt <CODE CLASS="Subscript T1.Text1">)</CODE></EM></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">leaf:<BR> literal<BR> variable-name <BR><CODE CLASS="italics T1.Text1"> (  expression  )<BR></CODE></I> <I CLASS="Parameter T1.Text1">function-macro-call<BR> statement<BR> parsed-function-call<BR> parsed-macro-call</I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">arguments:<BR> argument <CODE CLASS="italics T1.Text1">, ...</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">argument</I>:<BR> <EM CLASS=T1.Text1>symbol</EM> <I CLASS="Parameter T1.Text1">expression<BR></I> <I CLASS="Parameter T1.Text1">expression-no-symbol<BR></I> <EM CLASS=T1.Text1>symbol</EM></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">literal:<BR></I> <EM CLASS=T1.Text1>number<BR></EM> <EM CLASS=T1.Text1>character-literal<BR><I CLASS="italics T1.Text1"> string-literal<BR></I></EM> <B CLASS="bold T1.Text1"><CODE CLASS="bold T1.Text1">#t<BR> #f<BR> #(<I CLASS="bold T1.Text1">  constants  .  constant  )<BR> #(  constants<EM CLASS="Subscript bold T1.Text1">opt  )<BR> #[  constantsopt  ]<BR> parsed-list-constant<BR> parsed-vector-constant</EM></I></CODE></B></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">string-literal:<BR> <EM CLASS="italics T1.Text1">string ...</EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">constants:<BR> constant  <CODE CLASS="italics T1.Text1">, ...</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">constant:<BR> literal<BR></I> <EM CLASS=T1.Text1>symbol</EM></P>
<A NAME=HEADING118-56></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2113></A>Statements</H2>
<P CLASS=T1.Text1><I CLASS=T1.Text1>statement:<BR><EM CLASS=T1.Text1> begin-word</EM></I>  body-fragment<EM CLASS="Subscript T1.Text1">opt</EM>  end-clause</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">end-clause:<BR><CODE CLASS="italics T1.Text1"> end <EM CLASS="italics T1.Text1">begin-wordopt</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">case-body:<BR> cases  <CODE CLASS="italics T1.Text1">;<EM CLASS="Subscript italics T1.Text1">opt </EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">cases:<BR> case-label  constituents<EM CLASS="Subscript italics T1.Text1">opt  <CODE CLASS="Subscript italics T1.Text1">; ...</CODE></EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">case-label:<BR> expressions  <CODE CLASS="italics T1.Text1">=&gt;<BR> (  expression <EM CLASS="italics T1.Text1">, expressions )  =&gt;<BR> otherwise  =&gt;opt</EM></CODE></I></P>
<A NAME=HEADING118-62></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2114></A><A NAME=MARKER-9-2115></A>Methods</H2>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">method-definition:<BR> variable-name  parameter-list  body<EM CLASS="Subscript italics T1.Text1">opt  <CODE CLASS="Subscript italics T1.Text1">end  methodopt  variable-nameopt</CODE></EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">parameter-list:<BR><CODE CLASS="italics T1.Text1"> (  parameters<EM CLASS="Subscript italics T1.Text1">opt  )  ;opt <BR> (  parametersopt  )  =&gt;  variable  ; <BR> (  parametersopt )  =&gt;  ( values-listopt  )  ;opt</EM></CODE></I></P>
<P CLASS=T1i.Text1italic>parameters:<BR> required-parameters<BR> required-parameters  <CODE CLASS=T1i.Text1italic>,</CODE>  next-rest-key-parameter-list<BR> next-rest-key-parameter-list</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">next-rest-key-parameter-list:<BR><CODE CLASS="italics T1.Text1"> #next  variable-name <BR> #next  variable-name  ,  rest-key-parameter-list<BR> rest-key-parameter-list</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">rest-key-parameter-list:<BR><CODE CLASS="italics T1.Text1"> #rest  variable-name <BR> #rest  variable-name  ,  key-parameter-list<BR> key-parameter-list</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">key-parameter-list:<BR><CODE CLASS="italics T1.Text1"> #key</CODE></I>  <I CLASS=T1.Text1>keyword-parameters<EM CLASS="Subscript T1.Text1">opt<BR><CODE CLASS="Subscript T1.Text1"> #key</CODE></EM></I>  <I CLASS=T1.Text1>keyword-parameters<EM CLASS="Subscript T1.Text1">opt  <CODE CLASS="Subscript T1.Text1">,  #all-keys</CODE></EM></I></P>
<P CLASS=T1i.Text1italic>required-parameters:<BR> required-parameter  <B CLASS="bold T1i.Text1italic"><CODE CLASS="bold T1i.Text1italic">, <I CLASS="italics bold T1i.Text1italic">...</I></CODE></B></P>
<P CLASS=T1i.Text1italic>required-parameter:<BR> variable<BR> variable-name  <CODE CLASS=T1i.Text1italic>==</CODE>  expression</P>
<P CLASS=T1i.Text1italic>keyword-parameters:<BR> keyword-parameter  <CODE CLASS=T1i.Text1italic>,</CODE> ...</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">keyword-parameter:<BR> <EM CLASS="italics T1.Text1">symbolopt</EM></I>  <I CLASS=T1.Text1>variable  default<EM CLASS="Subscript T1.Text1">opt</EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">default:<BR><CODE CLASS="italics T1.Text1"> =</CODE></I>  <I CLASS=T1.Text1>expression</I></P>
<P CLASS=T1i.Text1italic><I CLASS="italics T1i.Text1italic">values-list:<BR> variables<BR></I> variables  <CODE CLASS=T1i.Text1italic>,</CODE>  <CODE CLASS=T1i.Text1italic>#rest</CODE>  variable <BR><CODE CLASS=T1i.Text1italic> #rest</CODE>  variable </P>
<A NAME=HEADING118-75></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2116></A>Macro Definitions</H2>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">macro-definition:<BR></I> macro-name<I CLASS=T1.Text1>  main-rule-set  aux-rule-sets<EM CLASS="Subscript T1.Text1">opt  <CODE CLASS="Subscript T1.Text1">end  macroopt </CODE></EM></I>macro-name<EM CLASS="Subscript T1.Text1"><I CLASS="Subscript T1.Text1">opt</I></EM></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">main-rule-set:<BR></I> <I CLASS="italics T1.Text1">body-style-definition-rule</I> ...<BR> <I CLASS="italics T1.Text1">list-style-definition-rule</I> ...<BR> <I CLASS="italics T1.Text1">statement-rule</I> ...<BR> <I CLASS="italics T1.Text1">function-rule</I> ...</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">body-style-definition-rule</I>:<BR><CODE CLASS=T1.Text1> {<I CLASS=T1.Text1>  define  definition-head<EM CLASS="Subscript T1.Text1">opt </EM></I></CODE>macro-name<I CLASS=T1.Text1> pattern<EM CLASS="Subscript T1.Text1">opt  <CODE CLASS="Subscript T1.Text1">;opt  end } =&gt; rhs</CODE></EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">list-style-definition-rule</I>:<BR><CODE CLASS=T1.Text1> {<I CLASS=T1.Text1>  define  definition-head<EM CLASS="Subscript T1.Text1">opt </EM></I></CODE>macro-name<I CLASS=T1.Text1>  pattern<EM CLASS="Subscript T1.Text1">opt <CODE CLASS="Subscript T1.Text1">}  =&gt; rhs</CODE></EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">rhs:<BR><CODE CLASS="italics T1.Text1"> {  template<EM CLASS="Subscript italics T1.Text1">opt  } ;opt</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1"><A NAME=MARKER-9-2117></A>definition-head</I>:<BR><I CLASS="italics T1.Text1"> modifier-pattern</I>  ...</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>modifier-pattern:<BR> modifier<BR> pattern-variable </I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">statement-rule:<BR><CODE CLASS="italics T1.Text1"> { </CODE></I>macro-name<I CLASS=T1.Text1>  pattern<EM CLASS="Subscript T1.Text1">opt  <CODE CLASS="Subscript T1.Text1">;opt  end  }  =&gt; rhs</CODE></EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">function-rule:<BR><CODE CLASS="italics T1.Text1"> { </CODE></I>macro-name  <B CLASS=T1.Text1>(</B>  <I CLASS=T1.Text1>pattern<EM CLASS="Subscript T1.Text1">opt </EM></I> <B CLASS=T1.Text1>) </B> <CODE CLASS=T1.Text1>}<I CLASS=T1.Text1>  =&gt; rhs</I></CODE></P>
<A NAME=HEADING118-85></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-2-2118></A>Patterns</H3>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">pattern:<BR> pattern-list  <CODE CLASS="italics T1.Text1">; ...</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">pattern-list:<BR> pattern-sequence <BR> property-list-pattern<BR> pattern-sequence  <B CLASS="italics T1.Text1">,  pattern-list</B></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">pattern-sequence:<BR> simple-pattern</I> ...</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">simple-pattern:<BR> <EM CLASS="italics T1.Text1">name-not-end<BR></EM></I> <CODE CLASS=T1.Text1>=&gt;<BR><I CLASS="italics T1.Text1"> bracketed-pattern<BR> binding-pattern<BR> pattern-variable</I></CODE></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">bracketed-pattern:<BR><CODE CLASS="italics T1.Text1"> ( pattern<EM CLASS="Subscript italics T1.Text1">opt   )<BR> [ patternopt   ]<BR> { patternopt   }</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">binding-pattern:<BR> pattern-variable <CODE CLASS="italics T1.Text1"> :: pattern-variable<BR> pattern-variable   = pattern-variable<BR> pattern-variable  :: pattern-variable  = pattern-variable</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">pattern-variable:<BR><CODE CLASS="italics T1.Text1"> ?  </CODE></I>name <BR><CODE CLASS=T1.Text1> ?<I CLASS=T1.Text1>  <EM CLASS=T1.Text1>constrained-name<BR></EM></I></CODE> ...</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">property-list-pattern:<BR><CODE CLASS="italics T1.Text1"> #rest  pattern-variable <BR> #key  pattern-keywords<EM CLASS="Subscript italics T1.Text1">opt <BR> #rest  pattern-variable  ,  #key  pattern-keywordsopt </EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">pattern-keywords:<BR> <CODE CLASS="italics T1.Text1">#all-keys<BR></CODE></I> <I CLASS="italics T1.Text1">pattern-keyword</I> <BR><I CLASS=T1.Text1> pattern-keyword  <CODE CLASS=T1.Text1>, pattern-keywords</CODE></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">pattern-keyword:<BR><CODE CLASS="italics T1.Text1"> ?  </CODE></I>name <I CLASS=T1.Text1>default<EM CLASS="Subscript T1.Text1">opt<BR><CODE CLASS="Subscript T1.Text1"> ?  constrained-name</CODE></EM></I> <I CLASS=T1.Text1>default<EM CLASS="Subscript T1.Text1">opt<BR><CODE CLASS="Subscript T1.Text1"> ??  </CODE></EM></I>name <I CLASS=T1.Text1>default<EM CLASS="Subscript T1.Text1">opt<BR><CODE CLASS="Subscript T1.Text1"> ??  constrained-name</CODE></EM></I> <I CLASS=T1.Text1>default<EM CLASS="Subscript T1.Text1">opt</EM></I></P>
<A NAME=HEADING118-96></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-9-2119></A><A NAME=MARKER-2-2120></A>Templates</H3>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1"><A NAME=MARKER-9-2121></A>template:<BR> template-element</I> ...</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">template-element:<BR><EM CLASS="italics T1.Text1"> name<BR> symbol<BR> number<BR> character-literal<BR> string<BR> unary-operator<BR> separator<BR> #-word<BR> one of  <CODE CLASS="italics T1.Text1">. :: =&gt;<BR> (  templateopt  )<BR> [  templateopt  ]<BR> {  templateopt  }<BR> #(  templateopt  )<BR> #[  templateopt  ]<BR> parsed-list-constant<BR> parsed-vector-constant<BR> substitution</CODE></EM></I></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">separator:<BR> one of  <CODE CLASS="italics T1.Text1">; ,<BR><EM CLASS="italics T1.Text1"> binary-operator</EM></CODE></I></P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>substitution:<BR></I> name-prefix<EM CLASS="Subscript T1.Text1">opt <CODE CLASS="Subscript T1.Text1">?</CODE></EM> name-string-or-symbol name-suffix<EM CLASS="Subscript T1.Text1">opt</EM>  <BR><CODE CLASS=T1.Text1> ??</CODE>  <EM CLASS=T1.Text1>name</EM>  separator<EM CLASS="Subscript T1.Text1">opt</EM>   <CODE CLASS=T1.Text1>...<BR> ...<BR> ?= name </CODE></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">name-prefix:<BR></I> string  <CODE CLASS=T1.Text1>##</CODE></P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">name-suffix:<BR><CODE CLASS="italics T1.Text1"> ##</CODE></I>  string </P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">name-string-or-symbol:<BR><EM CLASS="italics T1.Text1"> name<BR> string<BR> symbol</EM></I></P>
<A NAME=HEADING118-104></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-9-2122></A><A NAME=MARKER-2-2123></A>Auxiliary Rule Sets</H3>
<P CLASS=T1i.Text1italic>aux-rule-sets:<BR> aux-rule-set ...</P>
<P CLASS=T1i.Text1italic><I CLASS="italics T1i.Text1italic">aux-rule-set:<BR> <EM CLASS="italics T1i.Text1italic">symbol</EM></I> <I CLASS="italics T1i.Text1italic">aux-rules</I></P>
<P CLASS=T1i.Text1italic>aux-rules:<BR> aux-rule ...</P>
<P CLASS=T1.Text1><I CLASS="italics T1.Text1">aux-rule:<BR><CODE CLASS="italics T1.Text1"> {  pattern<EM CLASS="Subscript italics T1.Text1">opt  }  =&gt; rhs</EM></CODE></I></P>
<A NAME=HEADING118-109></A>
<H3 CLASS=H3.Heading3> <A NAME=MARKER-9-2124></A>Parsed Fragments</H3>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">parsed-definition</I>:<BR> (no external representation)</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">parsed-local-declaration</I>:<BR> (no external representation)</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">parsed-function-call</I>:<BR> (no external representation)</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">parsed-macro-call</I>:<BR> (no external representation)</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">parsed-list-constant</I>:<BR> (no external representation)</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">parsed-vector-constant</I>:<BR> (no external representation)<A NAME=MARKER-2-2125></A></P>
<A NAME="LINK-BNF_Appendix-lastpage"></A>
</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-1" CLASS=FOOTER><B CLASS=FOOTER></B>Program Structure</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-8" CLASS=FOOTER><B CLASS=FOOTER></B>Property Lists</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-13" CLASS=FOOTER><B CLASS=FOOTER></B>Fragments</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-24" CLASS=FOOTER><B CLASS=FOOTER></B>Definitions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-30" CLASS=FOOTER><B CLASS=FOOTER></B>Local Declarations</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-41" CLASS=FOOTER><B CLASS=FOOTER></B>Expressions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-56" CLASS=FOOTER><B CLASS=FOOTER></B>Statements</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-62" CLASS=FOOTER><B CLASS=FOOTER></B>Methods</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-75" CLASS=FOOTER><B CLASS=FOOTER></B>Macro Definitions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-85" CLASS=FOOTER><B CLASS=FOOTER></B>Patterns</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-96" CLASS=FOOTER><B CLASS=FOOTER></B>Templates</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-104" CLASS=FOOTER><B CLASS=FOOTER></B>Auxiliary Rule Sets</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_118.htm#HEADING118-109" CLASS=FOOTER><B CLASS=FOOTER></B>Parsed Fragments</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_119.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_117.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_116.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

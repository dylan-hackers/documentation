<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_110.htm">
<LINK REL=PREV HREF="drm_111.htm">
<LINK REL=NEXT HREF="drm_113.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Definitions</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING112></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_113.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_111.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_110.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>14 The Built-In Macros and Special Definitions</P>

</DIV>
<A NAME=HEADING112-0></A>
<A NAME="UID-Built-In_Macros-12290"></A>
<H1 CLASS=H1.Heading1> Definitions</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-1996></A>Definitions are used to declare the overall structure of a program. They often define one or more module bindings, but do not always do so. Definitions can only appear at top level in a program. Definitions do not return values.</P>
<TABLE BORDER=1><CAPTION><P CLASS=Tb.Table>Table 14-1  Definitions (continued)</P>
</CAPTION><TR VALIGN=TOP><TH><P CLASS=TbH.TblHd> Macro</P>
</TH><TH><P CLASS=TbH.TblHd> </P>
</TH><TH><P CLASS=TbH.TblHd> Description</P>
</TH><TH><P CLASS=TbH.TblHd> Page</P>
</TH></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define variable</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2000" CLASS=TbT.TblText>Defines and initializes a variable binding in the current module.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2000" CLASS=TbT.TblText>374</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define constant</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2003" CLASS=TbT.TblText>Defines and initializes a constant binding in the current module.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2003" CLASS=TbT.TblText>375</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define generic</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2007" CLASS=TbT.TblText>Defines a constant binding in the current module and initializes it to a new generic function.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2007" CLASS=TbT.TblText>376</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define method</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2010" CLASS=TbT.TblText>Adds a method to a generic function, and potentially defines a constant binding in the current module containing a new generic function.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2010" CLASS=TbT.TblText>377</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define class</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2013" CLASS=TbT.TblText>Defines a constant binding in the current module and initializes it to a new class.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2013" CLASS=TbT.TblText>378</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define module</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2016" CLASS=TbT.TblText>Defines and names a module, describing the imports and exports of the module.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2016" CLASS=TbT.TblText>380</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define library</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2020" CLASS=TbT.TblText>Defines and names a library, describing the imports and exports of the library.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2020" CLASS=TbT.TblText>386</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define domain</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2024" CLASS=TbT.TblText>Restricts the ways in which a generic function and set of types can be extended, thereby enabling additional error checking and compiler optimization.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2024" CLASS=TbT.TblText>388</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>define macro</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2027" CLASS=TbT.TblText>Defines a constant module binding containing a macro.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2027" CLASS=TbT.TblText>389</A></P>
</TD></TR></TABLE><A NAME=HEADING112-147></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-1997></A><A NAME=MARKER-9-1998></A>define variable</CODE> [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-1999></A><A NAME=MARKER-9-2000></A>Defines and initializes a variable binding in the current module.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define { <I CLASS="Parameter Code Cliche">adjective }* variable variables = init</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">adjective <CODE CLASS="BNF Parameter Cliche2">unreserved-name<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I>. The adjectives allowed are implementation dependent.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">variables</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable<EM CLASS="BNF RP.RoutineParam">bnf | ( variable-listbnf )</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">init</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define variable</CODE> defines variable bindings in the current module.</P>
<P CLASS=T1.Text1>The values returned by <I CLASS=T1.Text1>init</I> are used to initialize the bindings. The first value returned is bound to the first <I CLASS="Parameter T1.Text1">variable</I>, the second value to the second <I CLASS="Parameter T1.Text1">variable</I>, etc. The last <I CLASS="Parameter T1.Text1">variable</I> may be preceded by <CODE CLASS="Code T1.Text1">#rest</CODE>, in which case it is bound to a sequence containing all the remaining values.</P>
<P CLASS=T1.Text1>If more than one binding is defined, the <I CLASS="Parameter T1.Text1">variables</I> are enclosed in parentheses and separated by commas.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable *elapsed-time* = 0;
define variable (*whole-part*, *remainder*) = truncate(*amount*);
define variable (*first-value*, #rest *rest-values*)
                 = get-initial-orders();
</PRE>
<P CLASS=T1.Text1><A NAME=MARKER-2-2001></A>Module bindings may be specialized. This ensures that their value will always be of a given type. An attempt to initialize or assign the binding to a value not of that type will signal an error of type <CODE CLASS="Code T1.Text1">&lt;type-error&gt;</CODE>.</P>
<PRE CLASS=Cv.Code>
define variable *elapsed-time* :: &lt;integer&gt; = 0;
define variable *front-window* :: type-union (&lt;window&gt;, singleton(#f))
                 = initial-front-window();
define variable (*whole-part* :: &lt;integer&gt;, *remainder* :: &lt;real&gt;)
                 = truncate(*amount*);
</PRE>
<A NAME=HEADING112-163></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2002></A>define constant</CODE> [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2003></A>Defines and initializes a constant binding in the current module. </P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define { <I CLASS="Parameter Code Cliche">adjective }* constant constants = init</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">adjective <CODE CLASS="BNF Parameter Cliche2">unreserved-name<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I>. The adjectives allowed are implementation dependent.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">constants</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable<EM CLASS="BNF RP.RoutineParam">bnf | ( variable-listbnf )</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">init</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <A NAME=MARKER-2-2004></A><CODE CLASS="cv Cliche">define constant</CODE> defines constant bindings in the current module.</P>
<P CLASS=T1.Text1>The values returned by <I CLASS=T1.Text1>init</I> are used to initialize the constant bindings. The first value returned is bound to the first <I CLASS="Parameter T1.Text1">constant</I>, the second value to the second <I CLASS="Parameter T1.Text1">constant</I>, etc. The last <I CLASS="Parameter T1.Text1">constant</I> may be preceded by <CODE CLASS="Code T1.Text1">#rest</CODE>, in which case it is bound to a sequence containing all the remaining values.</P>
<P CLASS=T1.Text1>If more than one <I CLASS="Parameter T1.Text1">constant</I> is defined, the <I CLASS="Parameter T1.Text1">constants</I> are enclosed in parentheses and separated by commas.</P>
</DL>
<PRE CLASS=Cv.Code>
define constant $start-time = get-current-time();
define constant $pi = 3.14159;
define constant ($whole-pie, $piece-pie) = truncate($pi);
</PRE>
<P CLASS=T1.Text1><A NAME=MARKER-2-2005></A>Module constants may be specialized. This ensures that their value is of a given type. An attempt to initialize the constant to a value not of that type will signal an error of type <CODE CLASS="Code T1.Text1">&lt;type-error&gt;</CODE>.</P>
<PRE CLASS=Cv.Code>
define constant $start-time :: &lt;integer&gt; = get-current-time();
</PRE>
<P CLASS=T1.Text1>A constant binding cannot be assigned a new value. However, the object that is the value of the constant binding is not necessarily itself immutable. For example, if a constant binding contains a sequence, the elements of the sequence may be settable.</P>
<A NAME=HEADING112-178></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2006></A></CODE>define generic [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2007></A>Defines a constant binding in the current module and initializes it to a new generic function.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define { <I CLASS="Parameter Code Cliche">adjective }* generic name parameter-list [ options ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">adjective <CODE CLASS="BNF Parameter Cliche2">unreserved-name<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I>. The allowed adjectives are <CODE CLASS="Code Cliche2">sealed</CODE> and <CODE CLASS="Code Cliche2">open</CODE>. These adjectives are mutually exclusive. The default is <CODE CLASS="cv Cliche2">sealed</CODE>. Additional implementation-defined adjectives may be supported.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">name</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">parameter-list<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> (<CODE CLASS="MetaSyntax RP.RoutineParam"> [ parameters<EM CLASS="MetaSyntax RP.RoutineParam">bnf ] )  [ =&gt; <I CLASS="Parameter MetaSyntax RP.RoutineParam">values ]</I></EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">options</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">comma-property-list<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">values</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable<EM CLASS="BNF RP.RoutineParam">bnf | ( [ values-listbnf ] )</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define generic</CODE> is used to define generic functions.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-2008></A>It defines a constant module binding with the name <I CLASS="Parameter T1.Text1">name</I>, and initializes it to a new generic function described by the <I CLASS="Parameter T1.Text1">adjectives</I>, <I CLASS="Parameter T1.Text1">parameter-list</I> and <I CLASS="Parameter T1.Text1">options</I>.</P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>adjectives</I> specify whether the generic function is sealed. A complete description of generic function sealing is given in <A HREF="drm_74.htm#MARKER-9-1116" CLASS=T1.Text1>"Declaring Characteristics of Generic Functions" on page 135</A>.</P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>parameter-list</I> specifies the parameters and return values of the generic function and thereby constrains which methods may be added to it. For a complete description of these constraints, see <A HREF="drm_49.htm#MARKER-9-837" CLASS=T1.Text1>"Parameter List Congruency" on page 93</A>. A generic function parameter list may not include a next-method parameter, and its keyword parameters may include neither type specializers nor default initial values.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">options </I>are alternating keywords and values. No options are defined by the language. They may be supplied by individual implementations.</P>
<P CLASS=T1.Text1>The following example defines a generic function of two required arguments and one return value. All methods added to the generic function must also take two arguments and return one value. The first argument will always <BR>be specialized to a subtype of <CODE CLASS="Code T1.Text1">&lt;animal&gt;</CODE>, the second argument will always be specialized to a subtype of <CODE CLASS="Code T1.Text1">&lt;number&gt;</CODE>, and the return value will always <BR>be specialized to a subtype of <CODE CLASS="Code T1.Text1">&lt;number&gt;</CODE>.</P>
</DL>
<PRE CLASS=Cv.Code>
define generic cut-hair (subject :: &lt;animal&gt;, new-length :: &lt;number&gt;)
                          =&gt; (new-length :: &lt;number&gt;)
</PRE>
<P CLASS=T1.Text1>The use of the same name for a parameter and return value indicates that the parameter is returned as the value. This is only a convention;  it is not enforced by the language.</P>
<P CLASS=T1.Text1>The following example defines a generic function with one required parameter and one mandatory keyword parameter, <CODE CLASS="Code T1.Text1">strength:</CODE>. Methods added to the generic function must have one required parameter, they must accept keyword arguments, and they must permit the keyword argument <CODE CLASS="Code T1.Text1">strength:</CODE>.</P>
<PRE CLASS=Cv.Code>
define generic brew (brand :: &lt;coffee-brand&gt;, #key strength)
                             =&gt; (coffee :: &lt;coffee&gt;)
</PRE>
<A NAME=HEADING112-196></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2009></A>define method</CODE> [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2010></A>Adds a method to a generic function, and potentially defines a constant binding in the current module containing a new generic function.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define { <I CLASS="Parameter Code Cliche">adjective }* method name parameter-list <BR>    [ body ]<BR>end [ method ] [ name ]</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">adjective <CODE CLASS="BNF Parameter Cliche">unreserved-name<EM CLASS="BNF Parameter Cliche">bnf</EM></CODE></I>. The allowed adjective is <CODE CLASS="Code Cliche">sealed</CODE>. Additional implementation-defined <I CLASS="Parameter Cliche">adjectives</I> may be supported.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">name</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam"></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">parameter-list<CODE CLASS="BNF Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> parameter-list<EM CLASS=RP.RoutineParam>bnf</EM></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <A NAME=MARKER-2-2011></A><CODE CLASS=Cliche>define method</CODE> creates a method and adds it to the generic function in <I CLASS=Cliche>name</I>. If the module binding <I CLASS=Cliche>name</I>  is not already defined, it is defined as with <CODE CLASS=Cliche>define generic</CODE>. Thus,  <CODE CLASS=Cliche>define method</CODE> will create a new generic function or extend an old one, as needed.</P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>adjective</I> allows a sealing declaration to be made about the generic function to which the method is added. The effect of this adjective is described in <A HREF="drm_75.htm#MARKER-9-1131" CLASS=T1.Text1>"Abbreviations for Define Sealed Domain" on page 138</A>. </P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>parameter-list</I>  describes the parameters and return values of the method, including their number and type. The method can be called only with arguments that match the types of the parameters, and the method will always return values in the quantity and typed declared. Methods added to a generic function must have parameter lists that are congruent with the generic function's parameter list. A complete description of parameter lists is given in <A HREF="drm_49.htm#MARKER-9-782" CLASS=T1.Text1>"Parameter Lists" on page 84</A>.</P>
<P CLASS=T1.Text1>When the method is called, new local bindings are created for the parameters,  initialized to the arguments of the call. The <I CLASS="Parameter T1.Text1">body</I>  is then executed in the environment containing these bindings.</P>
</DL>
<PRE CLASS=Cv.Code>
define method tune (device :: &lt;radio&gt;) =&gt; (station :: &lt;station&gt;)
  // method body goes here
end method tune
</PRE>
<A NAME=HEADING112-209></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2012></A>define class</CODE> [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2013></A>Defines a constant binding in the current module and initializes it to a new class. </P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define { <I CLASS="Parameter Code Cliche">class-adjective }* class name ( { superclass } ,+ )<BR>   { slot-spec | init-arg-spec | inherited-slot-spec } ;*<BR>end [ class ] [ name ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">class-adjective<CODE CLASS="BNF Parameter Cliche2"> unreserved-name<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I>. The allowed adjectives are <CODE CLASS="Code Cliche2">abstract</CODE>, <CODE CLASS="Code Cliche2">concrete</CODE>, <CODE CLASS="Code Cliche2">primary</CODE>, <CODE CLASS="Code Cliche2">free</CODE>, <CODE CLASS="Code Cliche2">sealed</CODE>, and <CODE CLASS="Code Cliche2">open</CODE>. Additional implementation-dependent class-adjectives may be supported.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">name</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">superclass</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">slot-spec</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">{ <I CLASS="Parameter MetaSyntax RP.RoutineParam">slot-adjective }* [ allocation ]<BR>slot getter-name [ :: type ] [ init-expression ]<BR>{ , slot-option  }*</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">init-arg-spec<CODE CLASS="Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">[ required ] keyword symbol<EM CLASS="MetaSyntax RP.RoutineParam">bnf [ <I CLASS="Parameter MetaSyntax RP.RoutineParam">init-expression ]<BR>{ , init-arg-option  }*</I></EM></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">inherited-slot-<CODE CLASS="Code Parameter RP3.RoutineParam"></CODE></I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> inherited slot<CODE CLASS="MetaSyntax RP3.RoutineParam"> <I CLASS="Parameter MetaSyntax RP3.RoutineParam">getter-name [ init-expression ]<BR>spec { , inherited-option  }*</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">slot-adjective</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">unreserved-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE>. Supported slot-adjectives are <CODE CLASS="Code RP.RoutineParam">constant</CODE> and <CODE CLASS="Code RP.RoutineParam">sealed</CODE>. Additional implementation-dependent slot-adjectives may be supported.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">allocation</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">unreserved-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE>. Supported allocations are <CODE CLASS="Code RP.RoutineParam">instance</CODE>, <CODE CLASS="Code RP.RoutineParam">class</CODE>, <CODE CLASS="Code RP.RoutineParam">each-subclass</CODE>, and <CODE CLASS="Code RP.RoutineParam">virtual</CODE>. Additional implementation-defined allocations may be supported.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">getter-name</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">type</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">operand<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">init-expression</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam"> = expression<EM CLASS="MetaSyntax RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">slot-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> setter-option<CODE CLASS="MetaSyntax RP.RoutineParam">  |<BR><I CLASS="Parameter MetaSyntax RP.RoutineParam">init-keyword-option  |<BR>required-init-keyword-option  |<BR>init-value-option  |<BR>init-function-option  |<BR>type-option</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">init-arg-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> type-option<CODE CLASS="MetaSyntax RP.RoutineParam">  |<BR><I CLASS="Parameter MetaSyntax RP.RoutineParam">init-value-option  |<BR>init-function-option</I></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">inherited-</I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> init-value-option<CODE CLASS="MetaSyntax RP3.RoutineParam">  |<BR><I CLASS="Parameter MetaSyntax RP3.RoutineParam">option init-function-option</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">setter-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">setter: { variable-name<EM CLASS="Code RP.RoutineParam">bnf | #f }</EM></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">init-keyword-<CODE CLASS="Code Parameter RP3.RoutineParam"></CODE></I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> init-keyword:<CODE CLASS="MetaSyntax RP3.RoutineParam"> symbol<EM CLASS="MetaSyntax RP3.RoutineParam">bnf<BR><I CLASS="Parameter MetaSyntax RP3.RoutineParam">option</I></EM></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">required-init-<CODE CLASS="Code Parameter RP3.RoutineParam"></CODE></I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> required-init-keyword:<CODE CLASS="MetaSyntax RP3.RoutineParam"> symbol<EM CLASS="MetaSyntax RP3.RoutineParam">bnf<BR><I CLASS="Parameter MetaSyntax RP3.RoutineParam">keyword-option</I></EM></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">init-value-</I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> <CODE CLASS="Code RP3.RoutineParam">init-value: expression<EM CLASS="Code RP3.RoutineParam">bnf<BR><I CLASS="Parameter Code RP3.RoutineParam">option</I></EM></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">init-function-</I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> <CODE CLASS="Code RP3.RoutineParam">init-function: expression<EM CLASS="Code RP3.RoutineParam">bnf<BR><I CLASS="Parameter Code RP3.RoutineParam">option</I></EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">type-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">type: expression<EM CLASS="Code RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <A NAME=MARKER-2-2014></A><CODE CLASS="Code Cliche">define class</CODE> is used to define classes.</P>
<P CLASS=T1.Text1>It defines a constant module binding with the name <I CLASS="Parameter T1.Text1">name</I>, and initializes it to a new class.</P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>class-adjectives</I> provide sealing information about the class. Among the adjectives, <CODE CLASS="Code T1.Text1">abstract</CODE> and <CODE CLASS="Code T1.Text1">concrete</CODE> are mutually exclusive, <CODE CLASS="Code T1.Text1">primary</CODE> and <CODE CLASS="Code T1.Text1">free</CODE> are mutually exclusive, and <CODE CLASS="Code T1.Text1">sealed</CODE> and <CODE CLASS="Code T1.Text1">open</CODE> are mutually exclusive. Additional implementation-defined adjectives may be supported. See <A HREF="drm_73.htm#MARKER-9-1106" CLASS=T1.Text1>"Declaring Characteristics of Classes" on page 134</A> for a complete description of these adjectives.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">superclasses</I> are the classes from which the new class directly inherits. The rules of inheritance are described in <A HREF="drm_41.htm#MARKER-9-583" CLASS=T1.Text1>"Class Inheritance" on page 53</A> and <A HREF="drm_41.htm#MARKER-9-590" CLASS=T1.Text1>"Computing the Class Precedence List" on page 54</A>.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">init-expression</I>, <I CLASS="Parameter T1.Text1">required-init-keyword-option</I>, <I CLASS="Parameter T1.Text1">init-value-option</I>, and <I CLASS="Parameter T1.Text1">init-function-option</I> are all mutually exclusive in a single <I CLASS="Parameter T1.Text1">slot-spec</I>, <I CLASS="Parameter T1.Text1">init-arg-spec</I>, or <I CLASS="Parameter T1.Text1">inherited-slot-spec</I>.</P>
<P CLASS=T1.Text1>Each <I CLASS="Parameter T1.Text1">slot-spec</I> describes a slot specification in the class. Slot specifications are described in <A HREF="drm_42.htm#MARKER-9-610" CLASS=T1.Text1>"Slot Specifications" on page 58</A></P>
<P CLASS=T1.Text1>Each <I CLASS="Parameter T1.Text1">init-arg-spec</I> describes the handling of an initialization argument specification of the class. Initialization argument specifications are described in <A HREF="drm_43.htm#MARKER-9-680" CLASS=T1.Text1>"Initialization Argument Specifications" on page 68</A>. </P>
<P CLASS=T1.Text1>Each <I CLASS="Parameter T1.Text1">inherited-slot-spec</I> describes an inherited slot specification of the class. Inherited slot specifications are described in  <A HREF="drm_43.htm#MARKER-9-677" CLASS=T1.Text1>"Inherited Slot Specifications" on page 67</A>.</P>
</DL>
<A NAME=HEADING112-240></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2015></A>define module</CODE>   [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2016></A>Defines and names a module, describing the imports and exports of the module.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define module <I CLASS="Parameter Code Cliche">module-name<BR>    { export-clause | create-clause |use-clause  } ;*<BR></I></CODE> <CODE CLASS="Code Cliche">end [ module ] [ <I CLASS="Parameter Code Cliche">module-name ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">module-name <CODE CLASS="BNF Parameter Cliche2">name<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">export-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">export { ordinary-name<EM CLASS="Code RP.RoutineParam">bnf } ,*</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">create-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">create { ordinary-name<EM CLASS="Code RP.RoutineParam">bnf } ,*</EM></CODE> </P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">use-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">use <I CLASS="Parameter Code RP.RoutineParam">used-module { ,option }*</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">used-module</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">ordinary-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">import-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><I CLASS=RP.RoutineParam></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">exclude-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><I CLASS=RP.RoutineParam></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">prefix-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><I CLASS=RP.RoutineParam></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">rename-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">export-option</I> </P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">import-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">import: all | { { <I CLASS="Parameter Code RP.RoutineParam">variable-spec } ,* }</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">variable-spec</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">name<EM CLASS="BNF RP.RoutineParam">bnf [ =&gt; namebnf ]</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">exclude-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">exclude: { { name<EM CLASS="Code RP.RoutineParam">bnf } ,* }</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">prefix-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">prefix: string-literal<EM CLASS="Code RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">rename-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">rename: { { name<EM CLASS="Code RP.RoutineParam">bnf =&gt; namebnf } ,* }</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">export-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">export: all | { { name<EM CLASS="Code RP.RoutineParam">bnf } ,* }</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <A NAME=MARKER-2-2017></A><CODE CLASS="cv Cliche"><A NAME=MARKER-9-2018></A>define module</CODE> defines a module with the given name. It describes which modules are used by the module being defined, which bindings are imported from the used modules, and which bindings are exported by the module being defined.</P>
<P CLASS=T1.Text1>Circular use relationships among modules are not allowed. The graph of the module-uses-module relation must be directed and acyclic.</P>
<P CLASS=T1.Text1>Like other definitions, module definitions are only allowed at top level. Like all constituents, module definitions are contained in a module. The names of bindings being imported and exported in a module definition refer to bindings in the module being defined and the modules being used. These are not affected by the module that contains the module definition.</P>
<P CLASS=T1.Text1>There is no prohibition against macros that expand into module definitions.</P>
</DL>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1><I CLASS="Parameter B1.Bullet1">module-name</I> is the name of the module being defined. Note that no binding is created for this name. The namespaces of modules, libraries, and bindings are distinct. The module name is scoped within the library containing the module.
<LI CLASS=B1.Bullet1>An <I CLASS="Parameter B1.Bullet1">export-clause</I>  specifies bindings that are to be exported from the module being defined. Each name<I CLASS=B1.Bullet1>  </I>is the name of one such binding. These bindings must be defined by a definition in the module being defined. It is an error if any of the bindings were imported from other modules. It is allowed for the same name to appear more than once, since this is sometimes useful for documentation purposes.
<LI CLASS=B1.Bullet1>A <I CLASS="Parameter B1.Bullet1">create-clause</I> specifies that the named bindings are to be declared owned by and exported from the module being defined. Each name<I CLASS=B1.Bullet1> </I>is the name of a binding to declare and export. These bindings must not be defined by a definition in the module being defined, and they must not be imported from another module. They must be defined by a definition in a module that uses the module being defined. It is allowed for the same name to appear more than once, since this is sometimes useful for documentation purposes.
<LI CLASS=B1.Bullet1>Each <I CLASS="Parameter B1.Bullet1">use-clause</I> describes a set of bindings to be imported from another module. There may be multiple use clauses and there may even be multiple use clauses importing from the same module. If there are multiple use clauses importing from the same module, the bindings imported are the sum of the binding imported by each use clause. Because of renaming, it is possible for the same binding to imported multiple times under different names. This is not an error.<BR><BR>Within a use clause, the <I CLASS="Parameter B1.Bullet1">used-module</I> is the name of the module being used, and the options control which bindings are to be imported from that module, whether and how they should be renamed, and whether they should be reexported from the module being defined. Each of these options applies within the scope of the particular use clause, and does not affect the behavior of other use clauses (even if the other use clauses indicate the same module). The various options  may each appear no more than once in a single use clause. They may appear in any order.
<UL CLASS=B2.Bullet2>
<LI CLASS=B2.Bullet2>An <I CLASS="Parameter B2.Bullet2">import-option</I> describes which bindings should be imported. It can be the name <CODE CLASS="Code B2.Bullet2">all</CODE>, or a series of comma-delimited <I CLASS="Parameter B2.Bullet2">variable-specs</I> enclosed in curly braces. The default is <CODE CLASS="Code B2.Bullet2">all</CODE>, indicating that all bindings should be imported. If a series of <I CLASS="Parameter B2.Bullet2">variable-specs</I> is specified, only the indicated variables are imported.
<LI CLASS=B2.Bullet2>A <I CLASS="Parameter B2.Bullet2">variable-spec</I> is a name, or two names separated by an arrow. In the first form, the binding has the same name in the module being used and the module being defined. In the second form the binding is renamed as it is imported. The name preceding the arrow is the name of the binding in the module being used, and the name following the arrow is the name of the binding in the module being defined.
<LI CLASS=B2.Bullet2> An <I CLASS="Parameter B2.Bullet2">exclude-option</I> indicates bindings that should not be imported from the module being used. The default is the empty set. This option may only specify a nonempty set if the import option is <CODE CLASS="Code B2.Bullet2">all</CODE>.
<LI CLASS=B2.Bullet2>A <I CLASS="Parameter B2.Bullet2">prefix-option</I> indicates a prefix to be given to all binding names as they are imported. This option can be overriden for individual bindings by supplying a renaming in a rename option or import option. The default prefix option is the empty string.
<LI CLASS=B2.Bullet2>A <I CLASS="Parameter B2.Bullet2">rename-option</I> indicates how individual bindings should be renamed as they are imported. It is a comma-delimited series of entries surrounded by curly braces. Each entry is a pair of names separated by an arrow. The name preceding the arrow is the name of the binding in the module being used, and the name following the arrow is the name of the binding in the module being defined. The default for this option is the empty set.
<LI CLASS=B2.Bullet2>An <I CLASS="Parameter B2.Bullet2">export-option</I> indicates which imported bindings should be reexported from the module being defined. It can be the name <CODE CLASS="Code B2.Bullet2">all</CODE>, or a series of comma-delimited names enclosed in curly braces. Each name is the name of the binding in the module being defined as well as the name under which it will be exported. (There is no option to rename on export)  Each binding indicated must have been imported by this use clause. It is allowed for the same name  to appear more than once, as this is sometimes useful for documentation purposes. <CODE CLASS=B2.Bullet2>all </CODE>indicates that all the bindings imported by this use clause should be exported. The default value for this option is the empty set.
</UL>
</UL>
<PRE CLASS=Cv.Code>
		define module graphics
		  use dylan;
		  create draw-line,
		         erase-line,
		         invert-line,
		         skew-line,
		         frame-rect,
		         fill-rect,
		         erase-rect,
		         invert-rect;
		end module graphics;

		define module lines
		  use dylan;
		  use graphics,
			import: {draw-line,
		             erase-line,
		             invert-line,
		             skew-line};
		end module lines;
		define module rectangles
		  use dylan;
		  use graphics,
			prefix: &quot;graphics$&quot;,
			exclude: {skew-line};
		end module rectangles;
		define module dylan-gx
		  use dylan, export: all;
		  use graphics,
			rename: {skew-line =&gt; warp-line},
		      export: all;
		end module dylan-gx;
</PRE>
<P CLASS=T1.Text1>The modules created by these module declarations would have access to bindings with the following names:</P>
<PRE CLASS=Cv.Code>
graphics	
		draw-line
		erase-line
		invert-line
		skew-line
		frame-rect
		fill-rect
		erase-rect
		invert-rect
		plus all the bindings in the Dylan module
lines		
		draw-line
		erase-line
		invert-line
		skew-line
		plus all the bindings in the Dylan module
rectangles	
		graphics$draw-line
		graphics$erase-line
		graphics$invert-line
		graphics$frame-rect
		graphics$fill-rect
		graphics$erase-rect
		graphics$invert-rect
		plus all the bindings in the Dylan module
dylan-gx	
		draw-line
		erase-line
		invert-line
		warp-line
		frame-rect
		fill-rect
		erase-rect
		invert-rect
		plus all the bindings in the Dylan module
</PRE>
<P CLASS=T1.Text1>The <CODE CLASS="Code T1.Text1">lines</CODE> and <CODE CLASS="Code T1.Text1">rectangles</CODE> modules do not export any variables. They are presumably used to provide definitions for the variables created and exported by the <CODE CLASS="Code T1.Text1">graphics</CODE> modules. The difference between the <CODE CLASS="Code T1.Text1">graphics</CODE> module and the <CODE CLASS="Code T1.Text1">dylan-gx</CODE> module is that one variable is renamed, and the <CODE CLASS="Code T1.Text1">dylan-gx</CODE> module exports the variables that it imports from the <CODE CLASS=T1.Text1>dylan</CODE> module, while the <CODE CLASS="Code T1.Text1">graphics</CODE> module does not.</P>
<A NAME=HEADING112-282></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2019></A>define library</CODE>   [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2020></A><A NAME=MARKER-2-2021></A>Defines and names a library, describing the imports and exports of the library.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define library <I CLASS="Parameter Code Cliche">library-name<BR>    { export-clause | use-clause } ;*<BR>end [ library ] [ library-name ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">library-name <CODE CLASS="BNF Parameter Cliche2">name<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">use-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">use <I CLASS="Parameter Code RP.RoutineParam">used-library { ,option }*</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">export-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">export { ordinary-name<EM CLASS="Code RP.RoutineParam">bnf } ,*</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">used-library</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">ordinary-name<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">import-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><I CLASS=RP.RoutineParam></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">exclude-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><I CLASS=RP.RoutineParam></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">prefix-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><I CLASS=RP.RoutineParam></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">rename-option<CODE CLASS="MetaSyntax Parameter RP.RoutineParam"> |</CODE></I></P>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">export-option</I> </P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">import-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">import: all | { { <I CLASS="Parameter Code RP.RoutineParam">module-spec } ,* }</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">module-spec</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">name<EM CLASS="BNF RP.RoutineParam">bnf [ =&gt; namebnf ]</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">exclude-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">exclude: { { name<EM CLASS="Code RP.RoutineParam">bnf } ,* }</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">prefix-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">prefix: string-literal<EM CLASS="Code RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">rename-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">rename: { { name<EM CLASS="Code RP.RoutineParam">bnf =&gt; namebnf } ,* }</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">export-option</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam">export: all | { { name<EM CLASS="Code RP.RoutineParam">bnf } ,* }</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">define library</CODE> defines a library with the given name. It describes which libraries are used by the library being defined, which modules are imported from the used libraries, and which modules are exported by the library being defined.</P>
<P CLASS=T1.Text1>Circular use relationships among libraries are not allowed. The graph of the library-uses-library relation must be directed and acyclic.</P>
<P CLASS=T1.Text1>Like other definitions, library definitions are only allowed at top level. Like all constituents, library definitions are contained in a module. The names of modules being imported and exported by a library definition do not refer to bindings, and are not affected by the environment in which the library definition occurs.</P>
<P CLASS=T1.Text1>There is no prohibition against macros that expand into library definitions.</P>
</DL>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1><I CLASS="Parameter B1.Bullet1">library-name</I> is the name of the library being defined. Note that no binding is created for this name. The namespaces of libraries, modules, and bindings are distinct. The library name is scoped along with the other library names in the program.
<LI CLASS=B1.Bullet1>An <I CLASS="Parameter B1.Bullet1">export-clause</I> specifies modules that are to be exported from the library being defined. Each name<I CLASS=B1.Bullet1>  </I>is the name of one such module. It is an error if any of the modules were imported from other libraries. It is allowed for the same name to appear more than once, since this is sometimes useful for documentation purposes.
<LI CLASS=B1.Bullet1>Each <I CLASS="Parameter B1.Bullet1">use-clause</I> describes a set of modules to be imported from another library. There may be multiple use clauses and there may even be multiple use clauses importing from the same library. If there are multiple use clauses importing from the same library, the modules imported are the sum of the modules imported by each use clause. Because of renaming, it is possible for the same module to imported multiple times under different names. This is not an error.<BR><BR>Within a use clause, the <I CLASS="Parameter B1.Bullet1">used-library</I> is the name of the library being used. The mechanism by which this name is associated with another library is implementation defined.<BR><BR>The <I CLASS="Parameter B1.Bullet1">options</I> control which modules are to be imported from that library, whether and how they should be renamed, and whether they should be reexported from the library being defined. Each of these options applies within the scope of the particular use clause, and does not affect the behavior of other use clauses (even if the other use clauses indicate the same library). The various options  may each appear no more than once in a single use clause. They may appear in any order.
<UL CLASS=B2.Bullet2>
<LI CLASS=B2.Bullet2>An <I CLASS="Parameter B2.Bullet2">import-option</I> describes which modules should be imported. It can be the name <CODE CLASS="Code B2.Bullet2">all</CODE>, or a series of comma-delimited <I CLASS="Parameter B2.Bullet2">module-specs</I> enclosed in curly braces. The default is <CODE CLASS="Code B2.Bullet2">all</CODE>, indicating that all modules should be imported. If a series of <I CLASS="Parameter B2.Bullet2">module-specs</I> is specified, only the indicated modules are imported.
<LI CLASS=B2.Bullet2>A <I CLASS="Parameter B2.Bullet2">module-spec</I> is a name, or two names separated by an arrow. In the first form, the module has the same name in the library being used and the library being defined. In the second form the module is renamed as it is imported. The name preceding the arrow is the name of the module in the library being used, and the name following the arrow is the name of the module in the library being defined.
<LI CLASS=B2.Bullet2> An <I CLASS="Parameter B2.Bullet2">exclude-option</I> indicates modules that should not be imported from the library being used. The default is the empty set. This option may only specify a nonempty set if the import option is <CODE CLASS="Code B2.Bullet2">all</CODE>.
<LI CLASS=B2.Bullet2>A <I CLASS="Parameter B2.Bullet2">prefix-option</I> indicates a prefix to be given to all module names as they are imported. This option can be overriden for individual modules by supplying a renaming in the rename option or import option. The default prefix option is the empty string.
<LI CLASS=B2.Bullet2>A <I CLASS="Parameter B2.Bullet2">rename-option</I> indicates how individual modules should be renamed as they are imported. It is a comma-delimited series of entries surrounded by curly braces. Each entry is a pair of names separated by an arrow. The name preceding the arrow is the name of the module in the library being used, and the name following the arrow is the name of the module in the library being defined. The default for this option is the empty set.
<LI CLASS=B2.Bullet2>An <I CLASS="Parameter B2.Bullet2">export-option</I> indicates which imported modules should be reexported from the library being defined. It can be the name <CODE CLASS="Code B2.Bullet2">all</CODE>, or a series of comma-delimited names enclosed in curly braces. Each name is the name of the module in the library being defined as well as the name under which it will be exported. (There is no option to rename on export)  Each module indicated must have been imported by this use clause. It is allowed for the same name  to appear more than once, as this is sometimes useful for documentation purposes. <CODE CLASS=B2.Bullet2>all </CODE>indicates that all the modules imported by this use clause should be exported. The default value for this option is the empty set.
</UL>
</UL>
<A NAME=HEADING112-313></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2022></A>define sealed domain</CODE>  [Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-2023></A><A NAME=MARKER-9-2024></A>Restricts the ways in which a generic function and set of types can be extended, thereby enabling additional error checking and compiler optimization.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define sealed domain</CODE> <I CLASS="Parameter Cliche">generic-function<CODE CLASS="MetaSyntax Parameter Cliche">  ( { type } ,* )</CODE></I></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">generic-function<CODE CLASS="BNF Parameter Cliche"> variable-name<EM CLASS="BNF Parameter Cliche">bnf<BR></EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">type</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define sealed domain</CODE> seals the specified <I CLASS="Parameter Cliche">generic-function</I> over the domain indicated by the <I CLASS="Parameter Cliche">types</I>. For a complete description of the rules governing <CODE CLASS="cv Cliche">define sealed domain</CODE> and the implications of a <CODE CLASS="cv Cliche">define sealed domain</CODE> definition, see <A HREF="drm_75.htm#MARKER-9-1123" CLASS=Cliche>"Define Sealed Domain" on page 135</A>.</P>
</DL>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1><I CLASS="Parameter B1.Bullet1">generic-function</I> is the name of a module binding containing an explicitly defined generic function.
<LI CLASS=B1.Bullet1>Each <I CLASS="Parameter B1.Bullet1">type</I> is an expression, the value of which must be a type. The number of <I CLASS="Parameter B1.Bullet1">types  </I>must be the same as the number of required arguments accepted by <I CLASS="Parameter B1.Bullet1">generic-function.</I>
</UL>
<A NAME=HEADING112-321></A>
<H3 CLASS=H4.Heading4> <A NAME=MARKER-2-2025></A>define macro [Special Definition]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-2026></A><A NAME=MARKER-9-2027></A>Defines a constant module binding containing a macro.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">define macro <I CLASS="Parameter Code Cliche">macro-definition</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">macro-definition<CODE CLASS="BNF Parameter Cliche2"> macro-definition<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> See <A HREF="drm_75.htm#MARKER-9-1143" CLASS=Cliche>Chapter 10, "Macros,"</A> for a complete description of the macro system.</P>
<P CLASS=T1.Text1>Note that <CODE CLASS="Code T1.Text1">define macro</CODE> is not a defining macro but a special definition. It is not named by a binding, and so it cannot being excluded or renamed using module operations.<A NAME=MARKER-2-2028></A></P>
</DL>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-147" CLASS=FOOTER><B CLASS=FOOTER></B>define variable [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-163" CLASS=FOOTER><B CLASS=FOOTER></B>define constant [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-178" CLASS=FOOTER><B CLASS=FOOTER></B>define generic [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-196" CLASS=FOOTER><B CLASS=FOOTER></B>define method [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-209" CLASS=FOOTER><B CLASS=FOOTER></B>define class [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-240" CLASS=FOOTER><B CLASS=FOOTER></B>define module   [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-282" CLASS=FOOTER><B CLASS=FOOTER></B>define library   [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-313" CLASS=FOOTER><B CLASS=FOOTER></B>define sealed domain  [Definition]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_112.htm#HEADING112-321" CLASS=FOOTER><B CLASS=FOOTER></B>define macro [Special Definition]</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_113.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_111.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_110.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

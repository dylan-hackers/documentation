<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_47.htm">
<LINK REL=PREV HREF="drm_48.htm">
<LINK REL=NEXT HREF="drm_50.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Parameter Lists</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING49></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_50.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_48.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_47.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>6 Functions</P>

</DIV>
<A NAME=HEADING49-0></A>
<A NAME=UID-Functions-2254></A>
<H1 CLASS=H1.Heading1> <A NAME=MARKER-9-782></A>Parameter Lists</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-783></A>The parameter list of a function describes the number and types of the arguments that the function accepts, and the number and types of the values it returns.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-784></A>The parameter list of a generic function is used to define the overall protocol of the generic function. It constrains the methods that may be added to the generic function, through the parameter list congruency rules described on <A HREF="#MARKER-9-837" CLASS=T1.Text1>page 93</A>. It may also specify that calls to the generic function may contain any keyword arguments.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-785></A>The parameter list of a method specifies the types of arguments to which the method is applicable, and declares local bindings to which those arguments will be bound during the execution of the body of the method. It may also declare the return value types of the method.</P>
<A NAME=HEADING49-4></A>
<A NAME=UID-Functions-4841></A>
<H2 CLASS=H2.Heading2> Kinds of Parameters</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-786></A>Dylan parameter lists support <B CLASS=T1.Text1><A NAME=MARKER-2-787></A>required parameters</B>, <B CLASS=T1.Text1><A NAME=MARKER-2-788></A>rest parameters</B>, <B CLASS=T1.Text1><A NAME=MARKER-2-789></A>keyword parameters</B>, and sometimes a <B CLASS=T1.Text1><A NAME=MARKER-2-790></A>next-method parameter</B>. They also may include <B CLASS=T1.Text1><A NAME=MARKER-2-791></A>return value declarations</B>.</P>
<P CLASS=T1.Text1>The complete syntax of parameter lists is given in <A HREF="drm_118.htm#MARKER-9-2115" CLASS=T1.Text1>"Methods" on page 426</A>.</P>
<P CLASS=T1.Text1>Required parameters correspond to arguments that must be supplied when a function is called. The arguments are supplied in a fixed order and must appear before any other arguments.</P>
<P CLASS=T1.Text1>Each required parameter may be a name or a name <B CLASS=T1.Text1><A NAME=MARKER-2-792></A>specialized</B> by a type. Specifying a type declares that supplied argument must be a general instance of that type.</P>
<P CLASS=T1.Text1>A rest parameter allows a function to accept an unlimited number of arguments.<A REL=FOOTNOTE HREF="#FOOTNOTE-3" CLASS=T1.Text1>[3]</A>  After the required arguments of a function have been supplied, any additional arguments are collected in a sequence, which is passed as the value of the rest parameter. <A NAME=MARKER-2-793></A>This sequence may be immutable, and it may or may not be freshly allocated. The types of rest parameters cannot be declared.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-794></A><A NAME=MARKER-2-795></A>Keyword parameters correspond to arguments that are optional and may be given in any order. Symbols are used among the arguments to guide matching of arguments to parameters. These symbols are usually written in keyword syntax and so they are known as keywords. Keyword arguments can only be supplied after all required arguments are supplied. Keyword parameters may <BR><BR><BR><BR>be specialized, restricting which values may be supplied for them. Keyword parameters may also be given default values to be used when the caller does not supply a value.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-796></A><A NAME=MARKER-2-797></A>Required parameters come first in the parameter list, followed by the rest parameter, if any, and then the keyword parameters, if any. A rest parameter is indicated by the token <CODE CLASS=T1.Text1>#rest</CODE> followed by the name of the parameter. Keyword parameters are indicated by the token <CODE CLASS=T1.Text1>#key</CODE> followed by the keyword parameter specifiers, optionally followed by the token <CODE CLASS=T1.Text1>#all-keys</CODE>.</P>
<P CLASS=T1.Text1>If <CODE CLASS=T1.Text1>#rest</CODE> and <CODE CLASS=T1.Text1>#key</CODE> are used in the same parameter list, <CODE CLASS=T1.Text1>#rest</CODE> must come first. The rest parameter will be bound to a sequence containing all the keyword arguments and their corresponding values.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-798></A>A next-method parameter is indicated by the token <CODE CLASS=T1.Text1>#next</CODE>, followed by the name of the parameter. It is not normally necessary to specify a next-method parameter explicitly. If a next-method parameter is not specified by the programmer, <CODE CLASS=T1.Text1>define method</CODE> inserts one with the name <CODE CLASS=T1.Text1>next-method</CODE>. If an explicit next-method parameter is given, it must come after the required parameters and before the rest and keyword parameters. Details of using next-method are given in <A HREF="drm_50.htm#MARKER-9-858" CLASS=T1.Text1>"Calling Less Specific Methods" on page 98</A>.<A NAME=MARKER-2-799></A></P>
<A NAME=HEADING49-14></A>
<A NAME=UID-Functions-2273></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-9-800></A>Kinds of Parameter Lists</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-801></A>Each function (generic function or method) has an argument passing protocol specified by its parameter list. The argument passing protocol for a method must be compatible with the argument passing protocol of any generic function to which it is added, as described in <A HREF="#MARKER-9-837" CLASS=T1.Text1>"Parameter List Congruency" on page 93</A>.</P>
<P CLASS=T1.Text1>The argument passing protocol of a function can be described in one of the following ways:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>A function is said to <B CLASS=B1.Bullet1><A NAME=MARKER-2-802></A>require a fixed number of arguments</B> if its parameter list does not specify either <CODE CLASS=B1.Bullet1><A NAME=MARKER-2-803></A>#rest</CODE> or <CODE CLASS=B1.Bullet1><A NAME=MARKER-2-804></A>#key</CODE>.
<LI CLASS=B1.Bullet1>A function is said to <B CLASS=B1.Bullet1><A NAME=MARKER-2-805></A>accept keyword arguments</B> if its parameter list specifies <CODE CLASS=B1.Bullet1>#key</CODE>. The parameter list could also specify <CODE CLASS=B1.Bullet1>#rest</CODE> if it is a method, but not if it is a generic function.
<LI CLASS=B1.Bullet1>A function is said to <B CLASS=B1.Bullet1><A NAME=MARKER-2-806></A>accept all keyword arguments</B> if its parameter list specifies <CODE CLASS=B1.Bullet1>#all-keys</CODE> in addition to <CODE CLASS="Code B1.Bullet1">#key</CODE>.
<LI CLASS=B1.Bullet1>A function is said to <B CLASS=B1.Bullet1><A NAME=MARKER-2-807></A>accept a variable number of arguments</B> if its parameter list specifies <CODE CLASS=B1.Bullet1>#rest</CODE> but does not specify <CODE CLASS=B1.Bullet1>#key</CODE>. (Note: If the parameter list specifies <CODE CLASS="cv B1.Bullet1">#key</CODE> in addition to <CODE CLASS="cv B1.Bullet1">#rest</CODE> it is not said to accept a variable number of arguments.)
<P CLASS=T1.Text1>A method that accepts keyword arguments is said to <B CLASS=T1.Text1><A NAME=MARKER-2-808></A>recognize</B> the keywords mentioned in its parameter list. (A method may, of course, mention them in the parameter list and then ignore their values. It is still said to recognize them.)  It is possible for a method to accept keyword arguments in general but not recognize any particular keywords; it does this by specifying <CODE CLASS="Code T1.Text1">#key</CODE> without any subsequent keyword parameters.</P>
<P CLASS=T1.Text1>If a generic function that accepts keyword arguments mentions any specific keyword arguments in its parameter list, these are the <B CLASS=T1.Text1><A NAME=MARKER-2-809></A>mandatory keywords</B> of the generic function. Every method added to the generic function must recognize these keywords.</P>
<P CLASS=T1.Text1>A function may accept all keyword arguments by specifying <CODE CLASS="cv T1.Text1">#all-keys</CODE> in its parameter list.<A NAME=MARKER-2-810></A><A NAME=MARKER-2-811></A><A NAME=MARKER-2-812></A></P>
<P CLASS=T1.Text1>When a function that accepts keyword arguments is called, it is said to <B CLASS=T1.Text1><A NAME=MARKER-2-813></A>permit</B> a keyword argument in the call if one of the following is true:</P>
<LI CLASS=B1.Bullet1>The function is a method that recognizes the keyword.
<LI CLASS=B1.Bullet1>The function is a generic function and the keyword is recognized by any of the applicable methods of the call.
<LI CLASS=B1.Bullet1>The function accepts all keyword arguments.
<LI CLASS=B1.Bullet1>The function is a generic function and any of the applicable methods of the call accepts all keyword arguments.
<P CLASS=T1.Text1><A NAME=MARKER-2-814></A>If a function that accepts keyword arguments is called, it will signal an error if called with a keyword argument that it does not permit, or if the arguments following the required arguments are not keyword/value pairs. This is true even if the function specifies <CODE CLASS="cv T1.Text1">#rest</CODE>.</P>
<P CLASS=T1.Text1>If a method is called via a generic function or via next-method (rather than directly), the method itself does not check whether it received any keyword arguments it does not permit, nor does it check that the arguments following the required arguments are keyword/value pairs. This check is performed by the generic function or next-method, and is made relative to the call as a whole, not relative to an individual method or the methods remaining to be called.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-815></A>A call to a function may supply the same keyword argument more than once. When this is done, the leftmost keyword/value pair is used.<A NAME=MARKER-2-816></A></P>
</UL>
<A NAME=HEADING49-32></A>
<A NAME=UID-Functions-2288></A>
<H2 CLASS=H2.Heading2> Specializing Required Parameters</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-817></A>When you define a generic function or method, you may specify the types of the arguments appropriate for the generic function or method. This is called <B CLASS=T1.Text1><A NAME=MARKER-2-818></A>specializing</B> the generic function or method, or specializing the parameters of the generic function or method.</P>
<P CLASS=T1.Text1>The following example defines a method specialized on <CODE CLASS="cv T1.Text1">&lt;number&gt;</CODE>. The method will be applicable when <CODE CLASS=T1.Text1>double</CODE> is called on a general instance of <CODE CLASS=T1.Text1>&lt;number&gt;</CODE>.</P>
<PRE CLASS=Cv.Code>
define method double (thing :: &lt;number&gt;)
  thing + thing;
end method;
</PRE>
<P CLASS=T1.Text1>Specialization constrains the values that may be passed as the value of a parameter. The function can be called only with arguments that are instances of the specializers of the corresponding parameters.</P>
<P CLASS=T1.Text1>Specialization is useful in three way:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>It makes the intent of the program clear. It indicates to the compiler and to anyone reading the code that an error is signaled if an argument is not of the specializer type.
<LI CLASS=B1.Bullet1>It allows the compiler to perform additional optimizations.
<LI CLASS=B1.Bullet1><A NAME=MARKER-2-819></A>It is used to control method dispatch. By defining methods on the same generic function with different specializers, you can define behavior applicable to different sets of types. A generic function chooses among its methods on the basis of the methods' specializers. The generic function chooses the method whose specializers most closely match the types of the arguments.
<P CLASS=T1.Text1>Syntactically, specializers are operands. These operands are executed once when the function is created. They are not re-executed each time the function is called. The value of the operand must be a type.</P>
<P CLASS=T1.Text1>It is most common for specializers to be constant module bindings or calls to a built-in type constructor such as <CODE CLASS="Code T1.Text1">singleton</CODE>, <CODE CLASS="Code T1.Text1">limited</CODE>, or <CODE CLASS="Code T1.Text1">type-union</CODE>.</P>
<P CLASS=T1.Text1>There is a convenient syntax for singleton specializers, which is equivalent to explicitly calling <CODE CLASS="Code T1.Text1">singleton</CODE> in the current lexical scope.<A NAME=MARKER-2-820></A></P>
</UL>
<A NAME=HEADING49-44></A>
<A NAME=UID-Functions-2308></A>
<H2 CLASS=H2.Heading2> Keyword Parameters</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-821></A>The syntax of a keyword parameter is:</P>
<PRE CLASS=Cv.Code>
<CODE CLASS="MetaSyntax Cv.Code">[ <I CLASS="Parameter MetaSyntax Cv.Code">keyword  ] name [ :: operand ] [ = expression ]</I></CODE>
</PRE>
<P CLASS=T1.Text1>If <I CLASS="Parameter T1.Text1">keyword</I> is not supplied, then <I CLASS=T1.Text1>name</I> is used to indicate both the keyword and the name of the parameter. If the <I CLASS="Parameter T1.Text1">keyword</I> and <I CLASS="Parameter T1.Text1">name</I> are given independently, the <I CLASS="Parameter T1.Text1">keyword</I> is used when calling the method, and the <I CLASS="Parameter T1.Text1">name</I> is used as the name of the parameter inside the body of the method. </P>
<P CLASS=T1.Text1><A NAME=MARKER-2-822></A>The <I CLASS="Parameter T1.Text1">expression</I> supplies a default value for the parameter. It is used when the method is called and the keyword is not supplied. It is executed each time the method is called and the corresponding keyword argument is not supplied. If no <I CLASS="Parameter T1.Text1">expression</I> is specified, the parameter corresponding to an unsupplied keyword argument is initialized to <A NAME=MARKER-2-823></A><CODE CLASS="cv T1.Text1">#f</CODE>. The <I CLASS="Parameter T1.Text1">expression</I> is executed in a scope that includes all the preceding parameters, including required parameters, the rest parameter (if any), the preceding keyword parameters, and the next-method parameter (if any).</P>
<P CLASS=T1.Text1>In the following example, all three keyword parameters have default values, and all three use the same name for the keyword and the parameter.</P>
<PRE CLASS=Cv.Code>
define method percolate (#key brand = #&quot;maxwell-house&quot;,
                              cups = 4,
                              strength = #&quot;strong&quot;)
  make-coffee (brand, cups, strength);
end method;
</PRE>
<P CLASS=T1.Text1>The caller can choose which keyword arguments to supply and what order to supply them in:</P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>percolate (brand: #&quot;ja<A NAME=MARKER-2-824></A>va&quot;, cups: 10);<BR>percolate (strength: #&quot;strong&quot;,<BR>           brand: #&quot;st<A NAME=MARKER-2-825></A>arbucks&quot;,<BR>            cups: 1);</CODE></P>
<P CLASS=T1.Text1>The following method has two keyword parameters. In each, the name of the keyword and the name of the parameter is specified separately. The first keyword parameter has a default value, the second does not.</P>
<PRE CLASS=Cv.Code>
define method layout (widget, #key position: the-pos = 0,
                                   size: the-size)
  let the-sibling = sibling (widget);
  unless (the-pos = position (the-sibling))
    align-objects (widget, the-sibling, the-pos, the-size);
end method;
layout(my-widget, position: 100, size: 500);
layout(my-widget, size: query-user-for-size() );
</PRE>
<P CLASS=T1.Text1><A NAME=MARKER-2-826></A>The keyword parameter syntax in which the keyword name and parameter name are given separately is needed to allow keyword names such as <CODE CLASS="Code T1.Text1">position:</CODE> without forcing the method to use <CODE CLASS="Code T1.Text1">position</CODE> as a local binding. If a method uses <CODE CLASS="Code T1.Text1">position</CODE> as a local binding, it cannot access the module binding <CODE CLASS="Code T1.Text1">position</CODE> (which contains a function). The local binding would shadow the module binding.</P>
<P CLASS=T1.Text1>All required arguments must be supplied before any keyword arguments can be supplied. The following call to <CODE CLASS="cv T1.Text1">layout</CODE> will signal an error:</P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>layout(position: 100, size: 500);</CODE></P>
<A NAME=HEADING49-59></A>
<H3 CLASS=H3.Heading3> Types for Keyword Parameters</H3>
<P CLASS=T1.Text1><A NAME=MARKER-2-827></A>When a type is indicated for a keyword parameter in a method, it is the same as establishing a type for a local binding. Specifically, the types of any keyword parameters are not used for method dispatch. Keyword parameter types are not allowed in generic function definitions, and do not figure into parameter list congruency.</P>
<P CLASS=T1.Text1>The following two method definitions are equivalent:</P>
<PRE CLASS=Cv.Code>
method (#key X :: &lt;integer&gt;)
  ... X ...
end method;
method (#key X)
  let X :: &lt;integer&gt; = X;
  ... X ...
end method;
</PRE>
<P CLASS=T1.Text1>If a keyword parameter is given a type, if <CODE CLASS="Code T1.Text1">#f</CODE> is not an instance of that type, and if the keyword parameter is not given a default value, then the keyword parameter is essentially required. An error of type <CODE CLASS="Code T1.Text1">&lt;type-error&gt;</CODE> will be signaled if a call to the method does not include the keyword.</P>
<P CLASS=T1.Text1>The following examples include keyword parameters that include both a type and a default value.</P>
<PRE CLASS=Cv.Code>
define method find-happiness (#key hint :: &lt;symbol&gt; =  #&quot;here&quot;)
  ...
end method find-happiness;
</PRE>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>define method find-food (#key hint :: &lt;restaurant&gt; <BR>                              =  lookup-default-restaurant())<BR>  ...<BR>end method find-food;<A NAME=MARKER-2-828></A><A NAME=MARKER-2-829></A></CODE></P>
<A NAME=HEADING49-68></A>
<A NAME=UID-Functions-2324></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-830></A>Return Value Declarations<A NAME=MARKER-2-831></A></H2>
<P CLASS=T1.Text1>Parameter lists may include value declarations. Value declarations come at the end of the parameter list and are separated from the parameters by <CODE CLASS="cv T1.Text1">=&gt;</CODE>. For each return value, a value declaration can specify a name and an operand or just a name<I CLASS=T1.Text1> </I>if the type is <CODE CLASS="Code T1.Text1">&lt;object&gt;</CODE>. The complete syntax of value declarations is given in <A HREF="drm_118.htm#MARKER-9-2115" CLASS=T1.Text1>"Methods" on page 426</A>.</P>
<P CLASS=T1.Text1>The result of executing the operand at the time the function is defined is a type, called a <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-832></A>value type</B>. The name<I CLASS=T1.Text1> </I> never comes into scope. It is included for documentation and for syntactic consistency with parameters. It is valid for the same name to be used in both one parameter and one value declaration in the same parameter list; this is useful as documentation that a function returns one of its arguments.</P>
<P CLASS=T1.Text1>The last value declaration can be preceded by <CODE CLASS="Code T1.Text1">#rest</CODE> to indicate a variable number of return values. A value declaration preceded by <CODE CLASS="Code T1.Text1">#rest</CODE> is called a <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-833></A>rest value declaration</B>. A value declaration not preceded by <CODE CLASS="Code T1.Text1">#rest</CODE> is called a <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-834></A>required value declaration</B>. The value type in a rest value declaration is the type of each one of the remaining individual values, not the type of a conceptual sequence of multiple values.</P>
<P CLASS=T1.Text1>If a parameter-list does not contain a value declaration, it defaults to <CODE CLASS="Code T1.Text1">=&gt; #rest x :: &lt;object&gt;</CODE>. That is, the function can return any number of values of any type.</P>
<P CLASS=T1.Text1>A function will always return the number and types of values declared in its parameter-list. More precisely:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>Each value returned by a function must be an instance of the corresponding value type, or else an error of type <CODE CLASS=B1.Bullet1>&lt;type-error&gt;</CODE> will be signaled.
<LI CLASS=B1.Bullet1><A NAME=MARKER-2-835></A>If fewer values are returned by the function's body (or by the applicable method if the function is a generic function) than the number of required value declarations in the function's parameter-list, the missing values are defaulted to <CODE CLASS=B1.Bullet1>#f</CODE> and returned. If <CODE CLASS=B1.Bullet1>#f</CODE> is not an instance of the corresponding value type, an error of type <CODE CLASS=B1.Bullet1>&lt;type-error&gt;</CODE> is signaled.
<LI CLASS=B1.Bullet1>If a function does not have a rest value declaration, and more values are returned by the function's body (or by the applicable method if the function is a generic function) than the number of required value declarations in the function's parameter-list, the extra values are discarded and not returned.
<P CLASS=T1.Text1><A NAME=MARKER-2-836></A>Because of the parameter list congruency rules for value declarations (see <A HREF="#MARKER-9-837" CLASS=T1.Text1>"Parameter List Congruency" on page 93</A>) the values returned by a generic function do not have to be checked by the generic function. The check inside a method will always be enough to verify that the return values are valid for the generic function.</P>
</UL>
<PRE CLASS=Cv.Code>
define method average (x :: &lt;number&gt;, y :: &lt;number&gt;)
 =&gt; mean :: &lt;number&gt;;
 (x + y) / 2
end method;
<CODE CLASS="cv Cv.Code">// Returning multiple values
define method limits (center :: &lt;number&gt;, radius :: &lt;number&gt;)
 =&gt; (min :: &lt;number&gt;, max :: &lt;number&gt;);
 values(center - radius, center + radius);
end method;</CODE>
<CODE CLASS="cv Cv.Code">// The same name used both as a parameter and as a value type
define method rotate (image :: &lt;picture&gt;, rotation-angle :: &lt;number&gt;)

 =&gt; (image :: &lt;picture&gt;);
 ...
end method;</CODE>
// This method can return one, two, or three values
define method family (kid :: &lt;person&gt;)
  =&gt; (kid :: &lt;person&gt;, #rest parents);
  let mom = kid.mother;
  let dad = kid.father;
  case
    mom &amp; dad =&gt; values(kid, mom, dad);
    mom =&gt; values(kid, mom);
    dad =&gt; values(kid, dad);
    otherwise =&gt; kid;
  end case
end method family;
</PRE>
<P CLASS=T1.Text1>Note that the following example does not declare a return value of type <CODE CLASS="cv T1.Text1">&lt;number&gt;</CODE>. It declares a return value of type <CODE CLASS="cv T1.Text1">&lt;object&gt;</CODE>. To specify a type, both the name and the type must be specified. If only one is given, it is taken as the name.<CODE CLASS="cv T1.Text1"></CODE></P>
<PRE CLASS=Cv.Code>
define method average (x :: &lt;number&gt;, y :: &lt;number&gt;)
 =&gt; avg :: &lt;number&gt;;
 truncate/((x + y), 2);
end method;
</PRE>
<A NAME=HEADING49-84></A>
<A NAME=UID-Functions-2334></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-9-837></A>Parameter List Congruency</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-838></A>For any given generic function, the generic function and all methods for that function must have <B CLASS=T1.Text1>congruent parameter lists</B>. Two parameter lists are congruent if they satisfy the following conditions:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>They have the same number of required arguments.
<LI CLASS=B1.Bullet1>Each of the method's parameter specializers is a subtype of the corresponding parameter specializer of the generic function.
<LI CLASS=B1.Bullet1>One of the following is true:
<UL CLASS=B2.Bullet2>
<LI CLASS=B2.Bullet2>both accept keyword arguments
<LI CLASS=B2.Bullet2>both accept a variable number of arguments
<LI CLASS=B2.Bullet2>both require a fixed number of arguments
</UL>
<LI CLASS=B1.Bullet1>If the generic function accepts keyword arguments, each method must recognize the mandatory keywords of the generic function.
<P CLASS=T1.Text1>In addition, the value declarations must be congruent, defined as follows:</P>
<LI CLASS=B1.Bullet1>If the generic function's parameter list does not contain a rest value declaration, then
<UL CLASS=B2.Bullet2>
<LI CLASS=B2.Bullet2>The method's parameter list must not contain a rest value declaration.
<LI CLASS=B2.Bullet2>The two parameter lists must contain the same number of required value declarations.
<LI CLASS=B2.Bullet2>Each value type in the method's parameter list must be a subtype of the corresponding value type in the generic function's parameter list.
</UL>
<LI CLASS=B1.Bullet1><A NAME=MARKER-2-839></A>If the generic function's parameter list contains a rest value declaration, then:
<UL CLASS=B2.Bullet2>
<LI CLASS=B2.Bullet2>The method's parameter list is permitted, but not required, to contain a rest value declaration.
<LI CLASS=B2.Bullet2>The method's parameter list must contain at least as many required value declarations as the generic function's parameter list.
<LI CLASS=B2.Bullet2>Each value type in the method's parameter list must be a subtype of the corresponding value type in the generic function's parameter list. If the method has a rest value type, it corresponds to the generic function's rest value type. If the method has more required value types than the generic function, the extra ones must be subtypes of the generic function's rest value type.<A NAME=MARKER-2-840></A>
</UL>
</UL>
<A NAME=HEADING49-102></A>
<A NAME=UID-Functions-3556></A>
<H2 CLASS=H2.Heading2> Parameter Lists of Implicitly Defined Generic Functions</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-841></A>As a general principle, the parameter list of an implicitly defined generic function will impose as few constraints as possible on the methods that may be added. If a more constrained generic function definition is desired, an explicit definition should be used.</P>
<P CLASS=T1.Text1>The parameter list of an implicitly defined generic function is determined by its method definitions. These method definitions include both methods defined using <CODE CLASS="Code T1.Text1">define method</CODE> and slot getter and setter methods defined using <CODE CLASS="Code T1.Text1">define class</CODE>.</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>The implicitly defined generic function has the same basic argument pattern as the methods. Either they must all require a fixed number of arguments, they must all accept a variable number of arguments, or they must all accept keyword arguments. A set of methods that includes members with more than one of these patterns violates the parameter list congruency requirement, and is an error.
<LI CLASS=B1.Bullet1>The implicitly defined generic function has the same number of required arguments as the methods. A set of methods that includes members with different numbers of required arguments violates the parameter list congruency requirement, and is an error.
<LI CLASS=B1.Bullet1>Each required argument of the implicitly defined generic function is specialized on <CODE CLASS="Code B1.Bullet1">&lt;object&gt;</CODE>.
<LI CLASS=B1.Bullet1>If the implicitly defined generic function accepts keyword arguments, it does not have any mandatory keywords, nor does it accept all keyword arguments.
<LI CLASS=B1.Bullet1>The implicitly defined generic function has a rest value declaration of <CODE CLASS="Code B1.Bullet1">&lt;object&gt;</CODE>.<A NAME=MARKER-2-842></A><A NAME=MARKER-2-843></A>
</UL>

</DIV>

<DIV CLASS=WM-DIV-FOOTNOTES>

<DIV CLASS=WM-DIV-FOOTNOTES>
<HR>

<A NAME=FOOTNOTE-3>[3] </A>
 In practice, an implementation may place a reasonable limit on the number of arguments that may be passed to any function.

</DIV>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-4" CLASS=FOOTER><B CLASS=FOOTER></B>Kinds of Parameters</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-14" CLASS=FOOTER><B CLASS=FOOTER></B>Kinds of Parameter Lists</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-32" CLASS=FOOTER><B CLASS=FOOTER></B>Specializing Required Parameters</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-44" CLASS=FOOTER><B CLASS=FOOTER></B>Keyword Parameters</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-59" CLASS=FOOTER><B CLASS=FOOTER></B>Types for Keyword Parameters</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-68" CLASS=FOOTER><B CLASS=FOOTER></B>Return Value Declarations</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-84" CLASS=FOOTER><B CLASS=FOOTER></B>Parameter List Congruency</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_49.htm#HEADING49-102" CLASS=FOOTER><B CLASS=FOOTER></B>Parameter Lists of Implicitly Defined Generic Functions</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_50.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_48.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_47.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_110.htm">
<LINK REL=PREV HREF="drm_113.htm">
<LINK REL=NEXT HREF="drm_115.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Statements</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING114></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_115.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_113.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_110.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>14 The Built-In Macros and Special Definitions</P>

</DIV>
<A NAME=HEADING114-0></A>
<A NAME="UID-Built-In_Macros-2670"></A>
<H1 CLASS=H1.Heading1> Statements</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-2041></A>Statements are used to implement a variety of program constructs.</P>
<P CLASS=T1.Text1>Many statements include an optional implicit body, which may contain one or more constituents separated by semicolons. When an implicit body is executed, the expressions in the implicit body are executed in order (left to right). The values of the implicit body are the values of the last expression. If the optional implicit body is not present or contains no expressions, the return value is <CODE CLASS="cv T1.Text1">#f</CODE>.</P>
<TABLE BORDER=1><CAPTION><P CLASS=Tb.Table>Table 14-3  Statements (continued)</P>
</CAPTION><TR VALIGN=TOP><TH><P CLASS=TbH.TblHd> Macro</P>
</TH><TH><P CLASS=TbH.TblHd> </P>
</TH><TH><P CLASS=TbH.TblHd> Description</P>
</TH><TH><P CLASS=TbH.TblHd> Page</P>
</TH></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>if</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2044" CLASS=TbT.TblText>Executes an implicit body if the value of a test is true or an alternate if the test is false.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2044" CLASS=TbT.TblText>395</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>unless</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2046" CLASS=TbT.TblText>Executes an implicit body unless the value of a test is true.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2046" CLASS=TbT.TblText>396</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>case</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2048" CLASS=TbT.TblText>Executes a number of tests until one is true, and then executes an implicit body associated with the true test.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2048" CLASS=TbT.TblText>397</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>select</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2050" CLASS=TbT.TblText>Compares a target object to a series of potential matches, and executes an implicit body associated with the first match found.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2050" CLASS=TbT.TblText>398</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>while</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2054" CLASS=TbT.TblText>Repeatedly executes a body until a test expression is false.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2054" CLASS=TbT.TblText>399</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>until</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2056" CLASS=TbT.TblText>Repeatedly executes a body until a test expression is true.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2056" CLASS=TbT.TblText>400</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>for</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2058" CLASS=TbT.TblText>Performs general iteration over a body, updating bindings and performing end tests on each iteration.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2058" CLASS=TbT.TblText>400</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>begin</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2061" CLASS=TbT.TblText>Executes expressions in a body, in order.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2061" CLASS=TbT.TblText>404</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>block</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2063" CLASS=TbT.TblText>Executes a body with several options for nonstandard flow of control.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2063" CLASS=TbT.TblText>404</A></P>
</TD></TR><TR VALIGN=TOP><TD><P CLASS=TbT.TblText> <CODE CLASS=TbT.TblText>method</CODE></P>
</TD><TD><P CLASS=TbT.TblText> </P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2066" CLASS=TbT.TblText>Creates and returns a method.</A></P>
</TD><TD><P CLASS=TbT.TblText> <A HREF="#MARKER-9-2066" CLASS=TbT.TblText>408</A></P>
</TD></TR></TABLE><A NAME=HEADING114-162></A>
<A NAME="UID-Built-In_Macros-10641"></A>
<H2 CLASS=H2.Heading2> Conditionals</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-2042></A>The following statements are used to perform conditional execution.</P>
<A NAME=HEADING114-164></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2043></A>if</CODE> [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><CODE CLASS=SD.ShortDescription><A NAME=MARKER-9-2044></A></CODE>Executes an implicit body if the value of a test is true or an alternate if the test is false.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">if ( <I CLASS="Parameter Code Cliche">test ) [consequent ]<BR> { elseif ( elseif-test  ) [elseif-consequent ] }*<BR> [ else [alternate  ] ]<BR>end [ if ]</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">test <CODE CLASS="BNF Parameter Cliche">expression<EM CLASS="BNF Parameter Cliche">bnf</EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">consequent</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">elseif-test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">elseif-consequent<CODE CLASS="BNF Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> body<EM CLASS=RP.RoutineParam>bnf</EM></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">alternate</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">if</CODE> executes one or more expressions, executing and returning the values of a body following the first test that returns true.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">test</I> is the first expression to be executed. If its value is true, <CODE CLASS="Code T1.Text1">if</CODE> executes and returns the values of the <I CLASS="Parameter T1.Text1">consequent</I>. If the value of <I CLASS="Parameter T1.Text1">test</I> is false, <CODE CLASS="Code T1.Text1">if</CODE> proceeds with the optional elseif-tests and alternate.</P>
<P CLASS=T1.Text1>First the elseif clauses are tried in order. The first <I CLASS="Parameter T1.Text1">elseif-test</I> is executed. If its value is true, the corresponding <I CLASS="Parameter T1.Text1">elseif-consequent</I> is executed and its values are returned as the value of the <CODE CLASS="Code T1.Text1">if</CODE> statement. If its value is false, the next <I CLASS="Parameter T1.Text1">elseif-test</I> is tried. This continues until a true <I CLASS="Parameter T1.Text1">elseif-test</I> is found, or until there are no more elseif clauses.</P>
<P CLASS=T1.Text1>If the <I CLASS="Parameter T1.Text1">test</I> and all the <I CLASS="Parameter T1.Text1">elseif-tests</I> are false, the <I CLASS="Parameter T1.Text1">alternate</I> is executed and its values are returned as the value of the <CODE CLASS="Code T1.Text1">if</CODE> statement. If there is no alternate, the <CODE CLASS="Code T1.Text1">if</CODE> statement returns <CODE CLASS="Code T1.Text1">#f</CODE>.</P>
</DL>
<PRE CLASS=Cv.Code>
if ( x &lt; 0 )
  - x;
end if;
if ( heads?(flip(coin)) )
  start(black);
else
  start(white);
end if
if (player1.money &lt;= 0)
  end-game(player1)
elseif (player2.money &lt;= 0)
  end-game(player2)
else
  move(player1);
  move(player2);
end if
if ( camel.humps = 1 )
  &quot;dromedary&quot;
elseif ( camel.humps = 2 )
  &quot;bactrian&quot;
else
  &quot;not a camel&quot;
end if;
</PRE>
<A NAME=HEADING114-181></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2045></A>unless</CODE> [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2046></A>Executes an implicit body unless the value of a test is true.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">unless ( <I CLASS="Parameter Code Cliche">test  )<BR><B CLASS="Parameter Code Cliche">   [  body  ]<BR>end [ unless ]</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">test</I> <CODE CLASS="BNF Cliche2">expression<EM CLASS="BNF Cliche2">bnf</EM></CODE></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">unless</CODE> executes <I CLASS="Parameter Cliche">test</I>. If the value of <I CLASS="Parameter Cliche">test</I> is false, then the <I CLASS="Parameter Cliche">body</I> is executed and its values are returned by <CODE CLASS="Code Cliche">unless</CODE>. If the value of <I CLASS="Parameter Cliche">test</I> is true, the <I CLASS="Parameter Cliche">body</I> is not executed and <CODE CLASS="Code Cliche">unless</CODE> returns <CODE CLASS="cv Cliche">#f</CODE>.</P>
<P CLASS=T1.Text1>If there are no expressions in the <I CLASS="Parameter T1.Text1">body</I>, then <CODE CLASS="Code T1.Text1">#f</CODE> is returned.</P>
</DL>
<PRE CLASS=Cv.Code>
unless(detect-gas? (nose))
    light(match)
end unless
</PRE>
<A NAME=HEADING114-190></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2047></A>case              </CODE> [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2048></A>Executes a number of tests until one is true, and then executes an implicit body associated with the true test.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">case<BR> { <I CLASS="Parameter Code Cliche">test  =&gt; consequent } *<BR> [ otherwise [ =&gt; ] alternate  ]<BR>end [ case ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">test <CODE CLASS="BNF Parameter Cliche2">expression<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">consequent</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">[ constituents<EM CLASS="MetaSyntax RP.RoutineParam">bnf ] ;</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">alternate</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">[ constituents<EM CLASS="MetaSyntax RP.RoutineParam">bnf ] ;</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS=Cliche>case</CODE> executes the <I CLASS=Cliche>test</I> in order, until it reaches a test that returns true. When it reaches a test that returns true, it executes the corresponding <I CLASS="Parameter Cliche">consequent</I> and returns its values. Subsequent tests are not executed. If the corresponding <I CLASS="Parameter Cliche">consequent</I> is empty, the first value of the successful test is returned.</P>
<P CLASS=T1.Text1>As a special case, the name <CODE CLASS=T1.Text1>otherwise</CODE> may appear as a <I CLASS=T1.Text1>test</I>. This <I CLASS=T1.Text1>test</I> always succeeds if there is no preceding successful <I CLASS=T1.Text1>test</I>.</P>
<P CLASS=T1.Text1>If no <I CLASS=T1.Text1>test</I> is true, then <CODE CLASS=T1.Text1>case</CODE> returns <CODE CLASS=T1.Text1>#f</CODE>.</P>
</DL>
<PRE CLASS=Cv.Code>
case
   player1.money &lt;= 0
     =&gt; end-game(player1);
   player2.money &lt;= 0
     =&gt; end-game(player2);
   otherwise
     =&gt; move(player1);
        move(player2);
end case;
</PRE>
<A NAME=HEADING114-201></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2049></A>select</CODE> [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2050></A>Compares a target object to a series of potential matches, and executes an implicit body associated with the first match found.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">select ( <I CLASS="Parameter Code Cliche">target  [ by test  ] )<BR> { matches  =&gt; consequent }*<BR> [ otherwise [ =&gt; ] alternate ] <BR>end [ select ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">target <CODE CLASS="BNF Parameter Cliche2">expression<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">matches</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">{ expression<EM CLASS="MetaSyntax RP.RoutineParam">bnf } ,<B CLASS="MetaSyntax RP.RoutineParam">+ | ( { expressionbnf } ,+ )</B></EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">consequent</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">[ constituents<EM CLASS="MetaSyntax RP.RoutineParam">bnf ] ;</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">alternate</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">[ constituents<EM CLASS="MetaSyntax RP.RoutineParam">bnf ] ; </EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">select</CODE> generates a target object and then compares it to a series of potential matches, in order. If it finds a match, it executes the corresponding <I CLASS="Parameter Cliche">consequent</I> and returns the values of the <I CLASS="Parameter Cliche">consequent</I>. If no match is found, an error is signaled.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">target</I> is executed to produce the match object.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">test</I>, if supplied, is a function used to compare the target object to the potential matches. The default <I CLASS="Parameter T1.Text1">test</I> is <CODE CLASS="Code T1.Text1">==</CODE>.</P>
<P CLASS=T1.Text1>One at a time, each <I CLASS="Parameter T1.Text1">match</I> is executed and its value compared to <I CLASS="Parameter T1.Text1">target</I>, in order. If a match is found, the corresponding <I CLASS="Parameter T1.Text1">consequent</I> is executed and its values are returned. If the corresponding <I CLASS="Parameter T1.Text1">consequent</I> is empty, <CODE CLASS="Code T1.Text1">#f</CODE> is returned.</P>
<P CLASS=T1.Text1>Once a match is found, subsequent <I CLASS="Parameter T1.Text1">matches</I>  and the corresponding bodies are not executed.</P>
<P CLASS=T1.Text1>As a special case, the name <CODE CLASS="Code T1.Text1">otherwise</CODE> may appear instead of a <I CLASS="Parameter T1.Text1">matches</I>. This will be considered a match if no other match is found.</P>
<P CLASS=T1.Text1>If there is no matching clause, an error is signaled. Because an <CODE CLASS="Code T1.Text1">otherwise</CODE> clause matches when no other clause matches, a <CODE CLASS="Code T1.Text1">select</CODE> form that includes an <CODE CLASS="Code T1.Text1">otherwise</CODE> clause will never signal an error for failure to match.</P>
<P CLASS=T1.Text1>Since testing stops when the first match is found, it is irrelevant whether the test function would also have returned true if called on later matches of the same clause or on matches of later clauses.</P>
</DL>
<PRE CLASS=Cv.Code>
select ( career-choice(student) )
   art:, music:, drama:
     =&gt; &quot;Don't quit your day job&quot;;
   literature:, history:, linguistics:
     =&gt; &quot;That really is fascinating&quot;;
   science:, math:, engineering:
     =&gt; &quot;Say, can you fix my VCR?&quot;;
   otherwise =&gt; &quot;I wish you luck&quot;;
end select;
select ( my-object by instance? )
  &lt;window&gt;, &lt;view&gt;, &lt;rectangle&gt; =&gt; &quot;a graphical object&quot;;
  &lt;number&gt;, &lt;string&gt;, &lt;list&gt; =&gt; &quot;a computational object&quot;;
  otherwise =&gt; &quot;I don't know&quot;;
end select<A NAME=MARKER-2-2051></A>
</PRE>
<A NAME=HEADING114-220></A>
<A NAME="UID-Built-In_Macros-1898"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-2052></A>Iteration Constructs</H2>
<A NAME=HEADING114-221></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2053></A>while</CODE>  [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2054></A>Repeatedly executes a body until a test expression is false.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">while ( <I CLASS="Parameter Code Cliche">test  )<BR></I></CODE>    <CODE CLASS="MetaSyntax Cliche">[ <I CLASS="Parameter MetaSyntax Cliche">body</I></CODE>  <CODE CLASS="MetaSyntax Cliche">]<BR>end</CODE> <CODE CLASS="MetaSyntax Cliche">[ while ]<BR> =><B CLASS="MetaSyntax Cliche"> #f</B></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">test</I> <CODE CLASS="BNF Cliche2">expression<EM CLASS="BNF Cliche2">bnf</EM></CODE></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">#f</CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">while</CODE> loops over <I CLASS="Parameter Cliche">body</I> until <I CLASS="Parameter Cliche">test</I> returns false.</P>
<P CLASS=T1.Text1>Each pass through the loop begins by executing <I CLASS=T1.Text1>test</I>. If <I CLASS=T1.Text1>test</I> returns a true value, the expressions in the <I CLASS=T1.Text1>body</I> <I CLASS=T1.Text1> </I>are executed and the looping continues. If <I CLASS=T1.Text1>test</I> returns false, the loop terminates and <CODE CLASS="Code T1.Text1">while</CODE> returns <CODE CLASS="Code T1.Text1">#f</CODE>.</P>
</DL>
<A NAME=HEADING114-229></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2055></A>until</CODE>  <CODE CLASS=H4.Heading4> (</CODE> test  <CODE CLASS=H4.Heading4>) </CODE> [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2056></A>Repeatedly executes a body until a test expression is true.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">until ( <I CLASS="Parameter Code Cliche">test )<BR></I></CODE>    <CODE CLASS="MetaSyntax Cliche">[ <I CLASS="Parameter MetaSyntax Cliche">body</I></CODE>  <CODE CLASS="MetaSyntax Cliche">]<BR>end</CODE> [<CODE CLASS="Code Cliche">until</CODE>]  <BR>=> <B CLASS=Cliche> <CODE CLASS="Code Cliche">#f</CODE></B></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">test</I> <CODE CLASS="BNF Cliche">expression<EM CLASS="BNF Cliche">bnf</EM></CODE></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">#f</CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">until</CODE> loops over <I CLASS="Parameter Cliche">body</I> until <I CLASS="Parameter Cliche">test</I> returns true.</P>
<P CLASS=T1.Text1>Each pass through the loop begins by executing <I CLASS=T1.Text1>test</I>. If <I CLASS=T1.Text1>test</I> returns false, the expressions in the <I CLASS=T1.Text1>body</I> <I CLASS=T1.Text1> </I>are executed and the looping continues. If <I CLASS=T1.Text1>test</I> returns true, the loop terminates and <CODE CLASS="Code T1.Text1">until</CODE> returns <CODE CLASS="Code T1.Text1">#f</CODE>.</P>
</DL>
<A NAME=HEADING114-237></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2057></A>for</CODE> [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2058></A>Performs general iteration over a body, updating bindings and performing end tests on each iteration.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">for ( { <I CLASS="Parameter Code Cliche">for-clause } ,*  |<BR>     { { for-clause  ,}* end-clause  })<BR> [ loop-body  ]<BR> [ finally [ result-body  ] ]<BR>end [ for ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">for-clause explicit-step-clause<CODE CLASS="MetaSyntax Parameter Cliche2">  |</CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam"></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> collection-clause<CODE CLASS="MetaSyntax RP.RoutineParam">  |</CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam"></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> numeric-clause<CODE CLASS="MetaSyntax RP.RoutineParam"> </CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">end-test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">loop-body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">result-body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">explicit-step-<CODE CLASS="BNF Parameter RP3.RoutineParam"></CODE></I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> variable<EM CLASS=RP3.RoutineParam>bnf<CODE CLASS="MetaSyntax RP3.RoutineParam"> = <I CLASS="Parameter MetaSyntax RP3.RoutineParam">init-value  then next-value<BR>clause</I></CODE></EM></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">collection-</I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> <CODE CLASS="BNF RP3.RoutineParam">variable<EM CLASS="BNF RP3.RoutineParam">bnf in <I CLASS="Parameter BNF RP3.RoutineParam">collection<BR>clause</I></EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">numeric-clause<CODE CLASS="BNF Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> variable<EM CLASS=RP.RoutineParam>bnf<CODE CLASS="MetaSyntax RP.RoutineParam"> from <I CLASS="Parameter MetaSyntax RP.RoutineParam">start<BR>                [ { to | above  |below } bound  ]<BR>                [ by increment  ]</I></CODE></EM></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">end-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="MetaSyntax RP.RoutineParam">{ until: | while: } <I CLASS="Parameter MetaSyntax RP.RoutineParam">end-test</I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">init-value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">next-value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">start</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf<I CLASS="Parameter BNF RP.RoutineParam"></I></EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">bound</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">increment</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">for</CODE> iterates over <I CLASS="Parameter Cliche">loop-body</I>, creating and updating iteration bindings on each iteration according to the <I CLASS="Parameter Cliche">for-clauses</I>. Iteration ends when one of the <I CLASS="Parameter Cliche">for-clauses</I> is exhausted, or when the optional <I CLASS="Parameter Cliche">end-test</I> is satisfied.</P>
<P CLASS=T1.Text1>Each <I CLASS=T1.Text1>for-clause<CODE CLASS=T1.Text1> </CODE></I>controls one iteration binding. The optional <I CLASS=T1.Text1>end-test</I> does not control any iteration bindings.</P>
<P CLASS=T1.Text1>There are three kinds of for-clauses: <I CLASS="Parameter T1.Text1">explicit-step-clauses</I>, <I CLASS="Parameter T1.Text1">collection-clauses</I>, and <I CLASS="Parameter T1.Text1">numeric-clauses</I>:  An <I CLASS="Parameter T1.Text1">explicit-step-clause</I> creates bindings for the results of executing an expression. A <I CLASS="Parameter T1.Text1">collection-clause</I> creates bindings for successive elements of a collection. A <I CLASS="Parameter T1.Text1">numeric-clause</I> creates bindings for a series of numbers.</P>
<P CLASS=T1.Text1>Execution of a <CODE CLASS="Code T1.Text1">for</CODE> statement proceeds through the following steps:</P>
<P CLASS="N/.NList=1">Execute the expressions that are executed just once, in left to right order as they appear in the <CODE CLASS="Code N/.NList=1">for</CODE> statement. These expressions include the types of all the bindings, and the expressions <I CLASS="Parameter N/.NList=1">init-value</I>, <I CLASS="Parameter N/.NList=1">collection</I>, <I CLASS="Parameter N/.NList=1">start</I>, <I CLASS="Parameter N/.NList=1">bound</I>, and <I CLASS="Parameter N/.NList=1">increment</I>. If the value of <I CLASS="Parameter N/.NList=1">collection</I> is not a collection, an error is signaled. The default value for <I CLASS="Parameter N/.NList=1">increment</I> is <CODE CLASS="cv N/.NList=1">1</CODE>.</P>
<P CLASS=N.NList>Create the iteration bindings of explicit step and numeric clauses.</P>
<UL CLASS=B2.Bullet2>
<LI CLASS=B2.Bullet2> For each explicit step clause, create the binding for the value of <I CLASS="Parameter B2.Bullet2">init-value</I>. If the binding is typed and the value<I CLASS=B2.Bullet2> </I>is not of the specified type, signal an error. 
<LI CLASS=B2.Bullet2>For each numeric clause, create the binding for the value of <I CLASS="Parameter B2.Bullet2">start</I>. If the binding is typed and the value<I CLASS=B2.Bullet2> </I>is not of the specified type, signal an error. 
<P CLASS=N.NList>Check numeric and collection clauses for exhaustion. If a clause is exhausted, go to step 9.</P>
<LI CLASS=B2.Bullet2>A collection clause is exhausted if its collection has no next element.
<LI CLASS=B2.Bullet2>A numeric clause is exhausted if a <I CLASS="Parameter B2.Bullet2">bound </I>is supplied and the value of the clause is no longer in bounds. If <CODE CLASS="Code B2.Bullet2">above</CODE> is specified, the clause will be in bounds as long as the value is greater than the <I CLASS="Parameter B2.Bullet2">bounds</I>. If <CODE CLASS="Code B2.Bullet2">below</CODE> is specified, the clause will be in bounds as long as the value is less than the <I CLASS="Parameter B2.Bullet2">bounds</I>. If <CODE CLASS="Code B2.Bullet2">to</CODE> is specified with a positive or zero <I CLASS="Parameter B2.Bullet2">increment</I>, the clause will be in bounds as long as it is less than or equal to the  <I CLASS="Parameter B2.Bullet2">bounds</I>. If <CODE CLASS="Code B2.Bullet2">to</CODE> is specified with a negative <I CLASS="Parameter B2.Bullet2">increment</I>, the clause will be in bounds as long as it is greater than or equal to the <I CLASS="Parameter B2.Bullet2">bounds</I>.
<P CLASS=N.NList>For each collection clause<I CLASS=N.NList> </I>create the iteration binding for the next element of the collection for that clause. Fresh bindings are created each time through the loop (i.e., the binding is not assigned the new value). If the binding is typed and the value<I CLASS=N.NList> </I>is not of the specified type, signal an error. </P>
<P CLASS=N.NList>If <I CLASS="Parameter N.NList">end-test</I> is supplied, execute it.  If the value of <I CLASS="Parameter N.NList">end-test </I>is false and the symbol is <CODE CLASS="Code N.NList">while:</CODE>, go to step 9. If the value of <I CLASS="Parameter N.NList">end-test </I>is true and the symbol is <CODE CLASS="Code N.NList">until:</CODE>, go to step 9.</P>
<P CLASS=N.NList>Execute the expressions in the <I CLASS="Parameter N.NList">body</I> in order. The expressions in the <I CLASS="Parameter N.NList">body</I> are used to produce side-effects.</P>
<P CLASS=N.NList>Obtain the next values for explicit step and numeric clauses. Values are obtained in left to right order, in the environment produced by step 6.</P>
<LI CLASS=B2.Bullet2>For each explicit step clause, execute <I CLASS=B2.Bullet2>next-value</I>.
<LI CLASS=B2.Bullet2> For each numeric clause, add the <I CLASS="Parameter B2.Bullet2">increment</I> to the current value of the binding, using <CODE CLASS="cv B2.Bullet2">+</CODE>.
<P CLASS=N.NList>Create the iteration bindings of explicit step and numeric clauses for the values obtained in step 7. For each clause, if a binding type<I CLASS=N.NList> </I>is supplied and the next value for that clause<I CLASS=N.NList> </I>is not of the specified type, signal an error. Fresh bindings are created each time through the loop (i.e., the binding is not assigned the new value). After the bindings have been created, go to step 3.</P>
<P CLASS=N.NList>Execute the expressions in the <I CLASS="Parameter N.NList">result-body</I>  in order. Bindings created in step 2 and 8  are visible during the execution of <I CLASS="Parameter N.NList">result-body</I>, but bindings created in step 4 ( the iteration bindings of collection clauses) are not visible during the execution of <I CLASS="Parameter N.NList">result-body</I>. The values of the last expression in the <I CLASS="Parameter N.NList">result-body</I>  are returned as the values of the <CODE CLASS="Code N.NList">for</CODE> statement. If there are no expressions in the <I CLASS="Parameter N.NList">result-body</I>, <CODE CLASS="Code N.NList">for</CODE> returns <CODE CLASS="Code N.NList">#f</CODE>.</P>
</UL>
</DL>
<PRE CLASS=Cv.Code>
for ( thing = first-thing then next(thing),
      until: done?(thing) )
  do-some(thing)
end;
for (j :: &lt;integer&gt; from 0 to height)
  for (i :: &lt;integer&gt; from 0 to width)
   erase(i,j);
   plot (i,j);
  end for;
end for;
for (city in olympic-cities,
     year from start-year by 4)
  schedule-olympic-game(city, year)
  finally notify(press);
           sell(tickets);
end;
for (i from 0 below 100,
     zombies from 0 below 100,
     normals from 100 above 0 by -1)
   population[i] := zombies + normals
end;<A NAME=MARKER-2-2059></A>
</PRE>
<A NAME=HEADING114-280></A>
<A NAME="UID-Built-In_Macros-13876"></A>
<H2 CLASS=H2.Heading2> Other Statement Macros</H2>
<A NAME=HEADING114-281></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><B CLASS=H4.Heading4><A NAME=MARKER-2-2060></A>begin</B></CODE> <B CLASS=H4.Heading4>[Statement]</B></H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2061></A>Executes expressions in a body, in order.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">begin [ <I CLASS="Parameter Code Cliche">body  ] end</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">body</I> <CODE CLASS="BNF Cliche">body<EM CLASS="BNF Cliche">bnf</EM></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Begin executes the expressions in a body, in order. The values of the last expression are returned. If there are no expressions in the body, <CODE CLASS="Code Cliche">#f</CODE> is returned.</P>
</DL>
<A NAME=HEADING114-287></A>
<H3 CLASS=H4.Heading4> <CODE CLASS=H4.Heading4><A NAME=MARKER-2-2062></A>block</CODE>  [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2063></A>Executes a body with several options for nonstandard flow of control. </P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">block ( [ <I CLASS="Parameter Code Cliche">exit-variable ] )<BR> [ block-body ]<BR> [ afterwards [ afterwards-clause ] ]<BR> [ cleanup [ cleanup-clause  ] ]<BR> { exception exception-clause  }*<BR>end [ block ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">exit-variable <CODE CLASS="BNF Parameter Cliche2">variable-name<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">block-body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">afterwards-<CODE CLASS="BNF Parameter RP3.RoutineParam"></CODE></I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> body<EM CLASS=RP3.RoutineParam>bnf<BR><I CLASS="Parameter RP3.RoutineParam">clause</I></EM></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">cleanup-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">exception-clause</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="Code RP.RoutineParam"> ( [ <I CLASS="Parameter Code RP.RoutineParam">name  :: ] type  { ,exception-options  }*)<BR>    [ body<EM CLASS="Parameter Code RP.RoutineParam">bnf ]</EM></I></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">name</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">variable-name<EM CLASS="BNF RP.RoutineParam">bnf<I CLASS="Parameter BNF RP.RoutineParam"></I></EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">type</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">expression<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">exception-options<BR><CODE CLASS="MetaSyntax Parameter RP.RoutineParam">{ test: expression<EM CLASS="MetaSyntax Parameter RP.RoutineParam">bnf } | { init-arguments: expressionbnf }</EM></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <A NAME=MARKER-2-2064></A><CODE CLASS="Code Cliche">block</CODE> executes the expressions in the <I CLASS="Parameter Cliche">block-body</I> in order, and then executes the optional <I CLASS="Parameter Cliche">afterwards-clause</I> and <I CLASS="Parameter Cliche">cleanup-clause</I>. Unless there is a nonlocal exit, block returns the values of the <I CLASS="Parameter Cliche">block-body</I>, or <CODE CLASS="cv Cliche">#f</CODE> if there is no <I CLASS="Parameter Cliche">block-body</I>.</P>
<P CLASS=T1.Text1>If <I CLASS="Parameter T1.Text1">exit-variable</I> is provided, it is bound to an exit procedure (an object of type <CODE CLASS="cv T1.Text1">&lt;function&gt;</CODE>) that is valid during the execution of the block body and the clauses. At any point in time before the last clause returns, the exit procedure can be called. Calling the exit procedure has the effect of immediately terminating the execution of the block, and returning as values the arguments to the exit procedure.</P>
<P CLASS=T1.Text1>The body of the <I CLASS="Parameter T1.Text1">afterwards-clause</I>, if provided, is executed after the <I CLASS="Parameter T1.Text1">block-body</I>. The values produced by the <I CLASS="Parameter T1.Text1">afterwards-clause</I> are ignored. This is useful when you want to execute an expression for side-effect after the <I CLASS="Parameter T1.Text1">block-body</I> has executed, but still want to return the values of the last expression in the <I CLASS="Parameter T1.Text1">block-body</I>. </P>
<P CLASS=T1.Text1>The body of the <I CLASS="Parameter T1.Text1">cleanup-clause</I>, if provided, is executed after the <I CLASS="Parameter T1.Text1">block-body</I> and <I CLASS="Parameter T1.Text1">afterwards-clause</I>. Its values are also ignored. The cleanup clause differs from the afterwards clause in that its body is guaranteed to be executed, even if the execution of the block is interrupted by a nonlocal exit. There is no such guarantee for the <I CLASS="Parameter T1.Text1">afterwards-clause</I>.</P>
<P CLASS=T1.Text1>For example, the following code fragment ensures that files are closed even in the case of an error causing a nonlocal exit from the block body:</P>
</DL>
<PRE CLASS=Cv.Code>
block (return)
  open-files();
  if (something-wrong)
    return(&quot;didn't work&quot;);
  end if;
  compute-with-files()
cleanup
  close-files();
end block
</PRE>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">exception-clauses</I>, if supplied, install exception handlers during the execution of the <I CLASS="Parameter T1.Text1">block-body</I>, <I CLASS="Parameter T1.Text1">afterwards-clause</I>, and <I CLASS="Parameter T1.Text1">cleanup-clause</I>. If one of these handlers is invoked, it never declines but immediately takes a nonlocal exit to the beginning of the block, executes the expressions in its body and returns the values of the last expression or <CODE CLASS="Code T1.Text1">#f</CODE> if the body is empty. Note that when the expressions in an exception body are executed, all handlers established by the <CODE CLASS="cv T1.Text1">block</CODE> are no longer active. Note also that the cleanup clause of the block will be executed before the expressions of the handler body are executed.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">type</I> and <I CLASS="Parameter T1.Text1">exception-options</I> are as for <CODE CLASS="Code T1.Text1">let handler</CODE>. If present, <I CLASS="Parameter T1.Text1">name</I> is bound to the condition during the execution of the handler's body.</P>
<P CLASS=T1.Text1>The exception clauses are checked in the order in which they appear. That is, the first handler will take precedence over the second, the second over the third, etc.</P>
<P CLASS=T1.Text1>The following is a trivial use of an exception clause.</P>
<PRE CLASS=Cv.Code>
block ()
  open-files();
  compute-with-files()
exception (&lt;error&gt;) 
  &quot;didn't work&quot;;
cleanup
  close-files();
end block
</PRE>
<A NAME=HEADING114-310></A>
<H4 CLASS=H5.Heading5> Dynamic Extent of Block Features</H4>
<P CLASS=T1.Text1>A block installs features that are active for different portions of the execution of the block.</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>During the execution of the block body and the afterwards clause the exit procedure, exception clauses, and cleanup clauses are active.
<LI CLASS=B1.Bullet1>During the execution of the cleanup clause, the exit procedure and exception clauses are active.
<LI CLASS=B1.Bullet1>During the execution of a handler installed by an exception clause, the exit procedure is active.
</UL>
<A NAME=HEADING114-315></A>
<H4 CLASS=H5.Heading5> Intervening Cleanup Clauses</H4>
<P CLASS=T1.Text1>When an exit procedure is called, it initiates a nonlocal exit out of its establishing block. Before the nonlocal exit can complete, however, the cleanup clauses of intervening blocks (blocks that have been entered, but not exited, since the establishing block was entered) must be executed, beginning with the most recently entered intervening block. Once the cleanup clauses of an intervening block have been executed, it is an error to invoke the exit procedure established by that block. The cleanup clauses of the establishing block are executed last. At that point, further invocation of the exit procedure becomes invalid, and the establishing block returns with the values that were passed to the exit procedure.</P>
<P CLASS=T1.Text1>Note that a block statement may also be exited due to the execution of a handler clause. Before the exception clause is executed, intervening cleanup clauses are executed as described above (including any clause for the establishing block.)  The exit procedure may be invoked during execution of exception clauses, in which case the argument values are immediately returned from the block (the cleanup clause already having been executed).</P>
<P CLASS=T1.Text1>During the process of executing the cleanup clauses of the intervening blocks, any valid exit procedure may be invoked and may interrupt the current nonlocal exit.</P>
<P CLASS=T1.Text1>All exception clauses are executed in the same dynamic environment. None of the handlers established in the block are visible during the execution of one of the handlers. This can be thought of as parallel installation of the handlers.</P>
<A NAME=HEADING114-320></A>
<H4 CLASS=H5.Heading5> Restrictions on the use of exit procedures</H4>
<P CLASS=T1.Text1>The exit procedure is a first-class object. Specifically, it can be passed as an argument to functions, stored in data structures, and so on. Its use is not restricted to the lexical body of the block in which it was established. However, invocation of the exit procedure is valid only during the execution of the establishing block. It is an error to invoke an exit procedure after its establishing block has returned, or after execution of the establishing block has been terminated by a nonlocal exit.</P>
<P CLASS=T1.Text1>In the following example, the <CODE CLASS="cv T1.Text1">block</CODE> establishes an exit procedure in the binding <CODE CLASS="cv T1.Text1">bar</CODE>. The <CODE CLASS="cv T1.Text1">block</CODE> returns a method containing a call to <CODE CLASS="cv T1.Text1">bar</CODE>, and the  method is stored in the binding <CODE CLASS="cv T1.Text1">foo</CODE>. Calling <CODE CLASS="cv T1.Text1">foo</CODE> is an error because it is no longer valid to invoke <CODE CLASS="cv T1.Text1">bar</CODE> after its establishing <CODE CLASS="cv T1.Text1">block</CODE> has returned.</P>
<PRE CLASS=Cv.Code>
define constant foo =
  block (bar)
     method (n) bar(n) end;
  end block;
foo(5)
  {error or other undefined consequences}
</PRE>
<A NAME=HEADING114-324></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-2065></A>method</CODE> [Statement]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-2066></A>Creates and returns a method.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Macro Call:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">method <I CLASS="Parameter Code Cliche">parameter-list  [ body ] end [ method ]</I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">parameter-list <CODE CLASS="BNF Parameter Cliche2">parameter-list<EM CLASS="BNF Parameter Cliche2">bnf</EM></CODE></I></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">body</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <CODE CLASS="BNF RP.RoutineParam">body<EM CLASS="BNF RP.RoutineParam">bnf</EM></CODE></P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> An instance of <CODE CLASS="cv Cliche">&lt;method&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">method</CODE> creates and returns a method specified by the <I CLASS="Parameter Cliche">parameter-list</I> and <I CLASS="Parameter Cliche">body</I>. For a complete description of methods, see <A HREF="drm_48.htm#MARKER-9-762" CLASS=Cliche>"Methods" on page 80</A>.<A NAME=MARKER-2-2067></A></P>
</DL>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-162" CLASS=FOOTER><B CLASS=FOOTER></B>Conditionals</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-164" CLASS=FOOTER><B CLASS=FOOTER></B>if [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-181" CLASS=FOOTER><B CLASS=FOOTER></B>unless [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-190" CLASS=FOOTER><B CLASS=FOOTER></B>case               [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-201" CLASS=FOOTER><B CLASS=FOOTER></B>select [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-220" CLASS=FOOTER><B CLASS=FOOTER></B>Iteration Constructs</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-221" CLASS=FOOTER><B CLASS=FOOTER></B>while  [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-229" CLASS=FOOTER><B CLASS=FOOTER></B>until   ( test  )  [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-237" CLASS=FOOTER><B CLASS=FOOTER></B>for [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-280" CLASS=FOOTER><B CLASS=FOOTER></B>Other Statement Macros</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-281" CLASS=FOOTER><B CLASS=FOOTER></B>begin [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-287" CLASS=FOOTER><B CLASS=FOOTER></B>block  [Statement]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-310" CLASS=FOOTER><B CLASS=FOOTER></B>Dynamic Extent of Block Features</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-315" CLASS=FOOTER><B CLASS=FOOTER></B>Intervening Cleanup Clauses</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-320" CLASS=FOOTER><B CLASS=FOOTER></B>Restrictions on the use of exit procedures</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_114.htm#HEADING114-324" CLASS=FOOTER><B CLASS=FOOTER></B>method [Statement]</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_115.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_113.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_110.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_96.htm">
<LINK REL=PREV HREF="drm_97.htm">
<LINK REL=NEXT HREF="drm_99.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Constructing and Initializing Instances</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING98></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_99.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_97.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_96.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>12 The Built-In Functions</P>

</DIV>
<A NAME=HEADING98-0></A>
<A NAME="UID-Built-In_Functions-20431"></A>
<H1 CLASS=H1.Heading1> Constructing and Initializing Instances</H1>
<P CLASS=T0.Text0>Instance creation and initialization is performed by the open generic functions <CODE CLASS="cv T0.Text0">make</CODE> and <CODE CLASS="cv T0.Text0">initialize</CODE>. For an overview of the allocation and initialization process, see <A HREF="drm_43.htm#MARKER-9-658" CLASS=T0.Text0>"Instance Creation and Initialization" beginning on page 64</A>.</P>
<A NAME=HEADING98-2></A>
<A NAME="UID-Built-In_Functions-32090"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-1536></A><A NAME=MARKER-2-1537></A>General Constructor</H2>
<A NAME=HEADING98-3></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1538></A>make</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1539></A>Returns a general instance of its first argument.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">make <I CLASS="Parameter cv Cliche">type #rest supplied-init-args #key #all-keys => instance</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">type</I> An instance of <CODE CLASS="cv Cliche">&lt;type&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">supplied-init-args</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Keyword/argument pairs.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">instance</I> An <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>, which must be a general instance of <I CLASS="Parameter Cliche">type</I>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns an instance of <I CLASS=Cliche>type</I>, with characteristics specified by keyword arguments.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">instance</I> returned is guaranteed to be a general instance of <I CLASS=T1.Text1>type</I>  but not necessarily a direct instance of <I CLASS=T1.Text1>type</I>. This <A NAME=MARKER-2-1540></A>liberality allows <CODE CLASS=T1.Text1>make</CODE> to be called on an abstract class or other type;  it can instantiate and return a direct instance of one of the concrete subtypes of the abstract class or type.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">instance</I> returned may or may not be newly allocated. If a new instance is allocated, <CODE CLASS="cv T1.Text1">make</CODE> will call <CODE CLASS="cv T1.Text1">initialize</CODE> on the instance before returning it. </P>
<P CLASS=T1.Text1>Programmers may customize <CODE CLASS=T1.Text1>make</CODE> for particular classes by defining methods specialized by singleton specializers. These methods may obtain the default <CODE CLASS=T1.Text1>make</CODE> behavior, if desired, by calling next-method.</P>
<P CLASS=T1.Text1>Note that the <CODE CLASS="cv T1.Text1">&lt;class&gt;</CODE> method on <CODE CLASS="cv T1.Text1">make</CODE> returns a newly allocated direct instance of its first argument.</P>
</DL>
<A NAME=HEADING98-14></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>make</CODE> class <CODE CLASS=H5.Heading5>#rest supplied-init-args #key =>  object</CODE> [G.F. Method]</H4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1541></A>The method on <CODE CLASS=SD.ShortDescription>&lt;class&gt;</CODE> creates an instance of <I CLASS="Parameter SD.ShortDescription">class</I>, calls <CODE CLASS="cv SD.ShortDescription">initialize</CODE> on the instance, and then returns the instance. An error is signaled if <I CLASS="Parameter SD.ShortDescription">class</I> is abstract.</P>
<P CLASS=T1.Text1>A complete description of this method and its role in the initialization protocol is given in <A HREF="drm_43.htm#MARKER-9-658" CLASS=T1.Text1>"Instance Creation and Initialization" on page 64</A>.</P>
<A NAME=HEADING98-17></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>make (singleton (&lt;array&gt;))<BR> #key dimensions fill  =>  array</CODE> [Sealed G.F. Method]</H4>
<P CLASS=SD.ShortDescription>The method on <CODE CLASS=SD.ShortDescription>singleton(&lt;array&gt;)</CODE> accepts <I CLASS="Parameter SD.ShortDescription">dimensions</I> and <I CLASS="Parameter SD.ShortDescription">fill</I> keyword arguments, and instantiates a concrete subclass of <CODE CLASS="cv SD.ShortDescription">&lt;array&gt;</CODE>. These arguments are described with the &lt;array&gt; class on <A HREF="drm_93.htm#MARKER-9-1426" CLASS=SD.ShortDescription>page 218</A>.</P>
<A NAME=HEADING98-19></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>make (singleton (&lt;deque&gt;))<BR> #key size fill  =>  deque</CODE> [Sealed G.F. Method]</H4>
<P CLASS=SD.ShortDescription>The method on <CODE CLASS=SD.ShortDescription>singleton(&lt;deque&gt;)</CODE> accepts <I CLASS="Parameter SD.ShortDescription">size</I> and <I CLASS="Parameter SD.ShortDescription">fill</I> keyword arguments, and instantiates a concrete subclass of <CODE CLASS="cv SD.ShortDescription">&lt;deque&gt;</CODE>. These arguments are described with the &lt;deque&gt; class on <A HREF="drm_93.htm#MARKER-9-1442" CLASS=SD.ShortDescription>page 225</A>.</P>
<A NAME=HEADING98-21></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>make (singleton (&lt;range&gt;))<BR> #key from by to above below size  =>  deque</CODE> [Sealed G.F. Method]</H4>
<P CLASS=SD.ShortDescription>The method on <CODE CLASS=SD.ShortDescription>singleton(&lt;range&gt;)</CODE> accepts a number of keyword arguments, and instantiates a concrete subclass of <CODE CLASS="cv SD.ShortDescription">&lt;range&gt;</CODE>. These arguments are described with the <CODE CLASS="cv SD.ShortDescription">&lt;range&gt;</CODE> class on <A HREF="drm_93.htm#MARKER-9-1454" CLASS=SD.ShortDescription>page 230</A>.</P>
<A NAME=HEADING98-23></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>make (singleton (&lt;table&gt;))<BR> #key size  =>  object-table</CODE> [Sealed G.F. Method]</H4>
<P CLASS=SD.ShortDescription>The method on <CODE CLASS=SD.ShortDescription>singleton(&lt;table&gt;)</CODE> accepts <I CLASS="Parameter SD.ShortDescription">size</I> keyword argument, and instantiates <CODE CLASS="cv SD.ShortDescription">&lt;object-table&gt;</CODE>. The size argument is described with the &lt;table&gt; class on <A HREF="drm_93.htm#MARKER-9-1462" CLASS=SD.ShortDescription>page 235</A>.</P>
<A NAME=HEADING98-25></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>make (singleton (&lt;vector&gt;))<BR> #key size fill  =>  simple-object-vector</CODE> [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>make (singleton (&lt;simple-vector&gt;))<BR> #key size fill  =>  simple-object-vector</CODE> [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>Methods on <CODE CLASS=T1.Text1>singleton(&lt;vector&gt;)</CODE> and <CODE CLASS=T1.Text1>singleton(&lt;simple-vector&gt;)</CODE> accept <I CLASS="Parameter T1.Text1">size</I> and <I CLASS="Parameter T1.Text1">fill</I> keyword arguments, and return an instance of <CODE CLASS="cv T1.Text1">&lt;simple-object-vector&gt;</CODE>. These arguments are described with the <CODE CLASS="cv T1.Text1">&lt;vector&gt;</CODE> class on <A HREF="drm_93.htm#MARKER-9-1432" CLASS=T1.Text1>page 221</A> and with the <CODE CLASS="cv T1.Text1">&lt;simple-vector&gt;</CODE> class on <A HREF="drm_93.htm#MARKER-9-1435" CLASS=T1.Text1>page 222</A>.</P>
<A NAME=HEADING98-27></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>make (singleton (&lt;list&gt;))<BR> #key size fill  =>  list</CODE> [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>A method on <CODE CLASS=T1.Text1>singleton(&lt;list&gt;)</CODE> accepts <I CLASS="Parameter T1.Text1">size</I> and <I CLASS="Parameter T1.Text1">fill</I> keyword arguments. These arguments are described with the <CODE CLASS="cv T1.Text1">&lt;list&gt;</CODE> class on <A HREF="drm_93.htm#MARKER-9-1449" CLASS=T1.Text1>page 227</A>.</P>
<A NAME=HEADING98-29></A>
<A NAME="UID-Built-In_Functions-2323"></A>
<H2 CLASS=H2.Heading2> Initialization</H2>
<A NAME=HEADING98-30></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1542></A>initialize</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1543></A>Performs instance initialization that cannot be specified declaratively by a class definition.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">initialize <I CLASS="Parameter cv Cliche">instance #key #all-keys => #rest objects</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">instance</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">objects </I>Instances of <CODE CLASS="cv Cliche2">&lt;object&gt;</CODE>. The return values are ignored by <CODE CLASS="cv Cliche2">make</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Provides a way for users to handle initialization of instances which cannot be expressed simply by init specifications. This is typically needed when a computation requires inputs from multiple initialization arguments or slot values, or a single computation needs to be used to initialize multiple slots.</P>
<P CLASS=T1.Text1>By convention, all <CODE CLASS=T1.Text1>initialize</CODE> methods should call next-method very early, to make sure that any initializations from less specific classes are performed first.</P>
<P CLASS=T1.Text1>The <CODE CLASS=T1.Text1>initialize</CODE> generic function permits all keywords and requires none. It does this because the keyword argument checking is performed by the default method on <CODE CLASS=T1.Text1>make</CODE>.</P>
</DL>
<A NAME=HEADING98-38></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>initialize</CODE> object <CODE CLASS=H5.Heading5>#key =>  object</CODE> [G.F. Method]</H4>
<P CLASS=SD.ShortDescription>This method does nothing. It is present so that it is always safe for <CODE CLASS=SD.ShortDescription>initialize</CODE> methods to call next method, and so that it is safe for the default <CODE CLASS="cv SD.ShortDescription">make</CODE> method to call <CODE CLASS="cv SD.ShortDescription">initialize</CODE>.</P>
<A NAME=HEADING98-40></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1544></A>slot-initialized? </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-1545></A><A NAME=MARKER-9-1546></A>Tests whether a slot has been initialized</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">slot-initialized? <I CLASS="Parameter Code Cliche">instance getter  => boolean</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">instance</I> An instance of of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">getter</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;generic-function&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">boolean</I> An instance of <CODE CLASS="cv Cliche">&lt;boolean&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns true if the slot in <I CLASS="Parameter Cliche">instance</I> that would be accessed by the <I CLASS="Parameter Cliche">getter</I> generic function is initialized. If the slot is not initialized, then false is returned.</P>
<P CLASS=T1.Text1><CODE CLASS="cv T1.Text1">slot-initialized?</CODE> will signal an error if the  <I CLASS="Parameter T1.Text1">getter</I> does not access a slot in the <I CLASS="Parameter T1.Text1">instance</I>.</P>
<P CLASS=T1.Text1>To support <CODE CLASS="cv T1.Text1">slot-initialized?</CODE> for a virtual slot, programmers must define a method for <CODE CLASS="cv T1.Text1">slot-initialized?</CODE> that shares a protocol with the getter of the slot.<A NAME=MARKER-2-1547></A></P>
</DL>
<A NAME=HEADING98-49></A>
<A NAME="UID-Built-In_Functions-25322"></A>
<H2 CLASS=H2.Heading2> Specific Constructors</H2>
<A NAME=HEADING98-50></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1548></A><A NAME=MARKER-2-1549></A>list </CODE>[Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1550></A>Creates and returns a freshly allocated list.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">list #rest <I CLASS="Parameter Code Cliche">arguments => list</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">arguments</I> The elements of the <I CLASS="Parameter Cliche">list</I>. Instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">list</I> A freshly allocated instance of <CODE CLASS="cv Cliche">&lt;list&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a freshly allocated list containing the <I CLASS=Cliche>arguments</I>, in order.</P>
</DL>
<A NAME=HEADING98-56></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1551></A>pair </CODE>[Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1552></A><A NAME=MARKER-2-1553></A>Creates and returns a freshly allocated pair.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">pair <I CLASS="Parameter Code Cliche">object1,object2 => pair</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object1</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">object2</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">pair</I> A freshly allocated instance of <CODE CLASS="cv Cliche">&lt;pair&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Creates a freshly allocated pair whose head value is <I CLASS="Parameter Cliche">object1</I> and tail value is <I CLASS="Parameter Cliche">object2</I>.</P>
</DL>
<PRE CLASS=Cv.Code>
pair (1, 2)
  => #(1 . 2)
pair (1, #(2, 3, 4, 5))
  => #(1, 2, 3, 4, 5)
</PRE>
<P CLASS=T1.Text1>Note that while the pair returned by <CODE CLASS="cv T1.Text1">pair</CODE> is freshly allocated, it may be the beginning of a list, portions of which are not freshly allocated.</P>
<PRE CLASS=Cv.Code>
define variable *preexisting-list* = list(2, 3, 4)
define variable *new-list* = pair(1, *preexisting-list*)
*new-list*
  => #(1, 2, 3, 4)
tail(*new-list*) == *preexisting-list*
  => #t
third(*new-list*) := 'x'
*new-list*
  fi<CODE CLASS="cv Cv.Code">  </CODE>#(1, 2, x, 4)
*preexisting-list*
  fi<CODE CLASS="cv Cv.Code">  </CODE>#(2, x, 4)
</PRE>
<A NAME=HEADING98-66></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1554></A>range</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-1555></A>Creates and returns a range.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">range #key <I CLASS="Parameter Code Cliche">from to above below by size => range</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">from</I> An instance of <CODE CLASS="cv Cliche">&lt;real&gt;</CODE>. The default value is <CODE CLASS="cv Cliche">0</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">to</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;real&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">above</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;real&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">below</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;real&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">by</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;real&gt;. </CODE>The default value is <CODE CLASS="cv RP.RoutineParam">0</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">size</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;real&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">range</I> An instance of <CODE CLASS="cv Cliche">&lt;range&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Creates an instance of <CODE CLASS="cv Cliche">&lt;range&gt;</CODE>. The arguments correspond to the initialization arguments of <CODE CLASS="cv Cliche">&lt;range&gt;</CODE>, described on <A HREF="drm_93.htm#MARKER-9-1454" CLASS=Cliche>page 230</A>.</P>
</DL>
<A NAME=HEADING98-77></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1556></A>singleton</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-1557></A>Creates and returns a singleton.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">singleton <I CLASS="Parameter Code Cliche">object => singleton</I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">singleton</I> An instance of <CODE CLASS="cv Cliche">&lt;singleton&gt;</CODE>. The singleton for <I CLASS="Parameter Cliche">object</I>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a singleton for <I CLASS=Cliche>object</I>. <CODE CLASS=Cliche>singleton(<I CLASS=Cliche>object)</I></CODE> is equivalent to <CODE CLASS=Cliche>make(&lt;singleton&gt;, object: <I CLASS=Cliche>object)</I></CODE>. If a singleton for the specified object already exists, implementations are free to return it rather than allocate a new singleton.</P>
</DL>
<A NAME=HEADING98-83></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1558></A>limited</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1559></A><A NAME=MARKER-2-1560></A>Returns a limited subtype of a class.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">limited</CODE> <I CLASS="Parameter Cliche">class</I>  <CODE CLASS="cv Cliche">#key</CODE> <B CLASS=Cliche> => <I CLASS="Parameter Cliche">type</I></B></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">class</I> An instance of <CODE CLASS="cv Cliche">&lt;class&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">type</I> An instance of <CODE CLASS="cv Cliche">&lt;type&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a limited subtype of <I CLASS=Cliche>class</I>. The available keyword arguments depend on the <I CLASS="Parameter Cliche">class</I>. Not all classes support <CODE CLASS=Cliche>limited</CODE>; those that do are documented in the method descriptions below.</P>
<P CLASS=T1.Text1>Note that an implementation is not required to implement <CODE CLASS="cv T1.Text1">limited</CODE> as a generic function, and so the behavior embodied in the following method descriptions need not actually be implemented by separate methods. The behavior is described as a set of methods for convenience of presentation only. </P>
</DL>
<A NAME=HEADING98-90></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;integer&gt;)) #key</EM></CODE>  <I CLASS="variable H5.Heading5">min max fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>Returns a limited integer type, which is a subtype of <CODE CLASS="cv T1.Text1">&lt;integer&gt;</CODE> whose instances are integers greater than or equal to <I CLASS="Parameter T1.Text1">min</I> (if <CODE CLASS="cv T1.Text1">min:</CODE> is specified) and less than or equal to <I CLASS="Parameter T1.Text1">max</I> (if <CODE CLASS="cv T1.Text1">max:</CODE> is specified). If no keyword arguments are specified, the result type is equivalent to <CODE CLASS="cv T1.Text1">&lt;integer&gt;</CODE>. Limited integer types are not instantiable.</P>
<A NAME=HEADING98-92></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5><A NAME=MARKER-9-1561></A>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;collection&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;explicit-key-collection&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;mutable-collection&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;stretchy-collection&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;mutable-explicit-key-collection&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;sequence&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;mutable-sequence&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>These methods return uninstantiable limited collection types.</P>
<A NAME=HEADING98-94></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;table&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;object-table&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>These two methods return types that support a <CODE CLASS="cv T1.Text1">size:</CODE> initialization keyword with the same behavior as <CODE CLASS="cv T1.Text1">&lt;table&gt;</CODE>.</P>
<A NAME=HEADING98-96></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;array&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size dimensions fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>This method returns a type that supports <CODE CLASS="cv T1.Text1">dimensions:</CODE> and <CODE CLASS="cv T1.Text1">fill:</CODE> initialization keywords with the same behavior as <CODE CLASS="cv T1.Text1">&lt;array&gt;</CODE>. The default for fill is <CODE CLASS="cv T1.Text1">#f</CODE> so if <CODE CLASS="cv T1.Text1">instance?(#f, <I CLASS="Parameter cv T1.Text1">of)</I></CODE> is not true and the product of the <I CLASS="Parameter T1.Text1">dimensions</I> is nonzero, the <CODE CLASS="cv T1.Text1">fill:</CODE> initialization keyword is required because the default would cause a type error.</P>
<P CLASS=T1.Text1>Instantiating <I CLASS="Parameter T1.Text1">type</I> with a value of <I CLASS="Parameter T1.Text1">dimensions</I>  that has one element will return an instance of <CODE CLASS="cv T1.Text1">limited(&lt;simple-vector&gt;, of: <I CLASS="Parameter cv T1.Text1">of)</I></CODE>.</P>
<A NAME=HEADING98-99></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;vector&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>This method returns the same types as the method on <CODE CLASS="cv T1.Text1">singleton(&lt;simple-vector&gt;)</CODE>.</P>
<A NAME=HEADING98-101></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;simple-vector&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;stretchy-vector&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of  fi</I> type [Sealed G.F. Method]<BR><CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;deque&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of  fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>These three methods return types that support <CODE CLASS="cv T1.Text1">size:</CODE> and <CODE CLASS="cv T1.Text1">fill:</CODE> initialization keywords with the same behavior as the collection-class argument. The default for fill is <CODE CLASS="cv T1.Text1">#f</CODE> so if <CODE CLASS="cv T1.Text1">instance?(#f, <I CLASS="Parameter cv T1.Text1">of)</I></CODE> is not true and <I CLASS="Parameter T1.Text1">size</I> is nonzero, the <CODE CLASS="cv T1.Text1">fill:</CODE> initialization keyword is required because the default would cause a type error.</P>
<P CLASS=T1.Text1>All general instances of <CODE CLASS="cv T1.Text1">&lt;simple-vector&gt;</CODE> provide a constant time implementation of <CODE CLASS="cv T1.Text1">element</CODE> and <CODE CLASS="cv T1.Text1">element-setter</CODE>.</P>
<A NAME=HEADING98-104></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;string&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of size  fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">of</I> argument must be a subtype of <CODE CLASS="cv T1.Text1">&lt;character&gt;</CODE>. This method returns a type that supports <CODE CLASS="cv T1.Text1">size:</CODE> and <CODE CLASS="cv T1.Text1">fill:</CODE> initialization keywords with the same behavior as <CODE CLASS="cv T1.Text1">&lt;string&gt;</CODE>. The default for <CODE CLASS="cv T1.Text1">fill</CODE>: is <CODE CLASS="cv T1.Text1">' '</CODE> so if <CODE CLASS="cv T1.Text1">instance?(' ', <I CLASS="Parameter cv T1.Text1">of)</I></CODE> is not true and <I CLASS="Parameter T1.Text1">size</I> is nonzero, the <CODE CLASS="cv T1.Text1">fill:</CODE> initialization keyword is required because the default would cause a type error.</P>
<P CLASS=T1.Text1>There are no specified subtypes of <CODE CLASS="cv T1.Text1">&lt;character&gt;</CODE>, except for unions of singletons, which makes this method rather useless for portable programs. However, the method is provided because there might be useful subtypes of <CODE CLASS="cv T1.Text1">&lt;character&gt;</CODE> in a particular implementation or in future versions of Dylan.</P>
<A NAME=HEADING98-107></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>limited<EM CLASS="definition H5.Heading5"> (singleton (&lt;range&gt;))<BR>        #key</EM></CODE>  <I CLASS="variable H5.Heading5">of  fi</I> type [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">of</I> argument must be a subtype of <CODE CLASS="cv T1.Text1">&lt;real&gt;</CODE>. This method returns a type that supports <CODE CLASS="cv T1.Text1">from:</CODE>, <CODE CLASS="cv T1.Text1">to:</CODE>, <CODE CLASS="cv T1.Text1">below:</CODE>, <CODE CLASS="cv T1.Text1">above:</CODE>, <CODE CLASS="cv T1.Text1">by:</CODE>, and <CODE CLASS="cv T1.Text1">size:</CODE> initialization keywords with the same behavior as <CODE CLASS="cv T1.Text1">&lt;range&gt;</CODE>. Make of this type signals a <CODE CLASS="cv T1.Text1">&lt;type-error&gt;</CODE> if any element of the range is not an instance of <I CLASS="Parameter T1.Text1">of</I>.</P>
<A NAME=HEADING98-109></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1562></A><A NAME=MARKER-9-1563></A>type-union</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1564></A><A NAME=MARKER-2-1565></A>Returns the union of two or more types.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">type-union<EM CLASS="definition Code Cliche"><B CLASS="definition Code Cliche"> <I CLASS="Parameter definition Code Cliche">type1 #rest more-types  => type</I></B></EM></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">type1</I> An instance of <CODE CLASS="cv Cliche">&lt;type&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-types</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;type&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">type</I> An instance of <CODE CLASS="cv Cliche">&lt;type&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a type whose instances are the instances of <I CLASS="Parameter Cliche">type1</I> and all the <I CLASS="Parameter Cliche">more-types</I>. The type returned is not instantiable. A complete description of union types is given in <A HREF="drm_45.htm#MARKER-9-701" CLASS=Cliche>"Union Types" on page 72</A>.</P>
</DL>
<PRE CLASS=Cv.Code>
define constant $my-enumerated-type = 
                    type-union(singleton(#&quot;one&quot;),
                               singleton(#&quot;two&quot;),
                               singleton(#&quot;three&quot;),
                               singleton(#&quot;four&quot;),
                               singleton(#&quot;five&quot;))
</PRE>
<A NAME=HEADING98-117></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1566></A>vector</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1567></A><A NAME=MARKER-2-1568></A>Creates and returns a freshly allocated vector.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">vector #rest <I CLASS="Parameter Code Cliche">arguments <B CLASS="Parameter Code Cliche"> =>  vector</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">arguments</I> Instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">vector</I> A freshly allocated instance of <CODE CLASS="cv Cliche2">&lt;simple-object-vector&gt;</CODE>. Its elements are the <I CLASS="Parameter Cliche2">arguments</I>, in order.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a vector whose elements are the <I CLASS="Parameter Cliche">arguments</I>, in order.<A NAME=MARKER-2-1569></A></P>
</DL>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-2" CLASS=FOOTER><B CLASS=FOOTER></B>General Constructor</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-3" CLASS=FOOTER><B CLASS=FOOTER></B>make [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-14" CLASS=FOOTER><B CLASS=FOOTER></B>make class #rest supplied-init-args #key =>  object [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-17" CLASS=FOOTER><B CLASS=FOOTER></B>make (singleton (&lt;array&gt;))  #key dimensions fill  =>  array [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-19" CLASS=FOOTER><B CLASS=FOOTER></B>make (singleton (&lt;deque&gt;))  #key size fill  =>  deque [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-21" CLASS=FOOTER><B CLASS=FOOTER></B>make (singleton (&lt;range&gt;))  #key from by to above below size  =>  deque [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-23" CLASS=FOOTER><B CLASS=FOOTER></B>make (singleton (&lt;table&gt;))  #key size  =>  object-table [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-25" CLASS=FOOTER><B CLASS=FOOTER></B>make (singleton (&lt;vector&gt;))  #key size fill  =>  simple-object-vector [Sealed G.F. Method] make (singleton (&lt;simple-vector&gt;))  #key size fill  =>  simple-object-vector [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-27" CLASS=FOOTER><B CLASS=FOOTER></B>make (singleton (&lt;list&gt;))  #key size fill  =>  list [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-29" CLASS=FOOTER><B CLASS=FOOTER></B>Initialization</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-30" CLASS=FOOTER><B CLASS=FOOTER></B>initialize [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-38" CLASS=FOOTER><B CLASS=FOOTER></B>initialize object #key =>  object [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-40" CLASS=FOOTER><B CLASS=FOOTER></B>slot-initialized? [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-49" CLASS=FOOTER><B CLASS=FOOTER></B>Specific Constructors</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-50" CLASS=FOOTER><B CLASS=FOOTER></B>list [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-56" CLASS=FOOTER><B CLASS=FOOTER></B>pair [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-66" CLASS=FOOTER><B CLASS=FOOTER></B>range [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-77" CLASS=FOOTER><B CLASS=FOOTER></B>singleton [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-83" CLASS=FOOTER><B CLASS=FOOTER></B>limited [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-90" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;integer&gt;)) #key  min max => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-92" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;collection&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;explicit-key-collection&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;mutable-collection&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;stretchy-collection&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;mutable-explicit-key-collection&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;sequence&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;mutable-sequence&gt;))         #key  of size => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-94" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;table&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;object-table&gt;))         #key  of size => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-96" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;array&gt;))         #key  of size dimensions => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-99" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;vector&gt;))         #key  of size => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-101" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;simple-vector&gt;))         #key  of size => type [Sealed G.F. Method] limited (singleton (&lt;stretchy-vector&gt;))         #key  of  => type [Sealed G.F. Method] limited (singleton (&lt;deque&gt;))         #key  of  => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-104" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;string&gt;))         #key  of size  => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-107" CLASS=FOOTER><B CLASS=FOOTER></B>limited (singleton (&lt;range&gt;))         #key  of  => type [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-109" CLASS=FOOTER><B CLASS=FOOTER></B>type-union [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_98.htm#HEADING98-117" CLASS=FOOTER><B CLASS=FOOTER></B>vector [Function]</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_99.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_97.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_96.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

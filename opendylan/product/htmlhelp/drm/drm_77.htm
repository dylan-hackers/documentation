<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_76.htm">
<LINK REL=PREV HREF="drm_76.htm">
<LINK REL=NEXT HREF="drm_78.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Overview</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING77></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_78.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>10 Macros</P>

</DIV>
<A NAME=HEADING77-0></A>
<A NAME=UID-Macros-2598></A>
<H1 CLASS=H1.Heading1> Overview</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-1175></A>A <A NAME=MARKER-2-1176></A>macro is an extension to the core language that can be defined by the user, by the implementation, or as part of the Dylan language specification. Much of the <A NAME=MARKER-2-1177></A>grammatical structure of Dylan is built with macros. A macro defines the meaning of one construct in terms of another construct. The compiler substitutes the new construct for the original. The purpose of macros is to allow programmers to extend the Dylan language, for example by creating new control structures or new definitions. Unlike C, Dylan does not intend macros to be used to <A NAME=MARKER-2-1178></A>optimize code by inlining. Other parts of the language, such as sealing and <CODE CLASS="cv T1.Text1">define constant</CODE>, address that need.</P>
<P CLASS=T1.Text1>Throughout this chapter, <I CLASS="Parameter T1.Text1">italic font</I> and <EM CLASS=T1.Text1>small caps</EM> are used to indicate references to the formal grammar given in <A HREF="drm_116.htm#MARKER-9-2090" CLASS=T1.Text1>Appendix A, "BNF."</A></P>
<A NAME=HEADING77-3></A>
<A NAME=UID-Macros-5923></A>
<H2 CLASS=H2.Heading2> Compilation and Macro Processing</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-1179></A>Compilation consists of six conceptual phases:</P>
<P CLASS="N/.NList=1"><A NAME=MARKER-2-1180></A>Parsing a stream of characters into tokens, according to the lexical grammar in <A HREF="drm_116.htm#MARKER-9-2090" CLASS="N/.NList=1">Appendix A, "BNF."</A></P>
<P CLASS=N.NList><A NAME=MARKER-2-1181></A>Parsing a stream of tokens into a program, according to the phrase grammar in <A HREF="drm_116.htm#MARKER-9-2090" CLASS=N.NList>Appendix A, "BNF."</A></P>
<P CLASS=N.NList>Macro expansion, which translates the program to a core language.</P>
<P CLASS=N.NList><A NAME=MARKER-2-1182></A>Definition processing, which recognizes special and built-in definitions and builds a compile-time model of the static structure of the program.</P>
<P CLASS=N.NList>Optimization, which rewrites the program for improved performance.</P>
<P CLASS=N.NList>Code generation, which translates the program to executable form.</P>
<P CLASS=T1.Text1>Portions of a program can be <A NAME=MARKER-2-1183></A>macro calls. <A NAME=MARKER-2-1184></A>Macro expansion replaces a macro call with another construct, which can itself be a macro call or contain macro calls. This expansion process repeats until there are no macro calls remaining in the program, thus macros have no space or speed cost at run time. Of course, expanding macros affects the speed and space cost of compilation.</P>
<P CLASS=T1.Text1>A <A NAME=MARKER-2-1185></A>macro definition describes both the syntax of a macro call and the process for creating a new construct to replace the macro call. Typically the new construct contains portions of the old one, which can be regarded as <A NAME=MARKER-2-1186></A>arguments to the macro. A macro definition consists of a sequence of rewrite rules. The left-hand side of each rule is a pattern that matches a macro call. The right-hand side is a <A NAME=MARKER-2-1187></A>template for the expansion of a matching call. <A NAME=MARKER-2-1188></A>Pattern variables appearing in the left-hand side act as names for macro arguments. Pattern variables appearing in the right-hand side substitute arguments into the expansion. Macro arguments can be constrained to match specified elements of the Dylan grammar. Auxiliary rule sets enhance the rewrite rule notation with named subrules.</P>
<P CLASS=T1.Text1>Some implementations and a future version of the Dylan language specification might allow macro expansions to be produced by compile-time computation using the full Dylan language and an object-oriented representation for programs. Such a "procedural macro" facility is not part of Dylan at this time.</P>
<P CLASS=T1.Text1>The input to, and output from, macro expansion is a <A NAME=MARKER-2-1189></A>fragment, which is a sequence of elementary fragments. An elementary fragment is one of the following:</P>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1>A token: the output of the lexical grammar. The bracket tokens <CODE CLASS="cv B1.Bullet1">(</CODE>, <CODE CLASS="cv B1.Bullet1">)</CODE>, <CODE CLASS="cv B1.Bullet1">[</CODE>, <CODE CLASS="cv B1.Bullet1">]</CODE>, <CODE CLASS="cv B1.Bullet1">{</CODE>, <CODE CLASS="cv B1.Bullet1">}</CODE>, <CODE CLASS="cv B1.Bullet1">#(</CODE>, and <CODE CLASS="cv B1.Bullet1">#[</CODE> are not allowed. Core reserved words (except <CODE CLASS="cv B1.Bullet1">otherwise</CODE>), <EM CLASS=B1.Bullet1>begin-words</EM>, and <EM CLASS=B1.Bullet1>function-words</EM> are not allowed unless quoted with backslash.
<LI CLASS=B1.Bullet1>A bracketed fragment: balanced brackets ( <CODE CLASS="cv B1.Bullet1">()</CODE>, <CODE CLASS="cv B1.Bullet1">[]</CODE>, or <CODE CLASS="cv B1.Bullet1">{}</CODE> ) enclosing a fragment.
<LI CLASS=B1.Bullet1>A macro call fragment: a macro call.
<LI CLASS=B1.Bullet1>A parsed fragment: a single unit that is not decomposable into its component tokens. It has been fully parsed by the phrase grammar. A parsed fragment is either a function call, a list constant, a vector constant, a definition, or a local declaration.
<P CLASS=T1.Text1>The second and third phases of compilation (parsing and macro expansion) are interleaved, not sequential. The parsing phase of the compiler parses a macro call just enough to find its end. See <I CLASS="Parameter T1.Text1">definition-macro-call, statement, function-macro-call, body-fragment, list-fragment,</I> <I CLASS=T1.Text1> </I>and<I CLASS=T1.Text1> basic-fragment</I>  in <A HREF="drm_116.htm#MARKER-9-2090" CLASS=T1.Text1>Appendix A, "BNF."</A> This process of parsing a macro call also parses any macro calls nested inside it. The result is a macro call fragment.</P>
<P CLASS=T1.Text1>This loose grammar for macro calls gives users a lot of flexibility to choose the grammar that their macros will accept. For example, the grammar of macro calls doesn't care whether  a bracketed fragment will be interpreted as an argument list, a parameter list, a set of <CODE CLASS="cv T1.Text1">for</CODE> clauses, or a module import list.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-1190></A>The compiler delays computing the expansion of a macro call fragment until it is needed. If an argument to a macro is a macro call, the outer macro call is always expanded first. When the compiler computes the expansion of a macro call fragment, it obeys the macro's definition. Constraints on pattern variables can cause reparsing of portions of the macro call.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-1191></A>A <I CLASS="Parameter T1.Text1">constituent</I>, <I CLASS="Parameter T1.Text1">operand</I>, or <I CLASS="Parameter T1.Text1">leaf</I>  that is a macro call expands the macro during or before the definition processing and optimization phases. The compiler brackets the expansion in <CODE CLASS="cv T1.Text1">begin</CODE> ... <CODE CLASS="cv T1.Text1">end</CODE>, using the standard binding of <CODE CLASS="cv T1.Text1">begin</CODE> in the Dylan module, and then reparses it as a <I CLASS="Parameter T1.Text1">statement</I>. This reparsing may discover more macro calls. A parse error while reparsing a macro expansion could indicate an invalid macro definition or an incorrect call to the macro that was not detected during pattern matching. Once the cycle of macro expansion and reparsing has been completed, no tokens, bracketed fragments, or macro call fragments remain and the entire source record has become one parsed fragment.</P>
<P CLASS=T1.Text1>This <CODE CLASS="cv T1.Text1"><A NAME=MARKER-2-1192></A>begin</CODE> ... <CODE CLASS="cv T1.Text1">end</CODE> bracketing ensures that the expansion of a macro call will not be broken apart by operator precedence rules when the macro call is a subexpression. Similarly, it ensures that the scopes of local declarations introduced by a macro will not extend outside that macro expansion when the macro call is a statement in a body. </P>
<P CLASS=T1.Text1><A NAME=MARKER-2-1193></A>The fragment produced by parsing a macro call, which is the input to macro expansion, is as follows:</P>
<LI CLASS=B1.Bullet1><A NAME=MARKER-2-1194></A>Local declarations and <A NAME=MARKER-2-1195></A><A NAME=MARKER-2-1196></A>special definitions are parsed fragments.
<LI CLASS=B1.Bullet1>Calls to macros are macro call fragments.
<LI CLASS=B1.Bullet1><A NAME=MARKER-2-1197></A>List constants and vector constants are parsed fragments.
<LI CLASS=B1.Bullet1><A NAME=MARKER-2-1198></A>Anything in brackets is a bracketed fragment.
<LI CLASS=B1.Bullet1>If the macro call was not the result of macro expansion, everything else is represented as sequences of tokens. There are a few restrictions on the tokens, for example semicolons must appear in certain places and bare brackets cannot appear; for details see the definition of <I CLASS="Parameter B1.Bullet1">body-fragment</I>  and <I CLASS="Parameter B1.Bullet1">list-fragment</I>  in <A HREF="drm_116.htm#MARKER-9-2090" CLASS=B1.Bullet1>Appendix A, "BNF."</A>
<LI CLASS=B1.Bullet1>In a macro call that is the result of macro expansion, additional items can be parsed fragments, due to pattern-variable substitution.
<LI CLASS=B1.Bullet1>Many built-in macros expand into implementation-specific parsed fragments.
<P CLASS=T1.Text1><A NAME=MARKER-9-1199></A>The fragment produced by parsing an expression is as follows:</P>
<LI CLASS=B1.Bullet1> An expression consisting of a single token returns a one-token fragment. This will be a variable-name, noncollection literal, or <EM CLASS=B1.Bullet1>symbol</EM>.
<LI CLASS=B1.Bullet1>An expression consisting of just a <A NAME=MARKER-2-1200></A>string literal returns a one-token fragment. If the string literal consists of multiple <EM CLASS=B1.Bullet1>string</EM> tokens, they are concatenated into a single <EM CLASS=B1.Bullet1>string</EM> token.
<LI CLASS=B1.Bullet1>An expression consisting of just a <A NAME=MARKER-2-1201></A>list constant or a <A NAME=MARKER-2-1202></A>vector constant returns a list constant or vector constant fragment.
<LI CLASS=B1.Bullet1>An expression consisting of just a <A NAME=MARKER-2-1203></A>statement or <A NAME=MARKER-2-1204></A>function-macro-call returns a macro call fragment.
<LI CLASS=B1.Bullet1>An <A NAME=MARKER-2-1205></A>operator call, <A NAME=MARKER-2-1206></A>slot reference, or <A NAME=MARKER-2-1207></A>element reference that calls a function macro returns a macro call fragment.
<LI CLASS=B1.Bullet1>A function call, operator call, slot reference, or element reference that calls something other than a function macro returns a function call fragment.
<LI CLASS=B1.Bullet1>Enclosing an expression in parentheses does not change how it parses.
<P CLASS=T1.Text1>The term "<A NAME=MARKER-2-1208></A>parsed expression fragment" refers to any of the above.</P>
<P CLASS=T1.Text1>The parser recognizes parsed fragments as well as raw tokens. The nonterminals <I CLASS="Parameter T1.Text1">definition</I> and <I CLASS="Parameter T1.Text1">local-declaration</I> in the phrase grammar accept parsed fragments of the same kind. The nonterminal <I CLASS="Parameter T1.Text1">operand</I> accepts parsed function call fragments and macro call fragments. The nonterminal <I CLASS="Parameter T1.Text1">literal</I> accepts list constant and vector constant fragments. The nonterminal <I CLASS="Parameter T1.Text1">simple-fragment</I> accepts parsed function call fragments and macro call fragments. The nonterminal <I CLASS="Parameter T1.Text1">macro</I> accepts macro call fragments. The parser expands bracketed fragments into their constituent tokens before parsing them.<A NAME=MARKER-2-1209></A></P>
</UL>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_77.htm#HEADING77-3" CLASS=FOOTER><B CLASS=FOOTER></B>Compilation and Macro Processing</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_78.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_76.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

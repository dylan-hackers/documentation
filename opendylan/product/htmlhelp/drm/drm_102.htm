<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_96.htm">
<LINK REL=PREV HREF="drm_101.htm">
<LINK REL=NEXT HREF="drm_103.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Collection Operations</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING102></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_103.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_101.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_96.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>12 The Built-In Functions</P>

</DIV>
<A NAME=HEADING102-0></A>
<A NAME="UID-Built-In_Functions-3130"></A>
<H1 CLASS=H1.Heading1> <A NAME=MARKER-9-1696></A>Collection Operations</H1>
<P CLASS=T1.Text1><A NAME=MARKER-2-1697></A>The generic functions described in this section have predefined methods for the built-in collection classes (and sequence classes, where appropriate). The details of these predefined methods have not yet been specified.</P>
<P CLASS=T1.Text1>Note to implementors:  Functions such as <CODE CLASS="cv T1.Text1">map</CODE>, <CODE CLASS="cv T1.Text1">map-as</CODE> that return a new collection cannot rely on the type they instantiate having a valid default for <CODE CLASS="cv T1.Text1">fill:</CODE>. Therefore, when the size of the result is nonzero, these functions should compute the first element of the result before making the collection and specify that element as the <CODE CLASS="cv T1.Text1">fill:</CODE> value. Otherwise a spurious type error could occur when making the collection.</P>
<A NAME=HEADING102-3></A>
<A NAME="UID-Built-In_Functions-21096"></A>
<H2 CLASS=H2.Heading2> Collection Properties</H2>
<A NAME=HEADING102-4></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1698></A><A NAME=MARKER-2-1699></A>empty?</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1700></A>Returns true if its argument is empty.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">empty? <I CLASS="Parameter cv Cliche">object<B CLASS="Parameter cv Cliche">   =>  boolean</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">boolean</I> An instance of <CODE CLASS="cv Cliche">&lt;boolean&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns true if <I CLASS=Cliche>object</I> is empty. Otherwise returns <CODE CLASS=Cliche>#f</CODE>.</P>
</DL>
<A NAME=HEADING102-10></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>empty?</CODE>   collection =>  boolean [G.F. Method]</H4>
<P CLASS=T1.Text1>A set of methods defined for the class <CODE CLASS="cv T1.Text1">&lt;collection&gt;</CODE> returns true if the collection has zero elements.</P>
<A NAME=HEADING102-12></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1701></A>size</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><CODE CLASS=SD.ShortDescription><A NAME=MARKER-9-1702></A></CODE>Returns the size of its argument.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">size <I CLASS="Parameter cv Cliche">object<B CLASS="Parameter cv Cliche">  => #rest objects</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">objects</I> Instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the size of <I CLASS="Parameter Cliche">object</I>.</P>
</DL>
<A NAME=HEADING102-18></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>size</CODE> collection => integer-or-false [G.F. Method]</H4>
<P CLASS=T1.Text1>When called on a collection, <CODE CLASS="cv T1.Text1">size</CODE> returns the numbers of keys in the collection. This default method simply counts while iterating through the collection. <CODE CLASS="cv T1.Text1">size</CODE> may return <CODE CLASS="cv T1.Text1">#f</CODE> for collections of unbounded size.</P>
<A NAME=HEADING102-20></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>size</CODE> array => size  [G.F. Method]</H4>
<P CLASS=T1.Text1>The method for <CODE CLASS=T1.Text1>&lt;array&gt;</CODE> is equivalent to </P>
<PRE CLASS=Cv.Code>
<CODE CLASS="cv Cv.Code">reduce(\*, 1, dimensions (array))</CODE>
</PRE>
<A NAME=HEADING102-23></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>size  list</CODE>  =>  integer-or-false [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>For circular lists, <CODE CLASS=T1.Text1>size</CODE> is guaranteed to terminate and return <CODE CLASS=T1.Text1>#f</CODE>. For noncircular lists, <CODE CLASS=T1.Text1>size</CODE> returns an integer size value.</P>
<A NAME=HEADING102-25></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>size</CODE>   range =>  size [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>For unbounded ranges, <CODE CLASS=T1.Text1>size</CODE> always terminates and returns <CODE CLASS=T1.Text1>#f</CODE>. For finite ranges, <CODE CLASS=T1.Text1>size</CODE> returns an integer.</P>
<A NAME=HEADING102-27></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>size</CODE>   table =>  size [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The class <CODE CLASS="cv T1.Text1">&lt;table&gt;</CODE> provides an implementation of <CODE CLASS="cv T1.Text1">size</CODE> for use by its subclasses. The method returns an instance of <CODE CLASS="cv T1.Text1">&lt;integer&gt;</CODE>.</P>
<A NAME=HEADING102-29></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1703></A>size-setter</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1704></A>Sets the size of an object.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">size-setter<I CLASS="Parameter cv Cliche"> new-size object  <EM CLASS="Symbol Parameter cv Cliche">=> new-size</EM></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-size</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">object</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-size</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Sets the size of <I CLASS="Parameter Cliche">object</I> to <I CLASS="Parameter Cliche">new-size</I>.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>object </I>is modified by this operation.</P>
<P CLASS=T1.Text1>Methods are provided for stretchy sequences; that is, for collections that are instances both of <CODE CLASS="cv T1.Text1">&lt;stretchy-collection&gt;</CODE> and of <CODE CLASS="cv T1.Text1">&lt;sequence&gt;</CODE>.</P>
<P CLASS=T1.Text1><CODE CLASS="cv T1.Text1">size-setter</CODE> sets the size of a stretchy sequence<I CLASS=T1.Text1>  </I>to be <I CLASS="Parameter T1.Text1">new-size</I>. The stretchy sequence<I CLASS=T1.Text1> </I>is modified by this operation. If <I CLASS="Parameter T1.Text1">new-size </I>is less than or equal to the original size of the stretchy sequence, then the first <I CLASS="Parameter T1.Text1">new-size</I> elements of the stretchy sequence<I CLASS=T1.Text1> </I>are retained at the same positions. If <I CLASS="Parameter T1.Text1">new-size</I> is greater than the original size of the stretchy sequence, then the previous elements of the stretchy sequence<I CLASS=T1.Text1> </I>are retained at the same positions, and enough new elements are added to reach the new size. The value of each new element is the same as would have been used if the stretchy sequence<I CLASS=T1.Text1>  </I>had been created with <CODE CLASS=T1.Text1>make</CODE>, specifying <CODE CLASS="cv T1.Text1">size:</CODE> <I CLASS="Parameter T1.Text1">new-size  </I> but not <CODE CLASS="cv T1.Text1">fill:</CODE>.</P>
<P CLASS=T1.Text1>It is not specified how <CODE CLASS="cv T1.Text1">size-setter</CODE> adds new elements to the stretchy sequence. In particular, it is not required to call <CODE CLASS="cv T1.Text1">add!</CODE> or any other predefined function.</P>
</DL>
<A NAME=HEADING102-40></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1705></A>rank</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1706></A>Returns the number of dimensions of an array.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">rank <I CLASS="Parameter cv Cliche">array <B CLASS="Parameter cv Cliche"> => rank</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">array</I> An instance of <CODE CLASS="cv Cliche">&lt;array&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">rank</I> An instance of <CODE CLASS="cv Cliche">&lt;integer&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the number of dimensions (the rank) of <I CLASS=Cliche>array</I>.</P>
</DL>
<A NAME=HEADING102-46></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>rank</CODE> array => rank [G.F. Method]</H4>
<P CLASS=T1.Text1>The method for <CODE CLASS=T1.Text1>&lt;array&gt;</CODE> computes <CODE CLASS=T1.Text1>rank</CODE> by calling <CODE CLASS=T1.Text1>size</CODE> on the <CODE CLASS=T1.Text1>dimensions</CODE> of <CODE CLASS=T1.Text1>array</CODE>.</P>
<A NAME=HEADING102-48></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1707></A>row-major-index</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1708></A>Returns the row-major-index position of an array element.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">row-major-index <I CLASS="Parameter cv Cliche">array<B CLASS="Parameter cv Cliche"> #rest subscripts => index </B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">array</I> An instance of <CODE CLASS="cv Cliche">&lt;array&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">subscripts</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">index</I> An instance of <CODE CLASS="cv Cliche">&lt;integer&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Computes the position according to the row-major ordering of <CODE CLASS=Cliche>array</CODE> for the   element that is specified by <CODE CLASS=Cliche>subscripts</CODE>, and returns the position of that element.</P>
<P CLASS=T1.Text1>An error is signaled if the number of subscripts is not equal to the rank of the array. An error is signaled if any of the subscripts are out of bounds for array.</P>
</DL>
<A NAME=HEADING102-56></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>row-major-index</CODE> array <CODE CLASS=H5.Heading5>#rest</CODE> subscripts => index  [G.F. Method]</H4>
<P CLASS=T1.Text1>The method for <CODE CLASS=T1.Text1>&lt;array&gt;</CODE> computes the <I CLASS="Parameter T1.Text1">index</I> using the <I CLASS="Parameter T1.Text1">subscripts</I> and the result of calling <CODE CLASS=T1.Text1>dimensions</CODE> on the <I CLASS="Parameter T1.Text1">array</I>.</P>
<A NAME=HEADING102-58></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1709></A>dimensions</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1710></A>Returns the dimensions of an array.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">dimensions <I CLASS="Parameter cv Cliche">array<B CLASS="Parameter cv Cliche">   =>  sequence</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">array<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;array&gt;</CODE>.</P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">sequence<CODE CLASS="cv Parameter Cliche2"> </CODE></I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>. The elements of this sequences will be instances of <CODE CLASS="cv Cliche2">&lt;integer&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the dimensions <I CLASS=Cliche> </I>of <I CLASS=Cliche>array</I>, as a sequence of integers. The consequences are undefined if the resulting sequence is modified. This function forms the basis for all the other array operations. Each concrete subclass of <CODE CLASS=Cliche>&lt;array&gt;</CODE> must either provide or inherit an implementation of this function.</P>
</DL>
<A NAME=HEADING102-64></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>dimensions</CODE> vector =>  sequence [G.F. Method]</H4>
<P CLASS=T1.Text1>Returns a sequence whose single element is the size of the vector.</P>
<A NAME=HEADING102-66></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1711></A>dimension</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1712></A>Returns the size of a specified dimension of an array.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">dimension <I CLASS="Parameter cv Cliche">array axis<B CLASS="Parameter cv Cliche"> => dimension </B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">array </I>An instance of <CODE CLASS="cv Cliche">&lt;array&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">axis<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">dimension<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;integer&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the <I CLASS="Parameter Cliche">axis</I> dimension of <CODE CLASS=Cliche>array</CODE>.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">axis</I> must be a non-negative integer less than the rank of <CODE CLASS=T1.Text1>array</CODE>. An error is signaled if <I CLASS="Parameter T1.Text1">axis</I> is out of bounds for <CODE CLASS=T1.Text1>array</CODE>.</P>
</DL>
<A NAME=HEADING102-74></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>dimension</CODE> array axis => dimension   [G.F. Method]</H4>
<P CLASS=T1.Text1>The method for <CODE CLASS=T1.Text1>&lt;array&gt;</CODE> calls <CODE CLASS=T1.Text1>element</CODE> on the result of calling <CODE CLASS=T1.Text1>dimensions</CODE> on the <CODE CLASS=T1.Text1>array</CODE>, using the <CODE CLASS=T1.Text1>axis</CODE> number as the key.</P>
<A NAME=HEADING102-76></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1713></A>key-test</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1714></A>Returns the function used by its collection argument to compare keys.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">key-test <I CLASS="Parameter cv Cliche">collection<B CLASS="Parameter cv Cliche"> => test-function</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">collection<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;collection&gt;</CODE>.</P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">test-function</I> <CODE CLASS="cv Cliche2"> </CODE>An instance of <CODE CLASS="cv Cliche2">&lt;function&gt;. </CODE>The function used by the collection to compare keys. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the function used by <I CLASS="Parameter Cliche">collection</I> to compare keys.</P>
<P CLASS=T1.Text1>All collection classes must provide or inherit a method that returns a result consistent with their iteration protocol and <CODE CLASS=T1.Text1>element</CODE> methods. A given method for <CODE CLASS=T1.Text1>key-test</CODE> must return the same value (compared with <CODE CLASS=T1.Text1>==</CODE>) each time it is called.</P>
</DL>
<A NAME=HEADING102-83></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>key-test</CODE> sequence  => test-function [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The method of <CODE CLASS=T1.Text1>key-test</CODE> for sequences returns the function <CODE CLASS=T1.Text1>==</CODE>.</P>
<A NAME=HEADING102-85></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>key-test</CODE> table  => test-function [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The method of <CODE CLASS=T1.Text1>key-test</CODE> for instances of <CODE CLASS="cv T1.Text1">&lt;table&gt;</CODE> returns the first value of <CODE CLASS="cv T1.Text1">table-protocol(<I CLASS="Parameter cv T1.Text1">table)</I></CODE>.</P>
<A NAME=HEADING102-87></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1715></A>key-sequence</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><CODE CLASS=SD.ShortDescription><A NAME=MARKER-9-1716></A></CODE>Returns a sequence containing the keys of its collection argument.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">key-sequence <I CLASS="Parameter cv Cliche">collection<B CLASS="Parameter cv Cliche">  =>  keys</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">collection<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;collection&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">keys<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE> containing the keys of <I CLASS=Cliche>collection</I>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing the keys of <I CLASS=Cliche>collection</I>. </P>
<P CLASS=T1.Text1>Although elements may be duplicated in a collection, keys, by their nature, must be unique; two different elements in a collection may not share a common key, even though distinct keys may yield identical elements.</P>
<P CLASS=T1.Text1>The order in which the keys from <I CLASS=T1.Text1>collection</I> appear in the key sequence is unspecified if <I CLASS=T1.Text1>collection</I> is unstable under iteration. In particular, different calls to <CODE CLASS=T1.Text1>key-sequence</CODE> with the same argument may yield differently ordered key sequences. If <I CLASS=T1.Text1>collection</I>  is stable under iteration, however, the resulting sequence of keys will be in the natural order for <I CLASS=T1.Text1>collection</I>.<A NAME=MARKER-2-1717></A></P>
</DL>
<A NAME=HEADING102-95></A>
<A NAME="UID-Built-In_Functions-415"></A>
<H2 CLASS=H2.Heading2> Selecting Elements</H2>
<A NAME=HEADING102-96></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1718></A><A NAME=MARKER-2-1719></A>element</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><CODE CLASS=SD.ShortDescription><A NAME=MARKER-9-1720></A></CODE>Returns the collection element associated with a particular key.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">element <I CLASS="Parameter cv Cliche">collection key #key default<B CLASS="Parameter cv Cliche">  =>  element</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">collection<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;collection&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">key<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">default<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">element<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the element associated with <I CLASS=Cliche>key</I> in <I CLASS=Cliche>collection</I>. If no element is associated with <I CLASS=Cliche>key</I>, then the behavior of <CODE CLASS=Cliche>element</CODE> depends on whether it was called with a <I CLASS=Cliche>default</I> argument: if a <I CLASS=Cliche>default</I> argument was passed, its value is returned; otherwise, an error is signaled.</P>
<P CLASS=T1.Text1>All collections are required to implement <CODE CLASS=T1.Text1>element</CODE>.</P>
</DL>
<A NAME=HEADING102-105></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element</CODE> simple-vector  index #key default =>  element  [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>There is a constant time implementation of <CODE CLASS="cv T1.Text1">element</CODE> for all general instances of <CODE CLASS="cv T1.Text1">&lt;simple-vector&gt;</CODE>.</P>
<A NAME=HEADING102-107></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element</CODE> unicode-string index #key default  =>  character   [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The class <CODE CLASS=T1.Text1>&lt;unicode-string&gt;</CODE> provides a constant time implementation for the <CODE CLASS=T1.Text1>element</CODE> function.</P>
<A NAME=HEADING102-109></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element</CODE> byte-string index #key default  =>  character       [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The class <CODE CLASS=T1.Text1>&lt;byte-string&gt;</CODE> provides a constant time implementation for the <CODE CLASS=T1.Text1>element</CODE> function.</P>
<A NAME=HEADING102-111></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element</CODE> table key #key default  =>  element       [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The class <CODE CLASS=T1.Text1>&lt;table&gt;</CODE> provides a default implementation for the <CODE CLASS=T1.Text1>element</CODE> function.</P>
<A NAME=HEADING102-113></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1721></A>element-setter </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1722></A>Sets the collection element associated with a particular key.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">element-setter <I CLASS="Parameter cv Cliche">new-value  mutable-collection key<B CLASS="Parameter cv Cliche"> =>  new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">mutable-collection<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;mutable-collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">key<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value<CODE CLASS="cv Parameter Cliche"> </CODE></I>Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Alters <I CLASS=Cliche>mutable-collection </I> so that the value associated with <I CLASS=Cliche>key</I> will subsequently be <I CLASS=Cliche>new-value</I>. If <I CLASS="Parameter Cliche">mutable-collection</I> is stretchy, <CODE CLASS="cv Cliche">element-setter</CODE> may also change its size (for example, by adding new keys with values).</P>
<P CLASS=T1.Text1>An error is signaled if a program calls <CODE CLASS=T1.Text1>element-setter</CODE> with a key that is not already a key to <I CLASS=T1.Text1>collection</I>, unless the collection is stretchy.</P>
<P CLASS=T1.Text1>Stretchy collections allow <CODE CLASS=T1.Text1>element-setter</CODE> to be called with a key that is not present in the collection, expanding the collection as necessary to add a new element in that case. Each concrete subclass of <CODE CLASS=T1.Text1>&lt;stretchy-collection&gt;</CODE> must provide or inherit a method for <CODE CLASS=T1.Text1>element-setter</CODE> that behaves as follows when there is not already an element present for the indicated key:</P>
</DL>
<UL CLASS=B1.Bullet1>
<LI CLASS=B1.Bullet1> If the class is a subclass of <CODE CLASS=B1.Bullet1>&lt;explicit-key-collection&gt;</CODE>, adds a new element to the collection with the indicated key.
<LI CLASS=B1.Bullet1> If the class is a subclass of <CODE CLASS=B1.Bullet1>&lt;sequence&gt;</CODE>, first calls <CODE CLASS=B1.Bullet1>size-setter</CODE> on the key + 1 and the collection to expand the sequence. The key must be a non-negative integer.
</UL>
<A NAME=HEADING102-125></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element-setter</CODE>  new-element simple-vector  index  [Sealed G.F. Method]<BR>=>  new-element </H4>
<P CLASS=T1.Text1>There is a constant time implementation of <CODE CLASS="cv T1.Text1">element-setter</CODE> for all general instances of <CODE CLASS="cv T1.Text1">&lt;simple-vector&gt;</CODE>.</P>
<A NAME=HEADING102-127></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element-setter   new-value table key </CODE> [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The class <CODE CLASS="cv T1.Text1">&lt;table&gt;</CODE> provides an implementation of <CODE CLASS="cv T1.Text1">element-setter</CODE> for use by its subclasses. If no element with the given <I CLASS="Parameter T1.Text1">key</I> exists, <CODE CLASS=T1.Text1>element-setter</CODE> will add the <I CLASS="Parameter T1.Text1">key</I> and <I CLASS="Parameter T1.Text1">new-value</I> to the table.</P>
<A NAME=HEADING102-129></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element-setter</CODE>  character unicode-string index   [Sealed G.F. Method]<BR>=>  character</H4>
<P CLASS=T1.Text1>The class <CODE CLASS=T1.Text1>&lt;unicode-string&gt;</CODE> provides a constant time implementation for the <CODE CLASS=T1.Text1>element-setter</CODE> function.</P>
<A NAME=HEADING102-131></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>element-setter</CODE>  character byte-string index =>  character  [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The class <CODE CLASS=T1.Text1>&lt;byte-string&gt;</CODE> provides a constant time implementation for the <CODE CLASS=T1.Text1>element-setter</CODE> function.</P>
<A NAME=HEADING102-133></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1723></A>aref</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1724></A>Returns the array element indicated by a set of indices.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">aref <I CLASS="Parameter cv Cliche">array</I></CODE> <CODE CLASS="cv Cliche">#rest</CODE> <I CLASS="Parameter Cliche">indices<B CLASS="Parameter Cliche"> => element </B></I></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">array<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;array&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">indices<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">element<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the element of <I CLASS=Cliche>array</I> indicated by <I CLASS=Cliche>indices</I>.</P>
<P CLASS=T1.Text1>An error is signaled if the number of <I CLASS=T1.Text1>indices</I> is not equal to the rank of the <I CLASS=T1.Text1>array</I>. An error is signaled if any of the <I CLASS=T1.Text1>indices</I> are out of bounds for the <I CLASS=T1.Text1>array</I>.</P>
</DL>
<A NAME=HEADING102-141></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>aref</CODE> array <CODE CLASS=H5.Heading5>#rest</CODE> indices => element  [G.F. Method]</H4>
<P CLASS=T1.Text1>The method for <CODE CLASS=T1.Text1>&lt;array&gt;</CODE> calls <CODE CLASS=T1.Text1>element</CODE> on the <I CLASS=T1.Text1>array</I>, using as the key the result of applying <CODE CLASS=T1.Text1>row-major-index</CODE> to the <I CLASS=T1.Text1>array </I>and <I CLASS=T1.Text1>indices</I>.</P>
<A NAME=HEADING102-143></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1725></A>aref-setter </CODE>  [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1726></A>Sets the array element indicated by a set of indices.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">aref-setter <I CLASS="Parameter cv Cliche">new-value array #rest indices<B CLASS="Parameter cv Cliche"> => new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">array<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;array&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">indices</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Sets the element of <I CLASS=Cliche>array</I> indicated by <I CLASS=Cliche>indices</I> to the <I CLASS="Parameter Cliche">new-value</I> and returns the <I CLASS="Parameter Cliche">new-value</I>.</P>
<P CLASS=T1.Text1>array is modified by this operation.</P>
<P CLASS=T1.Text1>An error is signaled if the number of <I CLASS=T1.Text1>indices</I> is not equal to the rank of the <I CLASS=T1.Text1>array</I>. An error is signaled if any of the <I CLASS=T1.Text1>indices</I> are out of bounds for <I CLASS=T1.Text1>array</I>. An error is signaled if the <I CLASS=T1.Text1>array </I>is limited to hold objects of a particular type and the new value is not an instance of that type.</P>
</DL>
<A NAME=HEADING102-153></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>aref-setter</CODE> new-value   array <CODE CLASS=H5.Heading5> #rest</CODE> indices => new-value  [G.F. Method]</H4>
<P CLASS=T1.Text1>The method for <CODE CLASS=T1.Text1>&lt;array&gt;</CODE> calls <CODE CLASS=T1.Text1>element-setter</CODE> on the array and new value, using as the key the result of applying <CODE CLASS=T1.Text1>row-major-index</CODE> to the <CODE CLASS=T1.Text1>array</CODE> and <I CLASS="Parameter T1.Text1">indices</I>.</P>
<A NAME=HEADING102-155></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1727></A>first</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1728></A>Returns the first element of a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">first <I CLASS="Parameter cv Cliche">sequence #key default<B CLASS="Parameter cv Cliche"> =>  value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">sequence<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">default<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE> .</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the first element of the <I CLASS=Cliche>sequence</I> by calling <CODE CLASS=Cliche>element</CODE> with the supplied arguments and the corresponding index. </P>
<P CLASS=T1.Text1>Note that because <CODE CLASS=T1.Text1>element</CODE> is zero-based,  <CODE CLASS=T1.Text1>first(seq)</CODE> is equivalent to <CODE CLASS=T1.Text1>element(seq, 0)</CODE> and <CODE CLASS=T1.Text1>seq[0]</CODE>.</P>
</DL>
<A NAME=HEADING102-163></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1729></A>second</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1730></A>Returns the second element of a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">second <I CLASS="Parameter cv Cliche">sequence #key default<B CLASS="Parameter cv Cliche"> => value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">sequence<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">default<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the second element of the <I CLASS=Cliche>sequence</I> by calling <CODE CLASS=Cliche>element</CODE> with the supplied arguments and the corresponding index.</P>
</DL>
<A NAME=HEADING102-170></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1731></A>third</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1732></A>Returns the third element of a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">third <I CLASS="Parameter cv Cliche">sequence #key default<B CLASS="Parameter cv Cliche"> =>  value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">sequence<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">default<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value<CODE CLASS="cv Parameter Cliche"> </CODE></I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the third element of the <I CLASS=Cliche>sequence</I> by calling <CODE CLASS=Cliche>element</CODE> with the supplied arguments and the corresponding index.</P>
</DL>
<A NAME=HEADING102-177></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-9-1637></A>first-setter</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1734></A>Sets the first element of a mutable sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">first-setter <I CLASS="Parameter cv Cliche">new-value mutable-sequence<B CLASS="Parameter cv Cliche"> =>  new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">mutable-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;mutable-sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Sets the first element of the <I CLASS="Parameter Cliche">mutable-sequence</I> and returns the <I CLASS=Cliche>new-value</I>, by calling <CODE CLASS=Cliche>element-setter </CODE>with the supplied arguments and the corresponding index. </P>
<P CLASS=T1.Text1>Note that because <CODE CLASS=T1.Text1>element-setter</CODE> is zero-based, <CODE CLASS=T1.Text1>first-setter(val, seq)</CODE> is equivalent to <CODE CLASS=T1.Text1>element-setter(val, seq, 0)</CODE> and <CODE CLASS=T1.Text1>seq[0] := val</CODE>.</P>
</DL>
<A NAME=HEADING102-185></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1735></A>second-setter</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1736></A>Sets the second element of a mutable sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">second-setter <I CLASS="Parameter cv Cliche">new-value  mutable-sequence<B CLASS="Parameter cv Cliche"> =>   new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">mutable-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;mutable-sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Sets the second element of the <I CLASS="Parameter Cliche">mutable-sequence</I> and returns the <I CLASS=Cliche>new-value</I>, by calling <CODE CLASS=Cliche>element-setter </CODE>with the supplied arguments and the corresponding index.</P>
</DL>
<A NAME=HEADING102-192></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1737></A>third-setter</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1738></A>Sets the third element of a mutable sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">third-setter <I CLASS="Parameter cv Cliche">new-value mutable-sequence<B CLASS="Parameter cv Cliche"> =>  new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">mutable-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;mutable-sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Sets the third element of the <I CLASS="Parameter Cliche">mutable-sequence</I> and returns the <I CLASS=Cliche>new-value</I>, by calling <CODE CLASS=Cliche>element-setter </CODE>with the supplied arguments and the corresponding index.</P>
</DL>
<A NAME=HEADING102-199></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1739></A>last</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><CODE CLASS=SD.ShortDescription><A NAME=MARKER-9-1740></A></CODE>Returns the last element of a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">last <I CLASS="Parameter cv Cliche">sequence #key default<B CLASS="Parameter cv Cliche"> =>  value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">sequence</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">default</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value</I> Zero or more instances of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the last element of <I CLASS=Cliche>sequence</I>. </P>
<P CLASS=T1.Text1>If the sequence is empty, then the behavior of <CODE CLASS=T1.Text1>last</CODE> depends on whether it was called with a <I CLASS=T1.Text1>default</I>  argument. If the <I CLASS=T1.Text1>default</I>  argument was supplied, its value is returned; otherwise, an error is signaled.</P>
</DL>
<PRE CLASS=Cv.Code>
last (#(&quot;emperor&quot;, &quot;of&quot;, &quot;china&quot;))
<CODE CLASS="cv Cv.Code"> fi</CODE>  &quot;china&quot;
</PRE>
<A NAME=HEADING102-208></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1741></A>last-setter</CODE>      [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1742></A>Sets the last element of a mutable sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">last-setter <I CLASS="Parameter cv Cliche">new-value  mutable-sequence<B CLASS="Parameter cv Cliche"> =>  new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">mutable-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;mutable-sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Replaces the last element of <I CLASS=Cliche>mutable-sequence</I>  with <I CLASS=Cliche>new-value</I>.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">mutable-sequence</I> is modified by this operation.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>new-value</I>  must obey any type restrictions for elements of <I CLASS=T1.Text1>mutable-sequence</I> . An error is signaled if <I CLASS=T1.Text1>mutable-sequence</I>  is empty or unbounded.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable my-list = list (1, 2, 3)
my-list
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(1, 2, 3)
last (my-list) := 4
<CODE CLASS="cv Cv.Code"> fi</CODE>  4
my-list
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(1, 2, 4)
define variable my-empty-vector = vector()
my-empty-vector
<CODE CLASS="cv Cv.Code"> fi</CODE>  #[]
last (my-empty-vector) := 4
{error}
</PRE>
<A NAME=HEADING102-219></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1743></A>head </CODE>[Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1744></A>Returns the head of a list.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">head <I CLASS="Parameter cv Cliche">list<B CLASS="Parameter cv Cliche">  =>  object</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">list</I> An instance of <CODE CLASS="cv Cliche">&lt;list&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the head of <I CLASS="Parameter Cliche">list</I>.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>list</I> is a pair, <CODE CLASS="cv T1.Text1">head</CODE> returns the value of the head slot. If <I CLASS=T1.Text1>list</I> is the empty list, <CODE CLASS=T1.Text1>head</CODE> returns the empty list.</P>
</DL>
<PRE CLASS=Cv.Code>
head (#(4, 5, 6))
<CODE CLASS="cv Cv.Code"> fi</CODE>  4
head (#())
<CODE CLASS="cv Cv.Code"> fi</CODE>  #()
</PRE>
<A NAME=HEADING102-227></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1745></A>tail </CODE>[Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1746></A>Returns the tail of a list.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">tail <I CLASS="Parameter cv Cliche">list<B CLASS="Parameter cv Cliche">  =>  object</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">list</I> An instance of <CODE CLASS="cv Cliche">&lt;list&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the tail of <I CLASS="Parameter Cliche">list</I>.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>list</I> is a pair, <CODE CLASS="cv T1.Text1">tail</CODE> returns the value of the tail slot. If <I CLASS=T1.Text1>list</I> is the empty list, <CODE CLASS=T1.Text1>tail</CODE> returns the empty list.</P>
</DL>
<PRE CLASS=Cv.Code>
tail (#(4, 5, 6))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(5, 6)
tail (#())
<CODE CLASS="cv Cv.Code"> fi</CODE>  #()
</PRE>
<A NAME=HEADING102-235></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1747></A>head-setter </CODE>[Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1748></A>Sets the head of a pair.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">head-setter <I CLASS="Parameter cv Cliche">object  pair<B CLASS="Parameter cv Cliche"> =>  object</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">pair</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;pair&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Sets the head of <I CLASS=Cliche>pair</I> to contain <I CLASS=Cliche>object</I> and returns <I CLASS=Cliche>object</I>.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">pair</I> is modified by this operation.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable x = list (4, 5, 6)
head (x) := 9
<CODE CLASS="cv Cv.Code"> fi</CODE>  9
x
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(9, 5, 6)
</PRE>
<A NAME=HEADING102-244></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1749></A>tail-setter </CODE>[Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1750></A>Sets the tail of a pair.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">tail-setter <I CLASS="Parameter cv Cliche">object  pair<B CLASS="Parameter cv Cliche"> =>  object</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">pair</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;pair&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Sets the tail of <I CLASS=Cliche>pair</I> to contain <I CLASS=Cliche>object</I> and returns <I CLASS=Cliche>object</I>.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">pair</I> is modified by this operation.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable x = list (4, 5, 6)
tail (x) := #(9, 8, 7)
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(9, 8, 7)
x
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(4, 9, 8, 7)
tail (x) := &quot;dot&quot;
<CODE CLASS="cv Cv.Code"> fi</CODE>  &quot;dot&quot;
x
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(4, 9, 8 . &quot;dot&quot;)<A NAME=MARKER-2-1751></A>
</PRE>
<A NAME=HEADING102-253></A>
<A NAME="UID-Built-In_Functions-29552"></A>
<H2 CLASS=H2.Heading2> Adding and Removing Elements</H2>
<A NAME=HEADING102-254></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1752></A><A NAME=MARKER-2-1753></A>add </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1754></A>Adds an element to a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">add <I CLASS="Parameter cv Cliche">source-sequence new-element<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">new-element</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence that contains <I CLASS=Cliche>new-element</I> and all the elements of <I CLASS=Cliche>source-sequence</I>. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated. It may share structure with a preexisting sequence.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>source-sequence</I> is not modified by this operation. </P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">result-sequence</I>'s size is one greater than the size of <I CLASS=T1.Text1>source-sequence</I>. The generic function <CODE CLASS=T1.Text1>add</CODE> doesn't specify where the new element will be added, although individual methods may do so.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable *numbers* = #(3, 4, 5)
add (*numbers*, 1)
  =>  #(1, 3, 4, 5) 
*numbers*
  =>  #(3, 4, 5)
</PRE>
<A NAME=HEADING102-264></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1755></A>add! </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1756></A>Adds an element to a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">add! <I CLASS="Parameter cv Cliche">source-sequence new-element<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">new-element</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence that contains <I CLASS=Cliche>new-element</I> and all the elements of <I CLASS=Cliche>source-sequence</I>. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated. It may share structure with a preexisting sequence. <I CLASS="Parameter Cliche">source-sequence</I> and <I CLASS="Parameter Cliche">result-sequence</I> may or may not be <CODE CLASS="cv Cliche">==</CODE>.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>source-sequence</I> may be modified by this operation.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">result-sequence</I>'s size is one greater than the size of <I CLASS=T1.Text1>source-sequence</I>. The generic function <CODE CLASS=T1.Text1>add!</CODE> doesn't specify where the new element will be added, although individual methods may do so.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable *numbers* = list (3, 4, 5)
add! (*numbers*, 1)
  =>  #(1, 3, 4, 5)
*numbers*
  => {undefined}
</PRE>
<A NAME=HEADING102-274></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>add!   deque new-value  fi</CODE> deque [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The result of <CODE CLASS=T1.Text1>add!</CODE> on a deque is <CODE CLASS=T1.Text1>==</CODE> to the <I CLASS=T1.Text1>deque</I> argument, which is modified by this operation. <CODE CLASS=T1.Text1>add!<I CLASS=T1.Text1> </I></CODE>adds <I CLASS=T1.Text1>new-element</I> at the beginning of the <I CLASS=T1.Text1>deque</I>.</P>
<A NAME=HEADING102-276></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>add!   stretchy-vector new-element  fi</CODE> stretchy-vector [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The result of <CODE CLASS="cv T1.Text1">add!</CODE> on a stretchy vector is <CODE CLASS=T1.Text1>==</CODE> to the <I CLASS=T1.Text1>stretchy-vector</I> argument, which is modified by this operation. <CODE CLASS=T1.Text1>add!<I CLASS=T1.Text1> </I></CODE>adds <I CLASS=T1.Text1>new-element</I> at the end of the <I CLASS=T1.Text1>stretchy-vector</I>.</P>
<A NAME=HEADING102-278></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>add!   list element fi</CODE>  pair [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The result of <CODE CLASS="cv T1.Text1">add!</CODE> on a list is equivalent to<CODE CLASS="cv T1.Text1"> (pair <I CLASS="Parameter cv T1.Text1">element list)</I></CODE>. The result will share structure with the <I CLASS="Parameter T1.Text1">list</I> argument, but it will not be <CODE CLASS="cv T1.Text1">==</CODE> to the argument, and the argument will not be modified.</P>
<A NAME=HEADING102-280></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1757></A>add-new</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1758></A>Adds a new element to a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">add-new <I CLASS="Parameter cv Cliche">source-sequence new-element #key test<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">new-element</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Adds <I CLASS="Parameter Cliche">new-element</I> to source-sequence if it is not already an element of <I CLASS="Parameter Cliche">source-sequence</I>, as determined by the <I CLASS=Cliche>test</I> function. If <I CLASS=Cliche>new-element</I> is already a member of <I CLASS=Cliche>source-sequence</I>, then <I CLASS=Cliche>source-sequence</I> is returned unmodified.</P>
<P CLASS=T1.Text1>If an element is added, <CODE CLASS=T1.Text1>add-new</CODE> operates just as <CODE CLASS=T1.Text1>add</CODE> would. </P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>test</I> function may be noncommutative: it is always called with an element from <I CLASS=T1.Text1>source-sequence</I> as its first argument and <I CLASS=T1.Text1>new-element</I>  as its second argument.</P>
</DL>
<PRE CLASS=Cv.Code>
add-new (#(3, 4, 5), 1)
  =>  #(1, 3, 4, 5)
add-new (#(3, 4, 5), 4)
  =>  #(3, 4, 5)
</PRE>
<A NAME=HEADING102-291></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1759></A>add-new!</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1760></A>Adds a new element to a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">add-new! <I CLASS="Parameter cv Cliche">source-sequence new-element #key test<B CLASS="Parameter cv Cliche">  => result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">new-element</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">result-sequence</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Adds <I CLASS="Parameter Cliche">new-element</I> to source-sequence if it is not already an element of <I CLASS="Parameter Cliche">source-sequence</I>, as determined by the <I CLASS=Cliche>test</I> function. If <I CLASS=Cliche>new-element</I> is already a member of <I CLASS=Cliche>source-sequence</I>, then <I CLASS=Cliche>source-sequence</I> is returned unmodified.</P>
<P CLASS=T1.Text1>If an element is added, <CODE CLASS=T1.Text1>add-new!</CODE> operates just as <CODE CLASS=T1.Text1>add!</CODE> would. </P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>test</I> function may be noncommutative: it is always called with an element from <I CLASS=T1.Text1>sequence</I> as its first argument and <I CLASS=T1.Text1>new-element</I>  as its second argument.</P>
</DL>
<PRE CLASS=Cv.Code>
add-new! (list (3, 4, 5), 1)
  =>  #(1, 3, 4, 5)
add-new! (list (3, 4, 5), 4)
  =>  #(3, 4, 5)
</PRE>
<A NAME=HEADING102-302></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1761></A>remove </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-1762></A><A NAME=MARKER-9-1763></A>Removes an element from a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">remove <I CLASS="Parameter cv Cliche">source-sequence value #key test count<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">count</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE> or <CODE CLASS="cv RP.RoutineParam">#f</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">#f</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence consisting of the elements of <I CLASS=Cliche>source-sequence</I> not equal to <I CLASS=Cliche>value</I>. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated. However, the <I CLASS="Parameter Cliche">source-sequence</I> is never modified by <CODE CLASS="cv Cliche">remove</CODE>.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>test</I> is a function that determines whether an element is equal to <I CLASS=T1.Text1>value</I>. The <I CLASS=T1.Text1>test</I> function may be noncommutative: it is always called with an element from <I CLASS=T1.Text1>source-sequence</I> as its first argument and <I CLASS=T1.Text1>value</I>  as its second argument.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>count</I> is <CODE CLASS="cv T1.Text1">#f</CODE>, then all copies of <I CLASS="Parameter T1.Text1">value</I> are removed. Otherwise, no more than <I CLASS=T1.Text1>count</I> copies of <I CLASS=T1.Text1>value</I> are removed (so additional elements equal to <I CLASS=T1.Text1>value</I> might remain in <I CLASS="Parameter T1.Text1">result-sequence</I>).</P>
</DL>
<PRE CLASS=Cv.Code>
define variable *old-list* = list(1, 2, 3)
define variable *new-list* = remove(*old-list*, 1)
*new-list*
  =>  #(2, 3)
*new-list* == tail(*old-list*)
  =>  {undefined}
</PRE>
<A NAME=HEADING102-314></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1764></A>remove!</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1765></A>Removes an element from a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">remove! <I CLASS="Parameter cv Cliche">source-sequence value #key test count<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">count</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE> or <CODE CLASS="cv RP.RoutineParam">#f</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">#f</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence consisting of the elements of <I CLASS=Cliche>source-sequence</I> not equal to <I CLASS=Cliche>value</I>. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated, may or may not be <CODE CLASS="cv Cliche">==</CODE> to the <I CLASS="Parameter Cliche">source-sequence</I>, and may or may not share structure with the <I CLASS="Parameter Cliche">source-sequence</I>. The <I CLASS="Parameter Cliche">source-sequence</I> may be modified by <CODE CLASS="cv Cliche">remove!</CODE>.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>test</I> is a function that determines whether an element is equal to <I CLASS=T1.Text1>value</I>. The <I CLASS=T1.Text1>test</I> function may be noncommutative: it is always called with an element from <I CLASS=T1.Text1>source-sequence</I> as its first argument and <I CLASS=T1.Text1>value</I>  as its second argument.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>count</I> is <CODE CLASS="cv T1.Text1">#f</CODE>, then all copies of <I CLASS="Parameter T1.Text1">value</I> are removed. Otherwise, no more than <I CLASS=T1.Text1>count</I> copies of <I CLASS=T1.Text1>value</I> are removed (so additional elements equal to <I CLASS=T1.Text1>value</I> might remain in <I CLASS="Parameter T1.Text1">result-sequence</I>).</P>
</DL>
<A NAME=HEADING102-325></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>remove!   deque value #key test count   fi</CODE> deque [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The result of <CODE CLASS=T1.Text1>remove!</CODE> on a deque is <CODE CLASS=T1.Text1>==</CODE> to the <I CLASS=T1.Text1>deque</I> argument. The argument is modified by this operation.</P>
<A NAME=HEADING102-327></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>remove!   stretchy-vector element #key test count  </CODE> [Sealed G.F. Method]<BR>=> stretchy-vector</H4>
<P CLASS=T1.Text1>The result of <CODE CLASS=T1.Text1>remove!</CODE> on a stretchy vector is <CODE CLASS=T1.Text1>==</CODE> to the <I CLASS=T1.Text1>stretchy-vector</I> argument. The argument is modified by this operation.</P>
<A NAME=HEADING102-329></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>remove!   list element #key test count  fi</CODE>  list [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The result of <CODE CLASS=T1.Text1>remove!</CODE> on a list may or may not be <CODE CLASS=T1.Text1>==</CODE> to the <I CLASS=T1.Text1>list</I> argument. The argument may be modified by this operation.</P>
<A NAME=HEADING102-331></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1766></A>push</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1767></A>Adds an element to the front of a deque.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">push <I CLASS="Parameter cv Cliche">deque new-value<B CLASS="Parameter cv Cliche">  => new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">deque</I> An instance of <CODE CLASS="cv Cliche">&lt;deque&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">new-value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">new-value</I> An instance of <CODE CLASS="cv Cliche2">&lt;object&gt;</CODE>. The same object that was passed in as an argument. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Augments <I CLASS=Cliche>deque</I> by adding <I CLASS=Cliche>new-value</I> to its front.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">deque</I> is modified by this operation.</P>
</DL>
<A NAME=HEADING102-339></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1768></A>pop</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1769></A>Removes and returns the first element of a deque.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">pop <I CLASS="Parameter cv Cliche">deque<B CLASS="Parameter cv Cliche">  => first-element</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">deque</I> An instance of <CODE CLASS="cv Cliche">&lt;deque&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">first-element</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Removes the first element from <I CLASS=Cliche>deque</I> and returns it.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">deque</I> is modified by this operation. </P>
</DL>
<A NAME=HEADING102-346></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1770></A>push-last</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1771></A>Adds an element to the end of a deque.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">push-last <I CLASS="Parameter cv Cliche">deque new-value<B CLASS="Parameter cv Cliche">  => new-value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">deque</I> An instance of <CODE CLASS="cv Cliche">&lt;deque&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">new-value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">new-value</I> An instance of <CODE CLASS="cv Cliche2">&lt;object&gt;</CODE>. The same object that was passed in as an argument.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Augments <I CLASS=Cliche>deque</I> by adding <I CLASS=Cliche>new-value</I> to its end.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">deque</I> is modified by this operation. </P>
</DL>
<A NAME=HEADING102-354></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1772></A>pop-last</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1773></A>Removes and returns an element from the end of a deque.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">pop-last <I CLASS="Parameter cv Cliche">deque<B CLASS="Parameter cv Cliche">  => last-element</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">deque</I> An instance of <CODE CLASS="cv Cliche">&lt;deque&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">last-element</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Removes the last element from <I CLASS=Cliche>deque</I> and returns it.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">deque</I> is modified by this operation. <A NAME=MARKER-2-1774></A><A NAME=MARKER-2-1775></A></P>
</DL>
<A NAME=HEADING102-361></A>
<A NAME="UID-Built-In_Functions-9856"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-1776></A>Reordering Elements</H2>
<A NAME=HEADING102-362></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1777></A>reverse</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1778></A>Returns a sequence with elements in the reverse order of its argument sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">reverse <I CLASS="Parameter cv Cliche">source-sequence<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence </I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing the same elements as <I CLASS=Cliche>source-sequence</I>, but in reverse order. The <I CLASS="Parameter Cliche">result-sequence</I> is generally of the same class as the <I CLASS=Cliche>source-sequence</I>.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">result-sequence</I> may or may not be freshly allocated. The <I CLASS="Parameter T1.Text1">source-sequence</I> is not modified by this operation.</P>
<P CLASS=T1.Text1>The consequences are undefined if the <I CLASS="Parameter T1.Text1">source-sequence</I> is unbounded (circular or infinite).</P>
</DL>
<PRE CLASS=Cv.Code>
define variable *x* = list(&quot;bim&quot;, &quot;bam&quot;, &quot;boom&quot;)
*x*
  =>  #(&quot;bim&quot;, &quot;bam&quot;, &quot;boom&quot;)
reverse(*x*)
  =>  #(&quot;boom&quot;, &quot;bam&quot;, &quot;bim&quot;)
*x*
  =>  #(&quot;bim&quot;, &quot;bam&quot;, &quot;boom&quot;)
</PRE>
<A NAME=HEADING102-371></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>reverse   range fi</CODE>  new-range [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>Reversing a range produces another range. An unbounded range cannot be reversed.</P>
<A NAME=HEADING102-373></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1779></A>reverse!</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1780></A>Returns a sequence with elements in the reverse order of its argument sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">reverse! <I CLASS="Parameter cv Cliche">source-sequence<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing the same elements as <I CLASS=Cliche>source-sequence</I>, but in reverse order. The <I CLASS="Parameter Cliche">result-sequence</I> is generally of the same class as the <I CLASS=Cliche>source-sequence</I>.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">source-sequence</I> may be modified by this operation. The <I CLASS="Parameter T1.Text1">result-sequence</I> may or may not be freshly allocated. The <I CLASS="Parameter T1.Text1">source-sequence</I> and the <I CLASS="Parameter T1.Text1">result-sequence</I> may or may not be <CODE CLASS="cv T1.Text1">==</CODE>. Programs should never rely on this operation performing a side-effect on an existing sequence, but should instead use the value returned by the function.</P>
<P CLASS=T1.Text1>The consequences are undefined if the <I CLASS="Parameter T1.Text1">source-sequence</I> is unbounded (circular or infinite).</P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>define variable *x* = list(&quot;bim&quot;, &quot;bam&quot;, &quot;boom&quot;)<BR>*x*<BR>  =>  #(&quot;bim&quot;, &quot;bam&quot;, &quot;boom&quot;)<BR>reverse!(*x*)<BR>  =>  #(&quot;boom&quot;, &quot;bam&quot;, &quot;bim&quot;)<BR>*x*<BR>  => {undefined}</CODE></P>
</DL>
<A NAME=HEADING102-382></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>reverse!   range fi</CODE>  range [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>The result of <CODE CLASS=T1.Text1>reverse!</CODE> on a range is <CODE CLASS=T1.Text1>==</CODE> to the <I CLASS=T1.Text1>range</I> argument. An unbounded range cannot be reversed.</P>
<A NAME=HEADING102-384></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1781></A>sort</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1782></A>Returns a sequence containing the elements of its argument sequence, sorted.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">sort <I CLASS="Parameter cv Cliche">source-sequence #key test stable<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">&lt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">stable</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>, treated as a boolean.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing the elements of <I CLASS=Cliche>source-sequence</I> sorted into ascending order. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated. The <I CLASS="Parameter Cliche">source-sequence</I> is not modified by this operation.</P>
<P CLASS=T1.Text1><CODE CLASS="cv T1.Text1">sort</CODE> determines the relationship between two elements by giving elements to the <I CLASS="Parameter T1.Text1">test</I>. The first argument to the <I CLASS="Parameter T1.Text1">test</I> function is one element of <I CLASS="Parameter T1.Text1">source-sequence</I>; the second argument is another element of <I CLASS="Parameter T1.Text1">source-sequence</I>. <I CLASS="Parameter T1.Text1">test</I> should return true if and only if the first argument is strictly less than the second (in some appropriate sense). If the first argument is greater than or equal to the second (in the appropriate sense), then the <I CLASS="Parameter T1.Text1">test</I> should return  <CODE CLASS="cv T1.Text1">#f</CODE>.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>stable</I> is supplied and not <CODE CLASS="cv T1.Text1">#f</CODE>, a possibly slower algorithm will be used that will leave in their original order any two elements, <I CLASS=T1.Text1>x</I> and <I CLASS=T1.Text1>y</I>, such that <I CLASS=T1.Text1>test(x, y)</I> and <I CLASS=T1.Text1>test(y, x)</I> are both false.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable *numbers* = vector(3, 1, 4, 1, 5, 9)
*numbers*
  => #[3, 1, 4, 1, 5, 9]
sort (*numbers*)
  =>  #[1, 1, 3, 4, 5, 9]
*numbers*
  =>  #[3, 1, 4, 1, 5, 9]
</PRE>
<A NAME=HEADING102-395></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1783></A>sort!</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1784></A>Returns a sequence containing the elements of its argument sequence, sorted.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">sort! <I CLASS="Parameter cv Cliche">source-sequence #key test stable<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">&lt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">stable</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>, treated as a boolean.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing the elements of <I CLASS=Cliche>source-sequence</I> sorted into ascending order. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated. The <I CLASS="Parameter Cliche">source-sequence</I> may be modified by this operation. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be <CODE CLASS="cv Cliche">==</CODE> to <I CLASS="Parameter Cliche">source-sequence</I>. After this operation, the contents of <I CLASS="Parameter Cliche">source-sequence</I> are undefined.</P>
<P CLASS=T1.Text1>Programs should never rely on this operation performing a side-effect on an existing sequence, but should instead use the value returned by the function.</P>
<P CLASS=T1.Text1><CODE CLASS="cv T1.Text1">sort!</CODE> determines the relationship between two elements by giving elements to the <I CLASS="Parameter T1.Text1">test</I>. The first argument to the <I CLASS="Parameter T1.Text1">test</I> function is one element of <I CLASS="Parameter T1.Text1">source-sequence</I>; the second argument is another element of <I CLASS="Parameter T1.Text1">source-sequence</I>. <I CLASS="Parameter T1.Text1">test</I> should return true if and only if the first argument is strictly less than the second (in some appropriate sense). If the first argument is greater than or equal to the second (in the appropriate sense), then the <I CLASS="Parameter T1.Text1">test</I> should return  <CODE CLASS="cv T1.Text1">#f</CODE>.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>stable</I> is supplied and not <CODE CLASS="cv T1.Text1">#f</CODE>, a possibly slower algorithm will be used that will leave in their original order any two elements, <I CLASS=T1.Text1>x</I> and <I CLASS=T1.Text1>y</I>, such that <I CLASS=T1.Text1>test(x, y)</I> and <I CLASS=T1.Text1>test(y, x)</I> are both false.</P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>define variable *numbers* = vector(3, 1, 4, 1, 5, 9)<BR>*numbers*<BR>  => #[3, 1, 4, 1, 5, 9]<BR>sort! (*numbers*)<BR>  =>  #[1, 1, 3, 4, 5, 9]<BR>*numbers*<BR>  =>  {undefined}<A NAME=MARKER-2-1785></A></CODE></P>
</DL>
<A NAME=HEADING102-407></A>
<A NAME="UID-Built-In_Functions-2737"></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-2-1786></A>Set Operations</H2>
<A NAME=HEADING102-408></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1787></A>intersection</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1788></A>Returns the intersection of two sequences.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">intersection <I CLASS="Parameter cv Cliche">sequence1 sequence2<B CLASS="Parameter cv Cliche"> #key test  =>  new-sequence</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">sequence1</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">sequence2</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-sequence</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a new sequence containing only those elements of <I CLASS=Cliche>sequence1</I> that also appear in <I CLASS=Cliche>sequence2</I>.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>test</I>  is used to determine whether an element appears in <I CLASS=T1.Text1>sequence2</I>. It is always called with an element of <I CLASS=T1.Text1>sequence1</I>  as its first argument and an element from <I CLASS=T1.Text1>sequence2</I>  as its second argument. The order of elements in the result sequence is not specified.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">new-sequence</I> may or may not share structure with the <I CLASS="Parameter T1.Text1">sequence1</I> and <I CLASS="Parameter T1.Text1">sequence2</I>.</P>
</DL>
<PRE CLASS=Cv.Code>
? intersection (#(&quot;john&quot;, &quot;paul&quot;, &quot;george&quot;, &quot;ringo&quot;),
                #(&quot;richard&quot;, &quot;george&quot;, &quot;edward&quot;, &quot;charles&quot;),
                test: \=)
#(&quot;george&quot;)
</PRE>
<A NAME=HEADING102-419></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>intersection   range1 range2 </CODE> <CODE CLASS=H5.Heading5>#key</CODE> test =>  range [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>intersection</CODE> applied to two ranges and a test of <CODE CLASS=T1.Text1>==</CODE> (the default) will produce another range as its result, even though the <CODE CLASS=T1.Text1>type-for-copy</CODE> of a range is not <CODE CLASS=T1.Text1>&lt;range&gt;</CODE>. If either <I CLASS=T1.Text1>range1</I> or <I CLASS=T1.Text1>range2</I> is unbounded, this method is guaranteed to terminate only if the <I CLASS=T1.Text1>test</I> is <CODE CLASS=T1.Text1>==</CODE>.</P>
<A NAME=HEADING102-421></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1789></A>union </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1790></A>Returns the union of two sequences.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">union <I CLASS="Parameter cv Cliche">sequence1 sequence2<B CLASS="Parameter cv Cliche"> #key test  =>  new-sequence</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">sequence1</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">sequence2</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-sequence</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing every element of <I CLASS=Cliche>sequence1</I> and <I CLASS=Cliche>sequence2</I>.</P>
<P CLASS=T1.Text1>If the same element appears in both argument sequences, this will not cause it to appear twice in the result sequence. However, if the same element appears more than once in a single argument sequence, it may appear more than once in the result sequence.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>test</I> is used for all comparisons. It is always called with an element from <I CLASS=T1.Text1>sequence1</I>  as its first argument and an element from <I CLASS=T1.Text1>sequence2</I>  as its second argument. The order of elements in the <I CLASS="Parameter T1.Text1">new-sequence</I> is not specified.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">new-sequence</I> may or may not share structure with <I CLASS="Parameter T1.Text1">sequence1</I> or <I CLASS="Parameter T1.Text1">sequence2</I>. </P>
</DL>
<PRE CLASS=Cv.Code>
union (#(&quot;butter&quot;, &quot;flour&quot;, &quot;sugar&quot;, &quot;salt&quot;, &quot;eggs&quot;),
       #(&quot;eggs&quot;, &quot;butter&quot;, &quot;mushrooms&quot;, &quot;onions&quot;, &quot;salt&quot;),
       test: \=)
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(&quot;salt&quot;, &quot;butter&quot;, &quot;flour&quot;, &quot;sugar&quot;, &quot;eggs&quot;,
       &quot;mushrooms&quot;, &quot;onions&quot;)
</PRE>
<A NAME=HEADING102-433></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1791></A>remove-duplicates</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1792></A>Returns a sequence without duplicates.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">remove-duplicates <I CLASS="Parameter cv Cliche">source-sequence<B CLASS="Parameter cv Cliche"> #key test  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence that contains all the unique elements from <I CLASS=Cliche>source-sequence</I> but no duplicate elements.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>test</I>  is the function used to determine whether one element is a duplicate of another. The <I CLASS=T1.Text1>test</I> argument may be noncommutative; it will always be called with its arguments in the same order as they appear in <I CLASS=T1.Text1>source-sequence</I>.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">result-sequence</I> may or may not be freshly allocated. However, the <I CLASS="Parameter T1.Text1">source-sequence</I> will not be modified by this operation.</P>
</DL>
<PRE CLASS=Cv.Code>
remove-duplicates (#(&quot;spam&quot;, &quot;eggs&quot;, &quot;spam&quot;, 
                     &quot;sausage&quot;, &quot;spam&quot;, &quot;spam&quot;),
                    test: \=)
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(&quot;spam&quot;, &quot;eggs&quot;, &quot;sausage&quot;)
or
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(&quot;eggs&quot;, &quot;spam&quot;, &quot;sausage&quot;)
or
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(&quot;eggs&quot;, &quot;sausage&quot;, &quot;spam&quot;)
</PRE>
<A NAME=HEADING102-443></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1793></A>remove-duplicates!</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1794></A>Returns a sequence without duplicates.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">remove-duplicates! <I CLASS="Parameter cv Cliche">source-sequence<B CLASS="Parameter cv Cliche"> #key test  => result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">source-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence that contains all the unique elements from <I CLASS=Cliche>source-sequence</I> but no duplicate elements.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>test</I>  is the function used to determine whether one element is a duplicate of another. The <I CLASS=T1.Text1>test</I> argument may be noncommutative; it will always be called with its arguments in the same order as they appear in <I CLASS=T1.Text1>source-sequence</I>.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">result-sequence</I> may or may not be freshly allocated, may or may not share structure with the <I CLASS=T1.Text1>source-sequence</I>, and may or may not be <CODE CLASS="cv T1.Text1">==</CODE> to the <I CLASS=T1.Text1>source-sequence</I>. The <I CLASS=T1.Text1>source-sequence</I> may or may not be modified by the operation. </P>
</DL>
<PRE CLASS=Cv.Code>
define variable *menu* = #(&quot;spam&quot;, &quot;eggs&quot;, &quot;spam&quot;, 
                           &quot;sausage&quot;, &quot;spam&quot;, &quot;spam&quot;)
remove-duplicates! (*menu*, test: \=)
  =>  #(&quot;spam&quot;, &quot;eggs&quot;, &quot;sausage&quot;)
or
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(&quot;eggs&quot;, &quot;spam&quot;, &quot;sausage&quot;)
or
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(&quot;eggs&quot;, &quot;sausage&quot;, &quot;spam&quot;)
*menu*
  =>  {undefined}<A NAME=MARKER-2-1795></A>
</PRE>
<A NAME=HEADING102-453></A>
<A NAME="UID-Built-In_Functions-2699"></A>
<H2 CLASS=H2.Heading2> Subsequence Operations</H2>
<A NAME=HEADING102-454></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1796></A>copy-sequence </CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1797></A><A NAME=MARKER-2-1798></A>Returns a freshly allocated copy of some subsequence of a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">copy-sequence   <I CLASS="Parameter cv Cliche">source<B CLASS="Parameter cv Cliche"> #key start end  =>  new-sequence</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">source</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">start</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">0</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">end</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>. The default is the size of <I CLASS="Parameter RP.RoutineParam">source</I>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">new-sequence</I> A freshly allocated instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Creates a freshly allocated sequence containing the elements of <I CLASS=Cliche>source</I> between <I CLASS=Cliche>start</I> and <I CLASS=Cliche>end</I>.</P>
</DL>
<PRE CLASS=Cv.Code>
define constant hamlet = #(&quot;to&quot;, &quot;be&quot;, &quot;or&quot;, &quot;not&quot;, &quot;to&quot;, &quot;be&quot;)
hamlet == copy-sequence (hamlet)
<CODE CLASS="cv Cv.Code"> fi</CODE>  #f
copy-sequence (hamlet, start: 2, end: 4)
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(&quot;or&quot;, &quot;not&quot;)
</PRE>
<A NAME=HEADING102-463></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>copy-sequence</CODE>   range <CODE CLASS=H5.Heading5>#key start end fi</CODE>  new-range [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>When applied to a range, <CODE CLASS=T1.Text1>copy-sequence</CODE> returns another range, even though the <CODE CLASS=T1.Text1>type-for-copy</CODE> of a range is the <CODE CLASS=T1.Text1>&lt;list&gt;</CODE> class.</P>
<A NAME=HEADING102-465></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1799></A>concatenate</CODE>  [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1800></A>Returns the concatenation of one or more sequences in a sequence of a type determined by the <CODE CLASS="cv SD.ShortDescription">type-for-copy</CODE> of its first argument.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">concatenate <I CLASS="Parameter cv Cliche">first-sequence<B CLASS="Parameter cv Cliche"> #rest more-sequences  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">first-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-sequences</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing all the elements of all the sequences, in order.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">result-sequence</I> will be an instance of the <CODE CLASS="cv T1.Text1">type-for-copy</CODE> value for <I CLASS="Parameter T1.Text1">first-sequence</I>. It may or may not be freshly allocated. The <I CLASS="Parameter T1.Text1">result-sequence</I> may be created by calling <CODE CLASS="cv T1.Text1">make</CODE> on the indicated type, with a <CODE CLASS=T1.Text1>size:</CODE> initialization argument whose value is the sum of the sizes of the argument sequences. (For this reason, the <CODE CLASS="cv T1.Text1">type-for-copy</CODE> value of <I CLASS="Parameter T1.Text1">first-sequence</I> must support the <CODE CLASS="cv T1.Text1">size:</CODE> init-keyword.)</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>new-sequence</I> may share structure with any of the argument sequences, but it is not guaranteed to do so.  The argument sequences will not be modified by this operation.</P>
</DL>
<PRE CLASS=Cv.Code>
concatenate (&quot;low-&quot;, &quot;calorie&quot;)
<CODE CLASS="cv Cv.Code"> fi</CODE>  &quot;low-calorie&quot;
</PRE>
<A NAME=HEADING102-475></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1801></A>concatenate-as    </CODE>[Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1802></A>Returns the concatenation of one or more sequences in a sequence of a specified type.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">concatenate-as <I CLASS="Parameter cv Cliche">type first-sequence<B CLASS="Parameter cv Cliche"> #rest more-sequences =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">type</I> An instance of <CODE CLASS="cv Cliche2">&lt;type&gt;</CODE>, which must be a subtype of <CODE CLASS="cv Cliche2">&lt;mutable-sequence&gt;</CODE></P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">first-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam>  An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-sequences</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence</I> An instance of <I CLASS="Parameter Cliche2">type</I>, and therefore also an instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing all the elements of all the sequences, in order.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">result-sequence</I> will be an instance of <I CLASS="Parameter T1.Text1">type</I>. It may or may not be freshly allocated.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>type</I> must be a subtype of <CODE CLASS=T1.Text1>&lt;mutable-sequence&gt;</CODE> and acceptable as the first argument to <CODE CLASS=T1.Text1>make</CODE>. <CODE CLASS=T1.Text1>size:</CODE> with a non-negative integer value must be an acceptable initarg for <CODE CLASS="cv T1.Text1">make</CODE> of <I CLASS="Parameter T1.Text1">type</I>. The <I CLASS="Parameter T1.Text1">result-sequence</I> may be created by calling <CODE CLASS=T1.Text1>make</CODE> on <I CLASS="Parameter T1.Text1">type</I>, with a <CODE CLASS=T1.Text1>size: </CODE>initialization argument whose value is the sum of the sizes of the arguments.</P>
</DL>
<PRE CLASS=Cv.Code>
concatenate-as (&lt;string&gt;, #('n', 'o', 'n'), #('f', 'a', 't'))
<CODE CLASS="cv Cv.Code"> fi</CODE>  &quot;nonfat&quot;
</PRE>
<A NAME=HEADING102-486></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1803></A>replace-subsequence!</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1804></A>Replaces a portion of a sequence with the elements of another sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">replace-subsequence! <I CLASS="Parameter cv Cliche">target-sequence insert-sequence #key start end<BR>fi</I></CODE>   <I CLASS="Parameter Cliche">result-sequence</I></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">target-sequence</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">insert-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">start</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">0</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">end</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>. The default is the size of <I CLASS="Parameter RP.RoutineParam">target-sequence</I>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">result-sequence </I>An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">replace-subsequence!</CODE> returns a sequence with the same elements as <I CLASS=Cliche>target-sequence</I>, except that elements of the indicated subsequence of <I CLASS="Parameter Cliche">target-sequence</I> are replaced by all the elements of  <I CLASS=Cliche>insert-sequence</I>. The subsequence to be overridden begins at index <I CLASS=Cliche>start</I> and ends at index <I CLASS=Cliche>end</I>.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>result-sequence</I>  may or may not share structure with <I CLASS=T1.Text1>source-sequence</I> or <I CLASS=T1.Text1>insert-sequence</I>, and it may or may not be <CODE CLASS=T1.Text1>==</CODE> to <I CLASS=T1.Text1>source-sequence</I> or <I CLASS=T1.Text1>insert-sequence</I>. <I CLASS=T1.Text1>source-sequence</I>  may or may not be modified by the operation. <I CLASS=T1.Text1>insert-sequence</I> will not be modified by this operation.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable *original* = list (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)
*new* := replace-subsequence! (*original*, #(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), end: 1))
    #(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)
*new* := replace-subsequence! (*new*, #(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), start: 4))
    #(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;b&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
*new* := replace-subsequence! (*new*, #(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), 
                                      start: 2, end: 4))
    #(&quot;x&quot;, &quot;y&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
</PRE>
<A NAME=HEADING102-500></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1805></A>subsequence-position</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1806></A>Returns the position where a pattern appears in a sequence.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">subsequence-position   <I CLASS="Parameter cv Cliche">big pattern<B CLASS="Parameter cv Cliche"> #key test count  =>  index</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">big</I> An instance of <CODE CLASS="cv Cliche">&lt;sequence&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">pattern</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">count</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">1</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">index</I> <CODE CLASS="cv Cliche">#f</CODE> or an instance of <CODE CLASS="cv Cliche">&lt;integer&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Searches <I CLASS=Cliche>big</I> for a subsequence that is element-for-element equal to <I CLASS=Cliche>pattern</I>, as determined by the <I CLASS=Cliche>test</I> argument.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>test</I> is applied to elements of successive subsequences of <I CLASS=T1.Text1>big</I> and corresponding elements of the <I CLASS=T1.Text1>pattern</I> to determine whether a match has occurred. If a subsequence is found, <CODE CLASS="cv T1.Text1">subsequence-position</CODE> returns the index at which the subsequence starts; otherwise, it returns <CODE CLASS=T1.Text1>#f</CODE>. If there is more than one match, <I CLASS=T1.Text1>count</I> determines which subsequence is selected. A <I CLASS="Parameter T1.Text1">count</I> of 1 (the default) indicates that the first match should be returned.</P>
</DL>
<PRE CLASS=Cv.Code>
subsequence-position (&quot;Ralph Waldo Emerson&quot;, &quot;Waldo&quot;)
<CODE CLASS="cv Cv.Code"> fi</CODE>  6 
</PRE>
<A NAME=HEADING102-511></A>
<A NAME="UID-Built-In_Functions-3007"></A>
<H2 CLASS=H2.Heading2> Mapping and Reducing</H2>
<A NAME=HEADING102-512></A>
<H3 CLASS=H3.Heading3> Simple Mapping</H3>
<P CLASS=T0.Text0><A NAME=MARKER-2-1807></A><A NAME=MARKER-2-1808></A>The following mapping functions (<CODE CLASS="cv T0.Text0">do</CODE>, <CODE CLASS="cv T0.Text0">map</CODE>, <CODE CLASS="cv T0.Text0">map-as</CODE>, <CODE CLASS="cv T0.Text0">map-into</CODE>, <CODE CLASS="cv T0.Text0">any?</CODE>, <CODE CLASS="cv T0.Text0">every?</CODE>) iterate over a number of source collections. Each time through the iteration, a function is applied to one element from each of the source collections. The number of arguments to the function is equal to the number of source collections.</P>
<P CLASS=T1.Text1>The functions vary in how they handle the results of each function application.</P>
<A NAME=HEADING102-515></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1809></A>do</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1810></A>Iterates over one or more collections for side effect.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">do <I CLASS="Parameter cv Cliche">function collection #rest more-collections  fi<B CLASS="Parameter cv Cliche">  false</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">function</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-collections</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">false</I> <CODE CLASS="cv Cliche">#f</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Applies <I CLASS=Cliche>function</I> to corresponding elements of all the <I CLASS="Parameter Cliche">collections</I> and returns <CODE CLASS=Cliche>#f</CODE>. If all the <I CLASS="Parameter Cliche">collections</I> are sequences, <CODE CLASS=Cliche>do</CODE> guarantees that they will be processed in their natural order.</P>
</DL>
<PRE CLASS=Cv.Code>
do (method (a b) print (a + b) end,
    #(100, 100, 200, 200),
    #(1, 2, 3, 4))
101
102
203
204
<CODE CLASS="cv Cv.Code"> fi</CODE>  #f
</PRE>
<A NAME=HEADING102-524></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1811></A>map</CODE>   [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1812></A>Iterates over one or more collections and collects the results in a freshly allocated collection.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">map   <I CLASS="Parameter cv Cliche">function collection #rest more-collections<B CLASS="Parameter cv Cliche">  =>  new-collection</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">function</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-collections</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of  <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-collection</I> A freshly allocated instance of <CODE CLASS="cv Cliche">&lt;collection&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Creates a freshly allocated collection whose elements are obtained by calling <I CLASS=Cliche>function</I> on corresponding elements of all the <I CLASS="Parameter Cliche">collections</I>. If all the <I CLASS="Parameter Cliche">collections</I> are sequences, processing is performed in the natural order.</P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>map</CODE> returns a collection whose value is an instance of the <CODE CLASS=T1.Text1>type-for-copy</CODE> value of <I CLASS=T1.Text1>collection</I>. The new collection is created by calling <CODE CLASS="cv T1.Text1">make</CODE> on that type, with a <CODE CLASS="cv T1.Text1">size:</CODE> initialization argument whose value is the number of corresponding elements in the <I CLASS="Parameter T1.Text1">collections</I>.</P>
</DL>
<PRE CLASS=Cv.Code>
map (\+,
     #(100, 100, 200, 200),
     #(1, 2, 3, 4))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(101, 102, 203, 204)
</PRE>
<A NAME=HEADING102-534></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1813></A>map-as</CODE> [Function] </H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1814></A>Iterates over one or more collections and collects the results in a freshly allocated collection of a specified type.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">map-as <I CLASS="Parameter cv Cliche">type function collection #rest more-collections<B CLASS="Parameter cv Cliche"> =>  new-collection</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">type</I> An instance of <CODE CLASS="cv Cliche2">&lt;type&gt;</CODE>. It must be an instantiable subtype of <CODE CLASS=Cliche2>&lt;mutable-collection&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">function</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-collections</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of  <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">new-collection</I> A freshly allocated instance of <CODE CLASS="cv Cliche">&lt;mutable-collection&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Creates a freshly allocated collection of type <I CLASS="Parameter Cliche">type</I> whose elements are obtained by applying <I CLASS=Cliche>function</I> to corresponding elements of the <I CLASS="Parameter Cliche">collection</I> arguments. <I CLASS=Cliche>type</I>  must be acceptable as the first argument to <CODE CLASS=Cliche>make</CODE>. <CODE CLASS=Cliche>size:</CODE> with a non-negative integer value must be an acceptable initarg for <CODE CLASS=Cliche>make</CODE> of <I CLASS="Parameter Cliche">type</I>. <I CLASS="Parameter Cliche">new-collection</I> is created by calling <CODE CLASS=Cliche>make</CODE> on <I CLASS="Parameter Cliche">type</I>, with a <CODE CLASS=Cliche>size:</CODE> initialization argument whose value is the number of corresponding elements in the <I CLASS="Parameter Cliche">collections</I>. If all the <I CLASS="Parameter Cliche">collections</I> are sequences (including <I CLASS="Parameter Cliche">new-collection</I>), processing is done in the natural order.</P>
</DL>
<PRE CLASS=Cv.Code>
map-as (&lt;vector&gt;, \+,
        #(100, 100, 200, 200),
        #(1, 2, 3, 4))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(101, 102, 203, 204)
</PRE>
<A NAME=HEADING102-544></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1815></A>map-into</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1816></A>Iterates over one or more collections and collects the results in an existing mutable collection.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">map-into <I CLASS="Parameter cv Cliche">mutable-collection function collection #rest more-collections<B CLASS="Parameter cv Cliche">  <BR>=> mutable-collection</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">mutable-collection </I>An instance of <CODE CLASS="cv Cliche2">&lt;mutable-collection&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">function</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-collections</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">mutable-collection </I>An instance of <CODE CLASS="cv Cliche2">&lt;mutable-collection&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the <I CLASS=Cliche>mutable-collection</I> argument after modifying it by replacing its elements with the results of applying <I CLASS=Cliche>function</I> to corresponding elements of <I CLASS=Cliche>collection</I> and <I CLASS=Cliche>more-collections</I>.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>mutable-collection</I> and all the other <I CLASS="Parameter T1.Text1">collections</I> are sequences, processing is done in the natural order.</P>
<P CLASS=T1.Text1>When <I CLASS=T1.Text1>mutable-collection</I>  is an instance of <CODE CLASS=T1.Text1>&lt;stretchy-collection&gt;</CODE>, the usual alignment requirement (described in <A HREF="drm_65.htm#MARKER-9-1021" CLASS=T1.Text1>"Collection Alignment" on page 120</A>) is relaxed. In this case, the key sequence of <I CLASS=T1.Text1>mutable-collection</I>  is not considered during alignment. Rather, only the key sequences for the source <I CLASS="Parameter T1.Text1">collections</I> are aligned, with <I CLASS="Parameter T1.Text1">function</I>  called on the corresponding elements. The result of each call to <I CLASS=T1.Text1>function</I> is then stored into <I CLASS=T1.Text1>mutable-collection</I>  with the corresponding key (possibly stretching <I CLASS=T1.Text1>mutable-collection</I>  in the process), using <CODE CLASS=T1.Text1>element-setter</CODE>. Other keys in <I CLASS=T1.Text1>mutable-collection</I> remain undisturbed.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>mutable-collection </I>may be the same object as <I CLASS=T1.Text1>collection</I> or any of the <I CLASS=T1.Text1>more-collections</I>.</P>
<P CLASS=T1.Text1>An error is signaled if<I CLASS="Parameter T1.Text1"> mutable-collection</I> does not have the same <CODE CLASS="cv T1.Text1">key-test</CODE> function as the rest of the <I CLASS="Parameter T1.Text1">collections</I>. This is true even if it is a <CODE CLASS=T1.Text1>&lt;stretchy-collection&gt;</CODE> and therefore does not get aligned.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable x = list (10, 9, 8, 7)
map-into (x, \+, #(1, 2, 3, 4), #(100, 100, 200, 200))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(101, 102, 203, 204)
x
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(101, 102, 203, 204)
</PRE>
<A NAME=HEADING102-558></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1817></A>any?  </CODE>  [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1818></A><A NAME=MARKER-2-1819></A>Returns the first true value obtained by iterating over one or more collections.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">any? <I CLASS="Parameter cv Cliche">function collection</I></CODE> <CODE CLASS="cv Cliche">#rest</CODE> <I CLASS="Parameter Cliche">more-collections</I>  <EM CLASS="Symbol Cliche"> fi</EM>   <I CLASS="Parameter Cliche">value</I></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">function</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-collections</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Applies <I CLASS="Parameter Cliche">function</I> to groups of corresponding elements of <I CLASS="Parameter Cliche">collection</I> and <I CLASS="Parameter Cliche">more-collections</I>. If an application of <I CLASS="Parameter Cliche">function</I> returns true, then <CODE CLASS="cv Cliche">any?</CODE> returns that true value. Otherwise <I CLASS=Cliche>function</I> returns <CODE CLASS=Cliche>#f</CODE> when applied to every such group, and <CODE CLASS="cv Cliche">any?</CODE> returns <CODE CLASS=Cliche>#f</CODE>. </P>
<P CLASS=T1.Text1>If all the <I CLASS="Parameter T1.Text1">collections</I> are sequences, <CODE CLASS="cv T1.Text1">any?</CODE> operates in natural order. In all cases, <CODE CLASS="cv T1.Text1">any?</CODE> stops on the first true value returned by <I CLASS=T1.Text1>function</I>.</P>
</DL>
<PRE CLASS=Cv.Code>
any? (\&gt;, #(1, 2, 3 ,4), #(5, 4, 3, 2))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #t
any? (even?, #(1, 3, 5, 7))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #f
</PRE>
<A NAME=HEADING102-568></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1820></A>every? </CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1821></A><A NAME=MARKER-2-1822></A>Returns true if a predicate returns true when applied to all corresponding elements of a set of collections.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">every? <I CLASS="Parameter cv Cliche">function collection #rest more-collections<B CLASS="Parameter cv Cliche">  =>  value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">function</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">more-collections</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> Instances of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value</I> An instance of <CODE CLASS="cv Cliche">&lt;boolean&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Applies <I CLASS="Parameter Cliche">function</I> to groups of corresponding elements of <I CLASS="Parameter Cliche">collection</I> and <I CLASS="Parameter Cliche">more-collections</I>. If an application of <I CLASS="Parameter Cliche">function</I> returns false, then <CODE CLASS="cv Cliche">every?</CODE> returns <CODE CLASS="cv Cliche">#f</CODE>. Otherwise <I CLASS=Cliche>function</I> returns a true value when applied to every such group, and <CODE CLASS="cv Cliche">every?</CODE> returns <CODE CLASS=Cliche>#t</CODE>.</P>
<P CLASS=T1.Text1>If all the <I CLASS="Parameter T1.Text1">collections</I> are sequences, <CODE CLASS="cv T1.Text1">every?</CODE> operates in natural order. In all cases, <CODE CLASS="cv T1.Text1">every?</CODE> stops on the first false value returned by <I CLASS=T1.Text1>function</I>.</P>
</DL>
<PRE CLASS=Cv.Code>
every? (\&gt;, #(1, 2, 3, 4), #(5, 4, 3, 2))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #f
every? (odd?, #(1, 3, 5, 7))
<CODE CLASS="cv Cv.Code"> fi</CODE>  #t
</PRE>
<A NAME=HEADING102-578></A>
<H3 CLASS=H3.Heading3> Extensible Mapping Functions</H3>
<A NAME=HEADING102-579></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1823></A>reduce</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1824></A>Combines the elements of a collection and a seed value into a single value by repeatedly applying a binary function.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">reduce <I CLASS="Parameter cv Cliche">function initial-value collection<B CLASS="Parameter cv Cliche">  =>  value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">function</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">initial-value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the result of combining the elements of <I CLASS="Parameter Cliche">collection</I> and <I CLASS="Parameter Cliche">initial-value</I> according to <I CLASS="Parameter Cliche">function</I>.</P>
<P CLASS=T1.Text1>If <I CLASS=T1.Text1>collection</I> is empty, <CODE CLASS=T1.Text1>reduce</CODE> returns <I CLASS=T1.Text1>initial-value</I>; otherwise, <I CLASS=T1.Text1>function</I> is applied to <I CLASS=T1.Text1>initial-value</I> and the first element of <I CLASS=T1.Text1>collection</I> to produce a new value. If more elements remain in the <I CLASS=T1.Text1>collection</I>, then <I CLASS=T1.Text1>function</I> is called again, this time with the value from the previous application and the next element from <I CLASS=T1.Text1>collection</I>. This process continues until all elements of <I CLASS=T1.Text1>collection</I> have been processed.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>function</I> is a binary function used to combine all the elements of <I CLASS=T1.Text1>collection</I> into a single value. Processing is always done in the natural order for <I CLASS=T1.Text1>collection</I>.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable high-score = 10
reduce (max, high-score, #(3, 1, 4, 1, 5, 9))
<CODE CLASS="cv Cv.Code"> fi</CODE>  10
reduce (max, high-score, #(3, 12, 9, 8, 8, 6))
<CODE CLASS="cv Cv.Code"> fi</CODE>  12
</PRE>
<A NAME=HEADING102-590></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1825></A>reduce1</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1826></A>Combines the elements of a collection into a single value by repeatedly applying a binary function, using the first element of the collection as the seed value.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">reduce1 <I CLASS="Parameter cv Cliche">function collection<B CLASS="Parameter cv Cliche">  =>  value</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">function</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the combination of the elements of <I CLASS="Parameter Cliche">collection</I> according to <I CLASS="Parameter Cliche">function</I>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam>An error is signaled if <I CLASS=RP.RoutineParam>collection</I> is empty. <DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam></P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>reduce1</CODE> is similar to <CODE CLASS=T1.Text1>reduce</CODE>, except that the first element of <I CLASS=T1.Text1>collection</I> is taken as the initial value, and all the remaining elements of <I CLASS=T1.Text1>collection</I> are processed as if by <CODE CLASS=T1.Text1>reduce</CODE>. (In other words, the first value isn't used twice.)</P>
<P CLASS=T1.Text1>For unstable collections, "first" element effectively means "an element chosen at random."  Processing is done in the natural order for <I CLASS=T1.Text1>collection</I>.</P>
</DL>
</DL>
<PRE CLASS=Cv.Code>
reduce1 (\+, #(1, 2, 3, 4, 5))
<CODE CLASS="cv Cv.Code"> fi</CODE>  15
</PRE>
<A NAME=HEADING102-601></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1827></A>choose</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1828></A><A NAME=MARKER-2-1829></A>Returns those elements of a sequence that satisfy a predicate.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">choose <I CLASS="Parameter cv Cliche">predicate source-sequence<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">predicate</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">source-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing those elements of <I CLASS=Cliche>source-sequence </I> that satisfy <I CLASS=Cliche>predicate</I>. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated.</P>
</DL>
<PRE CLASS=Cv.Code>
choose (even?, #(3, 1, 4, 1, 5, 8, 9))
  =>  #(4, 8)
</PRE>
<A NAME=HEADING102-609></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1830></A>choose-by  </CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1831></A><A NAME=MARKER-2-1832></A>Returns those elements of a sequence that correspond to those in another sequence that satisfy a predicate.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">choose-by <I CLASS="Parameter cv Cliche">predicate test-sequence value-sequence<B CLASS="Parameter cv Cliche">  =>  result-sequence</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">predicate</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">value-sequence</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;sequence&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">result-sequence </I>An instance of <CODE CLASS="cv Cliche2">&lt;sequence&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a sequence containing the elements from <I CLASS=Cliche>value-sequence</I> that correspond to elements in <I CLASS=Cliche>test-sequence</I> that satisfy <I CLASS=Cliche>predicate</I>. The <I CLASS="Parameter Cliche">result-sequence</I> may or may not be freshly allocated.</P>
</DL>
<PRE CLASS=Cv.Code>
choose-by (even?, range (from: 1),
             #(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;))
  =>  #(&quot;b&quot;, &quot;d&quot;, &quot;f&quot;, &quot;h&quot;)
</PRE>
<A NAME=HEADING102-618></A>
<H3 CLASS=H3.Heading3> Other Mapping Functions</H3>
<A NAME=HEADING102-619></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1833></A>member?</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1834></A>Returns true if a collection contains a particular value.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">member? <I CLASS="Parameter cv Cliche">value collection<B CLASS="Parameter cv Cliche"> #key test  =>  boolean</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">value</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">collection</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;collection&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">test</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">==</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">boolean</I> An instance of <CODE CLASS="cv Cliche">&lt;boolean&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> <A NAME=MARKER-2-1835></A>Returns true if <I CLASS=Cliche>collection</I> contains <I CLASS=Cliche>value</I> as determined by <I CLASS=Cliche>test</I>. Otherwise returns false.</P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>test</I> function may be noncommutative: it is always called with <I CLASS=T1.Text1>value</I> as its first argument and an element from <I CLASS=T1.Text1>collection</I> as its second argument.</P>
</DL>
<PRE CLASS=Cv.Code>
define constant flavors = #(#&quot;vanilla&quot;, #&quot;pistachio&quot;, #&quot;ginger&quot;)
member? (#&quot;vanilla&quot;, flavors)      
<CODE CLASS="cv Cv.Code"> =&gt;  #t </CODE>                                  
member? (#&quot;banana&quot;, flavors)
<CODE CLASS="cv Cv.Code"> =&gt;  #f </CODE>  
</PRE>
<A NAME=HEADING102-629></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>member?</CODE>  val range  <CODE CLASS=H5.Heading5>#key</CODE> test =>  boolean [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>I</CODE>f <I CLASS=T1.Text1>range</I> is unbounded, this method is guaranteed to terminate if <I CLASS=T1.Text1>test</I> is <CODE CLASS="cv T1.Text1">==</CODE>.</P>
<A NAME=HEADING102-631></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-9-1794></A>find-key</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1837></A><A NAME=MARKER-2-1838></A>Returns the key in a collection such that the corresponding collection element satisfies a predicate.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="Code Cliche">find-key <I CLASS="Parameter Code Cliche">collection function<B CLASS="Parameter Code Cliche"> #key skip failure  =>  key</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">collection</I> An instance of <CODE CLASS="cv Cliche">&lt;collection&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">predicate</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">skip</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">0</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">failure</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">#f</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">key</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.  </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a key value such that <CODE CLASS=Cliche>(<I CLASS=Cliche>predicate</I></CODE> <CODE CLASS=Cliche>(element</CODE> <I CLASS=Cliche>collection key<CODE CLASS=Cliche>))</CODE></I> is true. If no element in <I CLASS="Parameter Cliche">collection</I> satisfies <I CLASS=Cliche>predicate</I>, <CODE CLASS="cv Cliche">find-key</CODE> returns <I CLASS=Cliche>failure</I>.</P>
<P CLASS=T1.Text1>The <I CLASS=T1.Text1>skip</I> argument indicates that the first <I CLASS=T1.Text1>skip</I> matching elements should be ignored. If <I CLASS=T1.Text1>skip</I> or fewer elements of <I CLASS=T1.Text1>collection</I> satisfy <I CLASS=T1.Text1>predicate</I>, then <I CLASS=T1.Text1>failure</I> is returned. If collection is not stable under iteration, then skip is only useful for finding out whether collection contains at least <I CLASS="Parameter T1.Text1">skip</I> elements which satisfy <I CLASS="Parameter T1.Text1">predicate</I>; it is not useful for finding a particular element.</P>
</DL>
<PRE CLASS=Cv.Code>
flavors
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(#&quot;vanilla&quot;, #&quot;pistachio&quot;, #&quot;ginger&quot;)
find-key (flavors, has-nuts?)
<CODE CLASS="cv Cv.Code"> fi</CODE>  1
flavors[1]
<CODE CLASS="cv Cv.Code"> fi</CODE>  #&quot;pistachio&quot;
</PRE>
<A NAME=HEADING102-642></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1839></A>remove-key!</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1840></A>Modifies an explicit key collection so it no longer has a particular key.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">remove-key! <I CLASS="Parameter cv Cliche">collection key<B CLASS="Parameter cv Cliche">  => boolean</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">collection</I> An instance of <CODE CLASS="cv Cliche">&lt;mutable-explicit-key-collection&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">key</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">boolean</I> An instance of <CODE CLASS="cv Cliche2">&lt;boolean&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Modifies <I CLASS=Cliche>collection</I> so that it no longer has a key equal to <I CLASS=Cliche>key</I>. Equality is determined by <I CLASS="Parameter Cliche">collection</I>'s key-test function.</P>
<P CLASS=T1.Text1>The <I CLASS="Parameter T1.Text1">boolean</I> return value will be <CODE CLASS="cv T1.Text1">#t</CODE> if the <I CLASS="Parameter T1.Text1">key</I> was present and removed, or <CODE CLASS="cv T1.Text1">#f</CODE> if the key was not present and hence not removed.</P>
</DL>
<A NAME=HEADING102-650></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>remove-key! table key </CODE>  => table [Sealed G.F. Method]</H4>
<P CLASS=T1.Text1>There is a predefined method on <CODE CLASS="cv T1.Text1">&lt;table&gt;</CODE>.</P>
<A NAME=HEADING102-652></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1841></A>replace-elements!  </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1842></A>Replaces those collection elements that satisfy a predicate.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">replace-elements! <I CLASS="Parameter cv Cliche">mutable-collection predicate new-value-fn<B CLASS="Parameter cv Cliche"> #key  count<BR>=>  mutable-collection</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">mutable-collection</I>  An instance of <CODE CLASS="cv Cliche2">&lt;mutable-collection&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">predicate</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">new-value-fn</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">count</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE> or <CODE CLASS="cv RP.RoutineParam">#f</CODE>. The default is <CODE CLASS="cv RP.RoutineParam">#f</CODE>.</P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">mutable-collection</I>  An instance of <CODE CLASS="cv Cliche2">&lt;mutable-collection&gt;</CODE>. </P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Replaces those elements of <I CLASS=Cliche>mutable-collection</I> for which <I CLASS=Cliche>predicate</I> returns true. The elements are replaced with the value of calling <I CLASS=Cliche>new-value-fn</I> on the existing element. If <I CLASS=Cliche>count</I> is <CODE CLASS="cv Cliche">#f</CODE>, all of the matching elements are replaced. Otherwise, no more than <I CLASS=Cliche>count</I> elements are replaced.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">mutable-collection</I> may be modified by this operation.<DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam></P>
</DL>
</DL>
<PRE CLASS=Cv.Code>
define variable numbers = list (10, 13, 16, 19)
replace-elements! (numbers, odd?, double)
<CODE CLASS="cv Cv.Code"> =>  </CODE>#(10, 26, 16, 38)
</PRE>
<A NAME=HEADING102-663></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1843></A>fill! </CODE>[Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1844></A>Fills a collection with a specified value.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">fill! <I CLASS="Parameter cv Cliche">mutable-collection value<B CLASS="Parameter cv Cliche"> #key start end  =>  mutable-collection</B></I></CODE></P>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Arguments:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">mutable-collection</I>  An instance of <CODE CLASS="cv Cliche2">&lt;mutable-collection&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">value</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">start</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">end</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>. </P>
</DL>
<DT CLASS=Cliche2><B CLASS="IMPORTANT Cliche2">Values:</B><DD CLASS=Cliche2><P CLASS=Cliche2> <I CLASS="Parameter Cliche2">mutable-collection </I> An instance of <CODE CLASS="cv Cliche2">&lt;mutable-collection&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Modifies <I CLASS="Parameter Cliche">mutable-collection</I> so that <CODE CLASS="cv Cliche">element(<I CLASS="cv Cliche">mutable-collection, key)</I></CODE> returns <I CLASS="Parameter Cliche">value</I> for every <I CLASS="Parameter Cliche">key</I>.</P>
<P CLASS=T1.Text1>If <I CLASS="Parameter T1.Text1">mutable-collection</I> is a sequence, then <I CLASS="Parameter T1.Text1">start</I> and <I CLASS="Parameter T1.Text1">end</I> keywords may be specified to indicate that only a part of the sequence should be filled. <I CLASS="Parameter T1.Text1">start</I> is considered an inclusive bound and defaults to <CODE CLASS="cv T1.Text1">0</CODE>; <I CLASS="Parameter T1.Text1">end</I> is an exclusive bound and defaults to the length of the sequence.</P>
</DL>
<PRE CLASS=Cv.Code>
define variable numbers = list (10, 13, 16, 19)
fill! (numbers, 3, start: 2)
<CODE CLASS="cv Cv.Code"> fi</CODE>  #(10, 13, 3, 3)<A NAME=MARKER-2-1845></A>
</PRE>
<A NAME=HEADING102-674></A>
<A NAME="UID-Built-In_Functions-418"></A>
<H2 CLASS=H2.Heading2> The Iteration Protocol</H2>
<A NAME=HEADING102-675></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1846></A><A NAME=MARKER-2-1847></A>forward-iteration-protocol</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-2-1540></A>Returns a group of functions used to iterate over the elements of a collection.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">forward-iteration-protocol<B CLASS="cv Cliche"> <I CLASS="Parameter cv Cliche">collection<BR>=>  initial-state limit next-state finished-state? current-key current-element current-element-setter copy-state</I></B></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">collection</I> An instance of <CODE CLASS="cv Cliche">&lt;collection&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">initial-state</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>. The initial iteration state object.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">limit<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>  that is used by the <I CLASS="Parameter RP.RoutineParam">finished-state?</I> function to determine whether the iteration has been completed.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">next-state</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. Its signature is</P>
<DL CLASS=RP2.RoutineParam2>
<DT CLASS=RP2.RoutineParam2><CODE CLASS=RP2.RoutineParam2>next-state <I CLASS=RP2.RoutineParam2>collection state</I></CODE> fi<CODE CLASS=RP2.RoutineParam2> <I CLASS=RP2.RoutineParam2>new-state</I></CODE><DD CLASS=RP2.RoutineParam2><P CLASS=RP2.RoutineParam2></P>
</DL>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> This function steps the iteration by producing a new state from the associated <I CLASS=RP.RoutineParam>collection</I>  and <I CLASS=RP.RoutineParam>state. </I>The <I CLASS="Parameter RP.RoutineParam">next-state</I> function may or may not modify the <I CLASS=RP.RoutineParam>state</I>  argument; it is an error to use a state value after it has been passed to the associated <I CLASS="Parameter RP.RoutineParam">next-state</I> function. The <I CLASS="Parameter RP.RoutineParam">copy-state</I> function provides a mechanism for saving a particular state in an iteration for later resumption. </P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">finished-state?</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. Its signature is</P>
<DL CLASS=RP2.RoutineParam2>
<DT CLASS=RP2.RoutineParam2><CODE CLASS=RP2.RoutineParam2>finished-state? <I CLASS=RP2.RoutineParam2>collection state limit</I></CODE> fi<CODE CLASS=RP2.RoutineParam2> <I CLASS=RP2.RoutineParam2>boolean</I></CODE><DD CLASS=RP2.RoutineParam2><P CLASS=RP2.RoutineParam2></P>
</DL>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> This function returns <CODE CLASS=RP.RoutineParam>#t</CODE> if the iteration of the collection has been completed, i.e., there are no other elements of the collection to consider. It returns <CODE CLASS=RP.RoutineParam>#f</CODE> otherwise. It is an error to use a finished state in a call to the associated <I CLASS="Parameter RP.RoutineParam">next-state</I>, <I CLASS="Parameter RP.RoutineParam">current-element</I>, <I CLASS="Parameter RP.RoutineParam">current-key</I> or <I CLASS="Parameter RP.RoutineParam">current-element-setter</I> functions.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">current-key</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. Its signature is</P>
<DL CLASS=RP2.RoutineParam2>
<DT CLASS=RP2.RoutineParam2><CODE CLASS=RP2.RoutineParam2>current-key <I CLASS=RP2.RoutineParam2>collection state</I></CODE> fi<CODE CLASS=RP2.RoutineParam2> <I CLASS=RP2.RoutineParam2>key</I></CODE><DD CLASS=RP2.RoutineParam2><P CLASS=RP2.RoutineParam2></P>
</DL>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> This function returns the unique key associated with <I CLASS=RP.RoutineParam>state </I> in the <I CLASS=RP.RoutineParam>collection</I>. If the <I CLASS="Parameter RP.RoutineParam">current-key</I> function were called once with each <I CLASS=RP.RoutineParam>state</I> value produced during an iteration over a collection, the resulting sequence of values would contain every key from the collection exactly once; it would be the key-sequence of the collection.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">current-element</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam>  An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. Its signature is</P>
<DL CLASS=RP2.RoutineParam2>
<DT CLASS=RP2.RoutineParam2><CODE CLASS=RP2.RoutineParam2>current-element <I CLASS=RP2.RoutineParam2>collection state</I></CODE> fi<CODE CLASS=RP2.RoutineParam2> <I CLASS=RP2.RoutineParam2>element</I></CODE><DD CLASS=RP2.RoutineParam2><P CLASS=RP2.RoutineParam2></P>
</DL>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> This function returns the element of <I CLASS=RP.RoutineParam>collection</I> currently indicated by <I CLASS=RP.RoutineParam>state</I>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">current-element-</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. Its signature is</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">setter<CODE CLASS="Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> current-element-setter <I CLASS=RP.RoutineParam>value</I> <I CLASS=RP.RoutineParam>collection state<CODE CLASS=RP.RoutineParam> => value</CODE></I></P>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> This function sets the element of <I CLASS=RP.RoutineParam>collection</I>  indicated by <I CLASS=RP.RoutineParam>state</I> to <I CLASS=RP.RoutineParam>value</I>  and returns <I CLASS=RP.RoutineParam>value. </I>If <I CLASS="Parameter RP.RoutineParam">collection</I> is not an instance of <CODE CLASS=RP.RoutineParam>&lt;mutable-collection&gt;</CODE>, or if the <I CLASS="Parameter RP.RoutineParam">value</I> is not of a type acceptable to the collection, an error is signaled.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">copy-state</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. Its signature is</P>
<DL CLASS=RP2.RoutineParam2>
<DT CLASS=RP2.RoutineParam2><CODE CLASS=RP2.RoutineParam2>copy-state <I CLASS=RP2.RoutineParam2>collection state</I></CODE> fi<CODE CLASS=RP2.RoutineParam2> <I CLASS=RP2.RoutineParam2>new-state</I></CODE><DD CLASS=RP2.RoutineParam2><P CLASS=RP2.RoutineParam2></P>
</DL>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> This function returns a state that represents the same point in the iteration over <I CLASS=RP.RoutineParam>collection</I>  as is represented by <I CLASS=RP.RoutineParam>state. </I>  </P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns eight values used to implement iteration over the <I CLASS=Cliche>collection</I> argument. </P>
<P CLASS=T1.Text1>Only the <I CLASS=T1.Text1>collection</I> argument this function was called with may be used as the <I CLASS=T1.Text1>collection</I> argument to functions returned by this function. Only the <I CLASS="Parameter T1.Text1">initial-state</I> object and state objects returned by the <I CLASS="Parameter T1.Text1">next-state</I> and <I CLASS="Parameter T1.Text1">copy-state</I> functions may be used as the <I CLASS=T1.Text1>state</I> argument to functions returned by this function. Only the <I CLASS="Parameter T1.Text1">limit</I> object may be used as the <I CLASS=T1.Text1>limit</I> argument to the <I CLASS="Parameter T1.Text1">finished-state?</I> function.</P>
<P CLASS=T0.Text0>An example of the use of the iteration protocol is the following definition of a single-argument version of the <CODE CLASS=T0.Text0>do</CODE> function:</P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>define method do1 (f :: &lt;function&gt;, c :: &lt;collection&gt;)<BR>  let (init, limit, next, end?, key, elt) = <BR>                     forward-iteration-protocol(c);<BR>  for (state = init then next(c, state),<BR>     until: end?(c, state, limit))<BR>    f(elt(c, state));<BR>  end for;<BR>end method do1;</CODE></P>
</DL>
<A NAME=HEADING102-703></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>forward-iteration-protocol table </CODE> <BR> =>  initial-state limit next-state finished-state? current-key current-element current-element-setter copy-state  [Sealed G.F. Method]</H4>
<P CLASS=SD.ShortDescription>The method for <CODE CLASS="cv SD.ShortDescription">&lt;table&gt;</CODE> implements the iteration protocol in terms of the function <CODE CLASS="cv SD.ShortDescription">table-protocol</CODE>.</P>
<A NAME=HEADING102-705></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1849></A>backward-iteration-protocol</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1850></A>Returns a group of functions used to iterate over the elements of a collection in reverse order.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">backward-iteration-protocol<B CLASS="cv Cliche"> <I CLASS="Parameter cv Cliche">collection<BR>=>  initial-state limit next-state finished-state? current-key current-element current-element-setter copy-state</I></B></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">collection</I> An instance of <CODE CLASS="cv Cliche">&lt;collection&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">initial-state</I> An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">limit<CODE CLASS="cv Parameter RP.RoutineParam"></CODE></I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">next-state</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. </P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">finished-state?</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">current-key</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">current-element</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.</P>
<DT CLASS=RP3.RoutineParam><I CLASS="Parameter RP3.RoutineParam">current-element-</I><DD CLASS=RP3.RoutineParam><P CLASS=RP3.RoutineParam> An instance of <CODE CLASS="cv RP3.RoutineParam">&lt;function&gt;</CODE>.<BR><I CLASS="Parameter RP3.RoutineParam">setter</I> </P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">copy-state</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>.   </P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns eight values used to implement reverse iteration over the <I CLASS="Parameter Cliche">collection</I> argument.</P>
<P CLASS=T1.Text1>Some collection classes that are stable under iteration support the ability to iterate in the reverse of the natural order, by providing a method on the generic function <CODE CLASS=T1.Text1>backward-iteration-protocol</CODE>. The eight values returned by this function are analogous to the corresponding values returned by <CODE CLASS=T1.Text1>forward-iteration-protocol</CODE>.</P>
</DL>
<A NAME=HEADING102-719></A>
<H3 CLASS=H3.Heading3> The Table Protocol</H3>
<P CLASS=T0.Text0>The class <CODE CLASS=T0.Text0>&lt;table&gt;</CODE> provides an implementation of the iteration protocol, using the function <CODE CLASS=T0.Text0>table-protocol</CODE>. Every concrete subclass of <CODE CLASS=T0.Text0>&lt;table&gt;</CODE> must provide or inherit a method for <CODE CLASS=T0.Text0>table-protocol</CODE>. A complete description of the table protocol is given in <A HREF="drm_67.htm#MARKER-9-1036" CLASS=T0.Text0>"Tables" on page 122</A>.</P>
<A NAME=HEADING102-721></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1851></A>table-protocol</CODE> [Open Generic Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1852></A>Returns functions used to implement the iteration protocol for tables.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">table-protocol <I CLASS="Parameter cv Cliche">table<B CLASS="Parameter cv Cliche"> =>  test-function  hash-function</B></I></CODE></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">table</I> An instance of <CODE CLASS="cv Cliche">&lt;table&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">test-function</I> An instance of <CODE CLASS="cv Cliche">&lt;function&gt;</CODE>. Its signature is</P>
<DL CLASS=RP2.RoutineParam2>
<DL CLASS=RP2.RoutineParam2>
<DT CLASS=RP2.RoutineParam2><CODE CLASS=RP2.RoutineParam2>test-function</CODE> <I CLASS=RP2.RoutineParam2>key1 key2</I>  => <I CLASS=RP2.RoutineParam2>boolean</I><DD CLASS=RP2.RoutineParam2><P CLASS=RP2.RoutineParam2></P>
</DL>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">test-function</I> is used to compare keys. It returns true if the keys are members of the same equivalence class according to the table's equivalence predicate.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">hash-function</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam>  An instance of <CODE CLASS="cv RP.RoutineParam">&lt;function&gt;</CODE>. Its signature is</P>
<DL CLASS=RP2.RoutineParam2>
<DT CLASS=RP2.RoutineParam2><CODE CLASS=RP2.RoutineParam2>hash-function</CODE> <I CLASS=RP2.RoutineParam2>key</I>  => <I CLASS=RP2.RoutineParam2>id</I> <I CLASS=RP2.RoutineParam2>state</I><DD CLASS=RP2.RoutineParam2><P CLASS=RP2.RoutineParam2></P>
</DL>
<DT CLASS=RP.RoutineParam><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> <I CLASS="Parameter RP.RoutineParam">hash-function</I> computes the hash code  of the <I CLASS=RP.RoutineParam>key</I>, using the hash function associated with the table's equivalence predicate. The hash code is returned as two values, <I CLASS=RP.RoutineParam>id</I> (an integer) and <I CLASS=RP.RoutineParam>state</I> (a hash state).  </P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns the test-function and hash-function for the <CODE CLASS="cv Cliche">&lt;table&gt;</CODE>. These functions are in turn used to implement the other collection operations on <CODE CLASS="cv Cliche">&lt;table&gt;</CODE>.</P>
</DL>
<A NAME=HEADING102-732></A>
<H4 CLASS=H5.Heading5> <CODE CLASS=H5.Heading5>table-protocol object-table </CODE>  => test-function  hash-function [Sealed G.F. Method]</H4>
<P CLASS=SD.ShortDescription>The method for <CODE CLASS="cv SD.ShortDescription">&lt;object-table&gt;</CODE> returns <CODE CLASS="cv SD.ShortDescription">==</CODE>  as the <I CLASS=SD.ShortDescription>test-function</I> and <CODE CLASS=SD.ShortDescription>object-hash</CODE> as the <I CLASS=SD.ShortDescription>hash-function</I>.</P>
<P CLASS=T1.Text1>The method for <CODE CLASS="cv T1.Text1">&lt;object-table&gt;</CODE> could be written as</P>
<PRE CLASS=Cv.Code>
define method table-protocol (table :: &lt;object-table&gt;)
      =&gt; test-function :: &lt;function&gt;, 
         hash-function :: &lt;function&gt;;
  values(\==, object-hash);
end method table-protocol;
</PRE>
<A NAME=HEADING102-736></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1853></A>merge-hash-codes</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription>Returns a hash-code created from the merging of two argument hash codes.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">merge-hash-codes <I CLASS="Parameter cv Cliche">id1 state1 id2 state2 #key ordered<BR>  fi</I></CODE>  <I CLASS=Cliche>merged-id merged-state</I></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">id1 </I>An instance of <CODE CLASS="cv Cliche">&lt;integer&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">state1</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">id2</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;integer&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">state2</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">ordered</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;boolean&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">merged-id </I>An instance of <CODE CLASS="cv Cliche">&lt;integer&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">merged-state</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.  </P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Computes a new hash code by merging the argument hash codes in some implementation dependent way. This can be used, for example, to generate a hash-code for an object by combining hash codes of some of its parts.</P>
<P CLASS=T1.Text1><I CLASS=T1.Text1>id1</I>, <I CLASS=T1.Text1>id2</I>, and <I CLASS=T1.Text1>merged-id </I> are all integers. <I CLASS=T1.Text1>state1</I>, <I CLASS=T1.Text1>state2</I>, and <I CLASS=T1.Text1>merged-state </I> are all hash states. <I CLASS=T1.Text1>ordered</I> is a boolean and determines whether the algorithm used to perform the merge is permitted to be order dependent. If false, which is the default, then the merged result must be independent of the order in which the argument pairs are provided. If true, then the order of the argument pairs matters because the algorithm used need not be either commutative or associative. It is best to provide a true value for <I CLASS=T1.Text1>ordered</I> when possible, as this may result in a better distribution of hash ids. However, <I CLASS="Parameter T1.Text1">ordered</I> must only be true if this will not cause the hash function to violate the second constraint on hash functions, described on <A HREF="drm_67.htm#MARKER-9-1049" CLASS=T1.Text1>page 123</A>.</P>
<P CLASS=T1.Text1><I CLASS="Parameter T1.Text1">state1</I> and <I CLASS="Parameter T1.Text1">state2</I> should be the value of <CODE CLASS="cv T1.Text1">$permanant-hash-state</CODE> or hash-states returned from previous calls to <CODE CLASS="cv T1.Text1">merge-hash-codes</CODE> or <CODE CLASS="cv T1.Text1">object-hash</CODE>.</P>
</DL>
<A NAME=HEADING102-749></A>
<H3 CLASS=H4.Heading4> <CODE CLASS="Code H4.Heading4"><A NAME=MARKER-2-1854></A>object-hash</CODE> [Function]</H3>
<HR CLASS=H4.Heading4>
<P CLASS=SD.ShortDescription><A NAME=MARKER-9-1855></A>The hash function for the equivalence predicate <CODE CLASS=SD.ShortDescription>==</CODE>.</P>
<DL CLASS=Cliche>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Signature:</B><DD CLASS=Cliche><P CLASS=Cliche> <CODE CLASS="cv Cliche">object-hash <I CLASS="Parameter cv Cliche">object<B CLASS="Parameter cv Cliche">  fi</B></I></CODE>  <I CLASS=Cliche>hash-id hash-state</I></P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Arguments:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">object </I>An instance of <CODE CLASS="cv Cliche">&lt;object&gt;</CODE>.</P>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Values:</B><DD CLASS=Cliche><P CLASS=Cliche> <I CLASS="Parameter Cliche">hash-id </I>An instance of <CODE CLASS="cv Cliche">&lt;integer&gt;</CODE>.</P>
<DL CLASS=RP.RoutineParam>
<DT CLASS=RP.RoutineParam><I CLASS="Parameter RP.RoutineParam">hash-state</I><DD CLASS=RP.RoutineParam><P CLASS=RP.RoutineParam> An instance of <CODE CLASS="cv RP.RoutineParam">&lt;object&gt;</CODE>.</P>
</DL>
<DT CLASS=Cliche><B CLASS="IMPORTANT Cliche">Description:</B><DD CLASS=Cliche><P CLASS=Cliche> Returns a hash-code for <I CLASS="Parameter Cliche">object</I> that corresponds to the equivalence predicate <CODE CLASS="cv Cliche">==</CODE>. It is made available as a tool for writing hash functions in which the object identity of some component of a key is to be used in computing the hash code. It returns a hash id (an integer) and associated hash state for the object, computed in some implementation dependent manner. The values returned by <CODE CLASS=Cliche>object-hash </CODE>when called repeatedly on the same object might not be the same for each call. If the <I CLASS=Cliche>hash-id</I> value changes then the <I CLASS=Cliche>hash-state</I> value will also change.<A NAME=MARKER-2-1856></A><A NAME=MARKER-2-1857></A></P>
</DL>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-3" CLASS=FOOTER><B CLASS=FOOTER></B>Collection Properties</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-4" CLASS=FOOTER><B CLASS=FOOTER></B>empty? [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-10" CLASS=FOOTER><B CLASS=FOOTER></B>empty?   collection =>  boolean [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-12" CLASS=FOOTER><B CLASS=FOOTER></B>size [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-18" CLASS=FOOTER><B CLASS=FOOTER></B>size collection => integer-or-false [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-20" CLASS=FOOTER><B CLASS=FOOTER></B>size array => size  [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-23" CLASS=FOOTER><B CLASS=FOOTER></B>size  list  =>  integer-or-false [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-25" CLASS=FOOTER><B CLASS=FOOTER></B>size   range =>  size [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-27" CLASS=FOOTER><B CLASS=FOOTER></B>size   table =>  size [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-29" CLASS=FOOTER><B CLASS=FOOTER></B>size-setter [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-40" CLASS=FOOTER><B CLASS=FOOTER></B>rank [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-46" CLASS=FOOTER><B CLASS=FOOTER></B>rank array => rank [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-48" CLASS=FOOTER><B CLASS=FOOTER></B>row-major-index [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-56" CLASS=FOOTER><B CLASS=FOOTER></B>row-major-index array #rest subscripts => index  [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-58" CLASS=FOOTER><B CLASS=FOOTER></B>dimensions [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-64" CLASS=FOOTER><B CLASS=FOOTER></B>dimensions vector =>  sequence [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-66" CLASS=FOOTER><B CLASS=FOOTER></B>dimension [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-74" CLASS=FOOTER><B CLASS=FOOTER></B>dimension array axis => dimension   [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-76" CLASS=FOOTER><B CLASS=FOOTER></B>key-test [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-83" CLASS=FOOTER><B CLASS=FOOTER></B>key-test sequence  => test-function [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-85" CLASS=FOOTER><B CLASS=FOOTER></B>key-test table  => test-function [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-87" CLASS=FOOTER><B CLASS=FOOTER></B>key-sequence [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-95" CLASS=FOOTER><B CLASS=FOOTER></B>Selecting Elements</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-96" CLASS=FOOTER><B CLASS=FOOTER></B>element [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-105" CLASS=FOOTER><B CLASS=FOOTER></B>element simple-vector  index #key default =>  element  [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-107" CLASS=FOOTER><B CLASS=FOOTER></B>element unicode-string index #key default  =>  character   [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-109" CLASS=FOOTER><B CLASS=FOOTER></B>element byte-string index #key default  =>  character       [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-111" CLASS=FOOTER><B CLASS=FOOTER></B>element table key #key default  =>  element       [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-113" CLASS=FOOTER><B CLASS=FOOTER></B>element-setter [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-125" CLASS=FOOTER><B CLASS=FOOTER></B>element-setter  new-element simple-vector  index  [Sealed G.F. Method] =>  new-element </A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-127" CLASS=FOOTER><B CLASS=FOOTER></B>element-setter   new-value table key  [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-129" CLASS=FOOTER><B CLASS=FOOTER></B>element-setter  character unicode-string index   [Sealed G.F. Method] =>  character</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-131" CLASS=FOOTER><B CLASS=FOOTER></B>element-setter  character byte-string index =>  character  [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-133" CLASS=FOOTER><B CLASS=FOOTER></B>aref [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-141" CLASS=FOOTER><B CLASS=FOOTER></B>aref array #rest indices => element  [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-143" CLASS=FOOTER><B CLASS=FOOTER></B>aref-setter   [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-153" CLASS=FOOTER><B CLASS=FOOTER></B>aref-setter new-value   array  #rest indices => new-value  [G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-155" CLASS=FOOTER><B CLASS=FOOTER></B>first [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-163" CLASS=FOOTER><B CLASS=FOOTER></B>second [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-170" CLASS=FOOTER><B CLASS=FOOTER></B>third [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-177" CLASS=FOOTER><B CLASS=FOOTER></B>first-setter [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-185" CLASS=FOOTER><B CLASS=FOOTER></B>second-setter [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-192" CLASS=FOOTER><B CLASS=FOOTER></B>third-setter [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-199" CLASS=FOOTER><B CLASS=FOOTER></B>last [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-208" CLASS=FOOTER><B CLASS=FOOTER></B>last-setter      [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-219" CLASS=FOOTER><B CLASS=FOOTER></B>head [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-227" CLASS=FOOTER><B CLASS=FOOTER></B>tail [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-235" CLASS=FOOTER><B CLASS=FOOTER></B>head-setter [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-244" CLASS=FOOTER><B CLASS=FOOTER></B>tail-setter [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-253" CLASS=FOOTER><B CLASS=FOOTER></B>Adding and Removing Elements</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-254" CLASS=FOOTER><B CLASS=FOOTER></B>add [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-264" CLASS=FOOTER><B CLASS=FOOTER></B>add! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-274" CLASS=FOOTER><B CLASS=FOOTER></B>add!   deque new-value  => deque [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-276" CLASS=FOOTER><B CLASS=FOOTER></B>add!   stretchy-vector new-element  => stretchy-vector [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-278" CLASS=FOOTER><B CLASS=FOOTER></B>add!   list element =>  pair [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-280" CLASS=FOOTER><B CLASS=FOOTER></B>add-new [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-291" CLASS=FOOTER><B CLASS=FOOTER></B>add-new! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-302" CLASS=FOOTER><B CLASS=FOOTER></B>remove [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-314" CLASS=FOOTER><B CLASS=FOOTER></B>remove! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-325" CLASS=FOOTER><B CLASS=FOOTER></B>remove!   deque value #key test count   => deque [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-327" CLASS=FOOTER><B CLASS=FOOTER></B>remove!   stretchy-vector element #key test count   [Sealed G.F. Method] => stretchy-vector</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-329" CLASS=FOOTER><B CLASS=FOOTER></B>remove!   list element #key test count  =>  list [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-331" CLASS=FOOTER><B CLASS=FOOTER></B>push [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-339" CLASS=FOOTER><B CLASS=FOOTER></B>pop [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-346" CLASS=FOOTER><B CLASS=FOOTER></B>push-last [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-354" CLASS=FOOTER><B CLASS=FOOTER></B>pop-last [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-361" CLASS=FOOTER><B CLASS=FOOTER></B>Reordering Elements</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-362" CLASS=FOOTER><B CLASS=FOOTER></B>reverse [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-371" CLASS=FOOTER><B CLASS=FOOTER></B>reverse   range =>  new-range [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-373" CLASS=FOOTER><B CLASS=FOOTER></B>reverse! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-382" CLASS=FOOTER><B CLASS=FOOTER></B>reverse!   range =>  range [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-384" CLASS=FOOTER><B CLASS=FOOTER></B>sort [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-395" CLASS=FOOTER><B CLASS=FOOTER></B>sort! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-407" CLASS=FOOTER><B CLASS=FOOTER></B>Set Operations</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-408" CLASS=FOOTER><B CLASS=FOOTER></B>intersection [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-419" CLASS=FOOTER><B CLASS=FOOTER></B>intersection   range1 range2  #key test =>  range [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-421" CLASS=FOOTER><B CLASS=FOOTER></B>union [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-433" CLASS=FOOTER><B CLASS=FOOTER></B>remove-duplicates [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-443" CLASS=FOOTER><B CLASS=FOOTER></B>remove-duplicates! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-453" CLASS=FOOTER><B CLASS=FOOTER></B>Subsequence Operations</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-454" CLASS=FOOTER><B CLASS=FOOTER></B>copy-sequence  [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-463" CLASS=FOOTER><B CLASS=FOOTER></B>copy-sequence   range #key start end =>  new-range [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-465" CLASS=FOOTER><B CLASS=FOOTER></B>concatenate  [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-475" CLASS=FOOTER><B CLASS=FOOTER></B>concatenate-as    [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-486" CLASS=FOOTER><B CLASS=FOOTER></B>replace-subsequence! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-500" CLASS=FOOTER><B CLASS=FOOTER></B>subsequence-position [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-511" CLASS=FOOTER><B CLASS=FOOTER></B>Mapping and Reducing</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-512" CLASS=FOOTER><B CLASS=FOOTER></B>Simple Mapping</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-515" CLASS=FOOTER><B CLASS=FOOTER></B>do [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-524" CLASS=FOOTER><B CLASS=FOOTER></B>map   [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-534" CLASS=FOOTER><B CLASS=FOOTER></B>map-as [Function] </A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-544" CLASS=FOOTER><B CLASS=FOOTER></B>map-into [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-558" CLASS=FOOTER><B CLASS=FOOTER></B>any?    [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-568" CLASS=FOOTER><B CLASS=FOOTER></B>every?  [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-578" CLASS=FOOTER><B CLASS=FOOTER></B>Extensible Mapping Functions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-579" CLASS=FOOTER><B CLASS=FOOTER></B>reduce [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-590" CLASS=FOOTER><B CLASS=FOOTER></B>reduce1 [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-601" CLASS=FOOTER><B CLASS=FOOTER></B>choose [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-609" CLASS=FOOTER><B CLASS=FOOTER></B>choose-by   [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-618" CLASS=FOOTER><B CLASS=FOOTER></B>Other Mapping Functions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-619" CLASS=FOOTER><B CLASS=FOOTER></B>member? [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-629" CLASS=FOOTER><B CLASS=FOOTER></B>member?  val range  #key test =>  boolean [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-631" CLASS=FOOTER><B CLASS=FOOTER></B>find-key [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-642" CLASS=FOOTER><B CLASS=FOOTER></B>remove-key! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-650" CLASS=FOOTER><B CLASS=FOOTER></B>remove-key! table key   => table [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-652" CLASS=FOOTER><B CLASS=FOOTER></B>replace-elements!  [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-663" CLASS=FOOTER><B CLASS=FOOTER></B>fill! [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-674" CLASS=FOOTER><B CLASS=FOOTER></B>The Iteration Protocol</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-675" CLASS=FOOTER><B CLASS=FOOTER></B>forward-iteration-protocol [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-703" CLASS=FOOTER><B CLASS=FOOTER></B>forward-iteration-protocol table    =>  initial-state limit next-state finished-state? current-key current-element current-element-setter copy-state  [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-705" CLASS=FOOTER><B CLASS=FOOTER></B>backward-iteration-protocol [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-719" CLASS=FOOTER><B CLASS=FOOTER></B>The Table Protocol</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-721" CLASS=FOOTER><B CLASS=FOOTER></B>table-protocol [Open Generic Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-732" CLASS=FOOTER><B CLASS=FOOTER></B>table-protocol object-table   => test-function  hash-function [Sealed G.F. Method]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-736" CLASS=FOOTER><B CLASS=FOOTER></B>merge-hash-codes [Function]</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_102.htm#HEADING102-749" CLASS=FOOTER><B CLASS=FOOTER></B>object-hash [Function]</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_103.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_101.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_96.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML Experimental 19960712//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="drm_1.htm">
<LINK REL=UP HREF="drm_47.htm">
<LINK REL=PREV HREF="drm_47.htm">
<LINK REL=NEXT HREF="drm_49.htm">
<LINK TITLE="WebMaker generated style" REL=stylesheet HREF=drm.css TYPE="text/css">
<TITLE> Overview</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FEFEF2" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<DIV CLASS=WM-DIV-BODY>
<A NAME=HEADING48></A>

<DIV CLASS=WM-DIV-HEADERS>
<P CLASS=HEADER><A HREF="drm_49.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_47.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_47.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=HEADER>6 Functions</P>

</DIV>
<A NAME=HEADING48-0></A>
<A NAME=UID-Functions-2150></A>
<H1 CLASS=H1.Heading1> <A NAME=MARKER-2-745></A>Overview</H1>
<P CLASS=T1.Text1>All operations in Dylan are functions.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-746></A>Functions accept zero or more arguments, and return zero or more values. The <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-747></A>parameter list</B> of the function describes the number and types of the arguments that the function accepts, and the number and types of the values it returns.</P>
<P CLASS=T1.Text1>There are two kinds of functions, methods and generic functions. Both are invoked in the same way. The caller does not need to know whether the function it is calling is a method or a generic function.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-748></A>A method is the basic unit of executable code. A method accepts a number of arguments, creates local bindings for them, executes an implicit body in the scope of these bindings, and then returns a number of values.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-749></A>A generic function contains a number of methods. When a generic function is called, it compares the arguments it received with the parameter lists of the methods it contains. It selects the most appropriate method and invokes it on the arguments. This technique of <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-750></A>method dispatch</B> is the  basic mechanism of polymorphism in Dylan.</P>
<P CLASS=T1.Text1>All Dylan functions are objects, instances of <CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-751></A>&lt;function&gt;</CODE>. Generic functions are instances of <CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-752></A>&lt;generic-function&gt;</CODE> and methods are instances of <A NAME=MARKER-2-753></A><CODE CLASS="Code T1.Text1">&lt;method&gt;</CODE>.</P>
<A NAME=HEADING48-7></A>
<A NAME=UID-Functions-2158></A>
<H2 CLASS=H2.Heading2> Generic Functions</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-754></A><A NAME=MARKER-2-755></A>Generic functions can be created with <CODE CLASS="Code T1.Text1">define generic</CODE> or by calling <CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-756></A>make</CODE> on the class <CODE CLASS="Code T1.Text1">&lt;generic-function&gt;</CODE>. They are most often created with <CODE CLASS="Code T1.Text1">define generic</CODE>.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-757></A>Generic functions may also be created implicitly by <CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-758></A>define method</CODE> or by <A NAME=MARKER-2-759></A>slot specifications in class definitions.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-760></A>A generic function definition includes a parameter list, which constrains the methods that can be added to the generic function; some aspects of the parameter must be matched by any method added. In addition, a generic function parameter list may specify that all keyword arguments are permitted in a call to the generic function.</P>
<P CLASS=T1.Text1>Parameter list congruency is described on <A HREF="drm_49.htm#MARKER-9-837" CLASS=T1.Text1>page 93</A>. The complete syntax of <CODE CLASS="cv T1.Text1">define generic</CODE> is given on <A HREF="drm_112.htm#MARKER-9-2007" CLASS=T1.Text1>page 376</A>.</P>
<P CLASS=T1.Text1>The following definition defines a generic function that accepts a single required argument. All methods added to this generic function must also accept a single required argument.</P>
<PRE CLASS=Cv.Code>
define generic double (thing)
</PRE>
<P CLASS=T1.Text1>The following definition defines a generic function that accepts two arguments of type <CODE CLASS="Code T1.Text1">&lt;number&gt;</CODE>. All methods added to the generic function must accept two required arguments of type <CODE CLASS="Code T1.Text1">&lt;number&gt;</CODE> or subtype of <CODE CLASS="Code T1.Text1">&lt;number&gt;</CODE>.</P>
<PRE CLASS=Cv.Code>
define generic average (n1 :: &lt;number&gt;, n2 :: &lt;number&gt;)
</PRE>
<P CLASS=T1.Text1>Generic functions created with <CODE CLASS="Code T1.Text1">define generic</CODE> may be sealed or open. For details of this option, see <A HREF="drm_74.htm#MARKER-9-1116" CLASS=T1.Text1>"Declaring Characteristics of Generic Functions" on page 135</A>.<A NAME=MARKER-2-761></A></P>
<A NAME=HEADING48-17></A>
<A NAME=UID-Functions-2162></A>
<H2 CLASS=H2.Heading2> <A NAME=MARKER-9-762></A>Methods</H2>
<P CLASS=T1.Text1><A NAME=MARKER-2-763></A>Methods can be created with <CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-764></A>define method</CODE>,  <A NAME=MARKER-2-765></A><CODE CLASS="Code T1.Text1">local</CODE>, and <A NAME=MARKER-2-766></A><CODE CLASS="Code T1.Text1">method</CODE> program constituents. <CODE CLASS="Code T1.Text1">define method</CODE> is used to define a method and add it to a generic function in a module binding. <CODE CLASS="Code T1.Text1">local</CODE> is used to create local bindings that contain self-recursive and mutually recursive methods. <CODE CLASS="Code T1.Text1">method</CODE> is used to create and return methods for immediate application, for use as function arguments, or for storage in a variable or other data structure. Methods are also created for slot getters and setters when a class is created.</P>
<P CLASS=T1.Text1>Methods cannot be created with <CODE CLASS="Code T1.Text1">make</CODE>.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-767></A>The parameters and return values of a method are described in its parameter list. The specializers in the parameter list declare the types of the arguments acceptable to the method. The method can be called only with arguments that match the specializers of the parameters. A complete description of parameter lists is given in <A HREF="drm_49.htm#MARKER-9-782" CLASS=T1.Text1>"Parameter Lists" on page 84</A>.</P>
<P CLASS=T1.Text1>When the method is invoked, it executes its implicit body. Statements in the implicit body are executed in order, in an environment that contains the parameters bound to the arguments.</P>
<P CLASS=T1.Text1>Methods may be invoked directly (used as functions), or indirectly through the invocation of a generic function.</P>
<A NAME=HEADING48-23></A>
<H3 CLASS=H3.Heading3> Methods in Generic Functions</H3>
<P CLASS=T1.Text1><CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-768></A>define method</CODE> creates a method and adds it to a generic function in a module variable. If the module variable indicated is not already defined, it is defined as with <CODE CLASS="Code T1.Text1">define generic</CODE>. Thus,  <CODE CLASS="Code T1.Text1">define method</CODE> will create a new generic function or extend an old one, as needed. Methods added to a generic function must have parameter lists that are congruent with the generic function's parameter list.</P>
<P CLASS=T1.Text1>The following method accepts a single argument of type <CODE CLASS="cv T1.Text1">&lt;number&gt;</CODE>, and returns the number doubled. The method will be added to the generic function in the module binding <CODE CLASS="Code T1.Text1">double</CODE>.</P>
<P CLASS=T1.Text1><CODE CLASS=T1.Text1>define method double (thing :: &lt;number&gt;)<BR>  =&gt; another-thing :: &lt;number&gt;;<BR>  thing + thing;<BR>end method;</CODE></P>
<P CLASS=T1.Text1><CODE CLASS="Code T1.Text1">define method</CODE> allows the programmer to control aspects of the sealing of the generic function to which the method is added. For more details, see <A HREF="drm_75.htm#MARKER-9-1131" CLASS=T1.Text1>"Abbreviations for Define Sealed Domain" on page 138</A>.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-769></A>A generic function with no required parameters can contain a single method. Adding a new method has the effect of replacing the existing method.</P>
<P CLASS=T1.Text1>The complete syntax of <CODE CLASS="cv T1.Text1">define method</CODE> is given on <A HREF="drm_112.htm#MARKER-9-2010" CLASS=T1.Text1>page 377</A>.<A NAME=MARKER-2-770></A></P>
<A NAME=HEADING48-30></A>
<H3 CLASS=H3.Heading3> Local Methods</H3>
<P CLASS=T1.Text1><CODE CLASS="Code T1.Text1"><A NAME=MARKER-2-771></A>local</CODE> is used for creating methods in local bindings. A single <CODE CLASS="cv T1.Text1">local</CODE> declaration may create one or more such methods. These methods may be self-recursive and they may be mutually recursive with other methods created by the same <CODE CLASS="Code T1.Text1">local</CODE> declaration.</P>
<P CLASS=T1.Text1><CODE CLASS="Code T1.Text1">local</CODE>  is similar to <CODE CLASS="Code T1.Text1">let</CODE> in that it creates local bindings in the current body. The parameters and the bodies of the methods are within the scope of the bindings. In this way, the methods can refer to themselves and to other methods created by the same <CODE CLASS="Code T1.Text1">local</CODE> declaration.</P>
<P CLASS=T1.Text1>The complete syntax of <CODE CLASS="cv T1.Text1">local</CODE> is given on <A HREF="drm_113.htm#MARKER-9-2035" CLASS=T1.Text1>page 391</A>.</P>
<PRE CLASS=Cv.Code>
define method newtons-sqrt (x :: &lt;number&gt;)
   local method sqrt1 (guess)
           // note call to other local method
           if (close-enough? (guess))
              guess
           else
              sqrt1 (improve (guess))  // note self-recursive call
           end if
         end sqrt1,
         method close-enough? (guess)
           abs (guess * guess - x) &lt; .0001
         end close-enough?,
         method improve (guess)
           (guess + (x / guess)) / 2
         end improve;
    sqrt1 (1)
end method newtons-sqrt;<A NAME=MARKER-2-772></A>
</PRE>
<A NAME=HEADING48-35></A>
<H3 CLASS=H3.Heading3> Bare Methods</H3>
<P CLASS=T1.Text1><A NAME=MARKER-2-773></A><A NAME=MARKER-2-774></A>Methods can also be created and used directly with the <CODE CLASS="cv T1.Text1"><A NAME=MARKER-2-775></A>method</CODE> statement.</P>
<P CLASS=T1.Text1>Methods created directly can be stored in module variables, passed as arguments to generic functions, stored in data structures, or immediately invoked.</P>
<P CLASS=T1.Text1>The following example creates a method and stores it in the module variable square. It is appropriate to define a method in this way (rather than with define method) when the protocol of the function being defined does not require multiple methods.</P>
<PRE CLASS=Cv.Code>
define constant square = method (n :: &lt;number&gt;)
                           n * n;
                           end method;
</PRE>
<P CLASS=T1.Text1>It is sometimes useful to create a method inline and pass it directly to another function that accepts a method as an argument, as in the following example.</P>
<PRE CLASS=Cv.Code>
// sort accepts a test argument, which defaults to \&lt;
sort(person-list,
     test: method(person1, person2)
             person1.age &lt; person2.age
            end method)
</PRE>
<P CLASS=T1.Text1>Methods created directly with the <CODE CLASS="Code T1.Text1">method</CODE> statement may be called directly or they may be added to generic functions. Usually, however, when you want to add a method to a generic function, you create and add the method in a single declarative step, with <CODE CLASS="Code T1.Text1">define method</CODE>.<A NAME=MARKER-2-776></A></P>
<A NAME=HEADING48-43></A>
<H3 CLASS=H3.Heading3> Closures</H3>
<P CLASS=T1.Text1><A NAME=MARKER-2-777></A>Methods created with <CODE CLASS="Code T1.Text1">method</CODE> or <CODE CLASS="Code T1.Text1">local</CODE> can be passed to functions and returned from functions. In both cases, the methods retain access to the lexical context in which they were created. Such methods are called <B CLASS="Bold T1.Text1">closures</B>.</P>
<P CLASS=T1.Text1><A NAME=MARKER-2-778></A>The following example defines a function that returns score-card methods. The method that is returned is <B CLASS="Bold T1.Text1"><A NAME=MARKER-2-779></A>closed over</B> the <CODE CLASS="Code T1.Text1">score</CODE> parameter. Each time this method is called, it updates the <CODE CLASS="Code T1.Text1">score</CODE> parameter and returns its new value.</P>
<PRE CLASS=Cv.Code>
define method make-score (points :: &lt;number&gt;)
  method (increase :: &lt;number&gt;)
    points := points + increase;
  end method;
end method make-score;
define constant score-david = make-score(100)
define constant score-diane = make-score(400)
score-david(0)
<CODE CLASS="cv Cv.Code"> fi</CODE>  100
score-david(10)
<CODE CLASS="cv Cv.Code"> fi</CODE>  110
score-david(10)
<CODE CLASS="cv Cv.Code"> fi</CODE>  120
score-diane(10)
<CODE CLASS="cv Cv.Code"> fi</CODE>  410
score-david(0)
<CODE CLASS="cv Cv.Code"> fi</CODE>  120
</PRE>
<P CLASS=T1.Text1>Each invocation of <CODE CLASS="Code T1.Text1">make-score</CODE> creates a new binding for <CODE CLASS="Code T1.Text1">score</CODE>, so each closure returned by <CODE CLASS="Code T1.Text1">make-score</CODE> refers to a different binding. In this way, assignments to the variable made by one closure do not affect the value of the variable visible to other closures.</P>
<P CLASS=T1.Text1>The following example defines a method for <CODE CLASS=T1.Text1>double</CODE> that works on functions. When you double a function, you get back a method that accepts arguments and calls the function twice, passing the same arguments both times. The method that is returned is closed over the function that was passed in as an argument.</P>
<PRE CLASS=Cv.Code>
define method double (internal-method :: &lt;function&gt;)
  method (#rest args)
    apply (internal-method, args);
    apply (internal-method, args);
    #f
  end method
end method;
<CODE CLASS="cv Cv.Code">define constant double-david = double(score-david);</CODE>
<CODE CLASS="cv Cv.Code">score-david(0)
 fi</CODE>  <CODE CLASS="cv Cv.Code">120
double-david(10)
 fi</CODE>  <CODE CLASS="cv Cv.Code">140
score-david(0)
 fi</CODE>  <CODE CLASS="cv Cv.Code">140<A NAME=MARKER-2-780></A><A NAME=MARKER-2-781></A></CODE>
</PRE>

</DIV>

<DIV CLASS=WM-DIV-FOOTERS>

<DIV CLASS=WM-DIV-TOC>

<!-- TOC --><DL CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_48.htm#HEADING48-7" CLASS=FOOTER><B CLASS=FOOTER></B>Generic Functions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_48.htm#HEADING48-17" CLASS=FOOTER><B CLASS=FOOTER></B>Methods</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_48.htm#HEADING48-23" CLASS=FOOTER><B CLASS=FOOTER></B>Methods in Generic Functions</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_48.htm#HEADING48-30" CLASS=FOOTER><B CLASS=FOOTER></B>Local Methods</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_48.htm#HEADING48-35" CLASS=FOOTER><B CLASS=FOOTER></B>Bare Methods</A>
<DD CLASS=FOOTER>
<DT CLASS=FOOTER><A REL=BELOW HREF="drm_48.htm#HEADING48-43" CLASS=FOOTER><B CLASS=FOOTER></B>Closures</A>
<DD CLASS=FOOTER>
</DL>


</DIV>

<HR CLASS=FOOTER>
<ADDRESS CLASS=FOOTER>The Dylan Reference Manual - 7 Apr 1998</ADDRESS>
<P CLASS=FOOTER><A HREF="drm_49.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=next.gif CLASS=HEADER></A> <A HREF="drm_47.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=prev.gif CLASS=HEADER></A> <A HREF="drm_47.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=up.gif CLASS=HEADER></A> <A HREF="drm_1.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=top.gif CLASS=HEADER></A> <A HREF="drm_2.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=content.gif CLASS=HEADER></A> <A HREF="drm_127.htm" CLASS=HEADER><IMG ALIGN=BOTTOM BORDER=0 SRC=index.gif CLASS=HEADER></A></P>
<P CLASS=FOOTER>Copyright Apple Computer, Inc. 1996. Apple&#174; and the Apple logo are registered trademarks of Apple Computer, Inc. Used with permission. All Rights Reserved.</P>
<P CLASS=FOOTER>You can order a <A HREF="http://www.harlequin.com/products/ads/dylan/purchase.shtml" CLASS=FOOTER>bound copy</A> of this book from Harlequin.</P>
<P CLASS=FOOTER>Generated with <A HREF="http://www.harlequin.com/webmaker" CLASS=FOOTER>Harlequin WebMaker&#174;</A></P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_12.HTM">
<LINK REL=PREV HREF="DB_12.HTM">
<LINK REL=NEXT HREF="DB_14.HTM">
<TITLE>1.1   Comparison of Dylan and other programming languages</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING13></A>

<DIV>
<P><A HREF="DB_14.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_12.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING13-0></A>
<H1>1.1   Comparison of Dylan and other programming languages</H1>
<P> Each language in wide use for applications has advantages and disadvantages. One way to compare languages is to imagine them arrayed along two axes. One axis ranges from <B>procedural</B> to <B>object-oriented</B> languages. The other axis ranges from <B>static</B> to <B>dynamic</B> languages. <A HREF="#MARKER-9-26">Figure 1.1</A> shows the comparison of several popular computer-programming languages on a graph.</P>
<UL>
<LI><P>A program in a <B>procedural</B> language consists of <B>functions</B> operating on <B>data</B>. The programming task is to choose the best available representation for data, and the best algorithms for manipulating the data. Languages near the procedural end of the axis include C, FORTRAN, and COBOL.</P>
<LI><P>A program in an <B>object-oriented</B> language consists of <B>objects</B>, categorized by <B>class</B>, that combine data and behavior. The programming task is to define the best class relations to represent objects, and the best set of operations that objects of related classes support. Languages near the object-oriented end of the axis include C++, Java, Smalltalk, and the Common LISP Object System (CLOS).</P>
<LI><P>A <B>static</B> language requires most program structure -- such as the types of variables and function arguments -- to be determined at compile time. The compiler can detect errors and optimize performance at the cost of run-time flexibility. Languages near the static end of the axis include C, C++, and FORTRAN.</P>
<LI><P>A <B>dynamic</B> language allows you to make more run-time changes to program structure, such as passing arguments of different types to the same function and, in some languages, defining new types or classes. A dynamic environment might allow run-time definition and linking. Languages near the dynamic end of the axis include Common LISP and Smalltalk.</P>
</UL>
<P> In reality, few languages in commercial use are purely procedural or object oriented, purely static or dynamic. In fact, the trend has been to add missing elements from one pole to languages that are close to the opposite pole. C++ adds object-oriented features to C; dynamic linking is becoming more common; LISP and Smalltalk vendors have made applications smaller and more efficient. This work, however, is hampered by the need to maintain compatibility with features of the language that were not designed with objects, dynamism, or performance in mind.</P>
<TABLE BORDER=1><CAPTION><P>Figure 1.1   <A NAME=MARKER-9-26></A>Object-oriented and dynamic extents of programming languages. </P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB13IMA2.GIF></P>
</TD></TR></TABLE><P> Dylan, in contrast, is a new language that integrates the best ideas from object-oriented, procedural, dynamic, and static languages, while avoiding many of the drawbacks. <A HREF="#MARKER-9-27">Figure 1.2</A> shows where Dylan fits on the graph.</P>
<TABLE BORDER=1><CAPTION><P>Figure 1.2   <A NAME=MARKER-9-27></A>Object-oriented and dynamic extents of Dylan and other languages. </P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB13IMA3.GIF></P>
</TD></TR></TABLE><P>Dylan's goals are simple:</P>
<UL>
<LI><P>Promote modular, reusable, component-oriented programs.</P>
<LI><P>Support powerful and familiar procedural programming.</P>
<LI><P>Encourage rapid and productive development of programs.</P>
<LI><P>Permit delivery of safe, efficient, compact applications.</P>
</UL>
<P> Let's take a brief look at features of Dylan that support these goals.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_14.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_12.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

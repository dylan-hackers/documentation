<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_320.HTM">
<LINK REL=PREV HREF="DB_320.HTM">
<LINK REL=NEXT HREF="DB_322.HTM">
<TITLE>20.2.1   Signaling conditions</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING321></A>

<DIV>
<P><A HREF="DB_322.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_320.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING321-0></A>
<H1>20.2.1   <A NAME=MARKER-9-824></A>Signaling <A NAME=MARKER-2-825></A>conditions</H1>
<P> Dylan provides a structured mechanism for indicating that an unusual event or exceptional situation has occurred during the execution of a program. Using this mechanism is called <B>signaling a condition</B>. A <A NAME=MARKER-2-826></A><B>condition</B> is an instance of the <A NAME=MARKER-2-827></A><CODE>&lt;condition&gt;</CODE> class, which represents a problem or unusual situation encountered during program execution. </P>
<P>To signal a condition, we need to take these steps:</P>
<P>1.  Define a condition class, which must be a subclass of <CODE>&lt;condition&gt;</CODE>. The condition class should have slots that are appropriate for the application. In this example, we define a condition class named <CODE>&lt;time-error&gt;</CODE> to be a direct subclass of <CODE>&lt;error&gt;</CODE>. Note that <A NAME=MARKER-2-828></A><CODE>&lt;error&gt;</CODE> is a subclass of <CODE>&lt;condition&gt;</CODE>. We defined <CODE>&lt;time-error&gt;</CODE> to inherit from <CODE>&lt;error&gt;</CODE>, because in case our application does not handle the exception, we want Dylan always to take some action, such as entering a debugger. If <CODE>&lt;time-error&gt;</CODE> inherited from <CODE>&lt;condition&gt;</CODE> and the application failed to handle the exception, then the exception might simply be ignored.</P>
<P>2.  Modify the functions that might detect the exception. These functions must make an instance of the condition class, and must use an appropriate Dylan function to initiate the signaling process. In this example, we redefine the <CODE>+ </CODE>method to signal the condition with the <CODE>error</CODE> function.</P>
<P> In the following code, we define a condition named <CODE>&lt;time-error&gt;</CODE> to represent any kind of time error, and we define a condition named <CODE>&lt;time-boundary-error&gt;</CODE> to represent violations of time-of-day bounds. </P>
<P> </P>
<PRE>
define abstract class &lt;time-error&gt; (&lt;error&gt;)
  constant slot invalid-time :: &lt;time&gt;, required-init-keyword: invalid-time:;
end class &lt;time-error&gt;;
define method say (condition :: &lt;time-error&gt;) =&gt; ()
  format-out(&quot;The time &quot;);
  say(condition.invalid-time);
  format-out(&quot; is invalid.&quot;);
end method say;
define class &lt;time-boundary-error&gt; (&lt;time-error&gt;)
<I>  // Inclusive bound
</I>  constant slot min-valid-time 
    :: &lt;time&gt;, required-init-keyword: min-time:;
<I>  // Exclusive bound
</I>  constant slot valid-time-limit 
    :: &lt;time&gt;, required-init-keyword: time-limit:;
end class &lt;time-boundary-error&gt;;
define method say (condition :: &lt;time-boundary-error&gt;) =&gt; ()
  next-method();
  format-out(&quot;\nIt must not be less than &quot;);
  say(condition.min-valid-time);
  format-out(&quot; and must be less than &quot;);
  say(condition.valid-time-limit);
  format-out(&quot;.&quot;);
end method say;
</PRE>
<P> We redefine the <CODE>+</CODE> method to signal the <CODE>&lt;time-boundary-error&gt;</CODE> condition (instead of returning an error string) to indicate that this problem has occurred:</P>
<PRE>
define method \+ (offset :: &lt;time-offset&gt;, time-of-day :: &lt;time-of-day&gt;)
  =&gt; (sum :: &lt;time-of-day&gt;)
  let sum 
    = make(&lt;time-of-day&gt;, 
           total-seconds: 
             offset.total-seconds + time-of-day.total-seconds);
  if (sum &gt;= $midnight &amp; sum &lt; $tomorrow)
    sum;
  else 
    error(make(&lt;time-boundary-error&gt;, invalid-time: sum,
               min-time: $midnight, time-limit: $tomorrow));
  end if;
end method \+;
</PRE>
<P> We create the condition with <CODE>make</CODE>, just as we create instances of other classes. We call the <A NAME=MARKER-2-829></A><CODE>error</CODE> function to signal the condition. The <CODE>error</CODE> function is guaranteed never to return to its caller. </P>
<P>Now we can specify an exact return value for the <CODE>+</CODE> method, because we are no longer returning an error string to indicate a problem with the addition.</P>
<P>In previous chapters (for example, in <A HREF="DB_88.HTM#MARKER-9-248">Section 6.1.3, page 78</A>), we called the <CODE>error</CODE> function with a string. Given a string as its first argument, the <CODE>error</CODE> function creates a general-purpose condition named <A NAME=MARKER-2-830></A><CODE>&lt;simple-error&gt;</CODE> and stores its arguments in the condition instance. In the preceding example, however, we created an instance of a condition that is customized for our program (<CODE>&lt;time-boundary-error&gt;</CODE>), and then supplied that condition to the <CODE>error</CODE> function. This approach provides information that is more readily accessible to the code that will handle the condition. Conditions, like any other Dylan class, can use inheritance, and can participate in generic function dispatch. For example, we define <CODE>say</CODE> methods for our errors, so that our handlers can provide a reasonable error message to the user. (Unfortunately, Dylan debuggers do not yet have a standard way to know about our <CODE>say</CODE> generic function. We expect that Dylan will eventually support such a mechanism.)</P>
<P>Supplying a specific condition to the <CODE>error</CODE> function brings the full power of Dylan's object-oriented programming capabilities to the task of signaling and handling exceptional situations.</P>
<P>Once the <CODE>error</CODE> function receives a condition instance, or makes an instance of <CODE>&lt;simple-error&gt;</CODE> itself, Dylan begins a process of attempting to resolve the situation represented by the condition. We present the details of condition resolution in the next section.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_322.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_320.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

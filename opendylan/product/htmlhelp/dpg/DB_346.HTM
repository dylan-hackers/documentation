<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_345.HTM">
<LINK REL=PREV HREF="DB_345.HTM">
<LINK REL=NEXT HREF="DB_347.HTM">
<TITLE>B.1   The concept of pointers</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING346></A>

<DIV>
<P><A HREF="DB_347.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_345.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING346-0></A>
<H1>B.1   The concept of <A NAME=MARKER-2-928></A>pointers</H1>
<P> If you are familiar with a language with explicit pointers, such as C, you may be confused initially by Dylan's object model. Although there is no "pointer-to" operation in Dylan, there are pointers in the implementation. If you are trying to imagine how Dylan objects are implemented, it is better to think in terms of always manipulating a pointer to the object: A Dylan variable (or slot) stores a pointer to an object, rather than a copy of the object's slots. Similarly, assignment, argument passing, and identity comparison are in terms of pointers to objects.</P>
<P>Even characters and numbers can be <I>considered</I> as objects that are pointed to (objects with an unmodifiable value slot), making the object model uniform. But compilers optimize away the indirection for these built-in classes.</P>
<P>Note that <CODE>=</CODE> comparison defaults to pointer comparison, but can be customized by class. There are sensible customizations built-in for characters, numbers, collections, sequences, and lists. You can add your own customizations for classes that you create.</P>
<P>Consider this Dylan code:</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> Dylan object example. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
define class &lt;color&gt; (&lt;object&gt;)
  slot red :: &lt;integer&gt; = 0, init-keyword: red:;
  slot green :: &lt;integer&gt; = 0, init-keyword: green:;
  slot blue :: &lt;integer&gt; = 0, init-keyword: blue:;
end class &lt;color&gt;;
</TD></TR><TR VALIGN=TOP><TD>define constant black = make(&lt;color&gt;);
</TD></TR><TR VALIGN=TOP><TD>define constant white
  = make(&lt;color&gt;, red: 2 ^ 24 - 1, green: 2 ^ 24 - 1, blue: 2 ^ 24 - 1);
</TD></TR><TR VALIGN=TOP><TD>define method whiteness-test(color :: &lt;color&gt;)
  if (color = white) format-out(&quot;It's white!\n&quot;) end;
end method whiteness-test;
</TD></TR><TR VALIGN=TOP><TD>define variable color = black;
</TD></TR><TR VALIGN=TOP><TD>color := white;
whiteness-test(color);
</TD></TR></TABLE></PRE>
<P> </P>
<P> The equivalent C code is as follows:</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> C equivalent of Dylan object example. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
typedef struct _color
  { int red, green, blue; }
Color;
</TD></TR><TR VALIGN=TOP><TD>static Color _black = {0, 0, 0};
Color* const black = &amp;_black;
</TD></TR><TR VALIGN=TOP><TD>static Color _white = {16777215, 16777215, 16777215};
Color* const white = &amp;_white;
</TD></TR><TR VALIGN=TOP><TD>void whitenessTest(Color* const color) {
  if (color == white) { printf(&quot;It's white!\n&quot;); }
}
</TD></TR><TR VALIGN=TOP><TD>void main () {
  Color* color = black;

  color = white;
  whitenessTest(color);
}
</TD></TR></TABLE></PRE>
<P> </P>
<P> The benefit of the Dylan model is that the final two statements are a single pointer assignment and a passing of a single pointer as a parameter. The comparison in whitenessTest is a single pointer comparison. Another possible C implementation -- one more typical of C style, but <I>not</I> equivalent to the Dylan implementation -- is as follows:</P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> C-style example, without pointers. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
typedef struct _color
  { int red, green, blue; }
Color;
</TD></TR><TR VALIGN=TOP><TD>Color const black = {0, 0, 0};
Color const white = {16777215, 16777215, 16777215};
void whitenessTest(Color const color) {
  if (color.red == white.red &amp;&amp;
      color.green == white.green &amp;&amp;
      color.blue == white.blue)
  { printf(&quot;It's white!\n&quot;); }
}
void main () {
  Color color = black;

  	color = white;
  whitenessTest(color);
}
</TD></TR></TABLE></PRE>
<P> In the C-style example, without pointers, the final two statements consist of three integer assignments (as the <CODE>Color</CODE> structure is copied), and a passing of a three-slot structure (the equivalent of three arguments) as an argument. The comparison in whitenessTest is three integer comparisons (as the two <CODE>Color</CODE> structures are compared, slot by slot).</P>
<P>The drawback of the Dylan object example is shown here:</P>
<PRE>
color.blue := 0;
</PRE>
<P> The preceding call makes <CODE>white</CODE> yellow! In the C-style example, without pointers, you would make only <CODE>color</CODE> yellow. You can prevent people from changing defined colors to other colors in Dylan by not allowing the slots of <CODE>&lt;color&gt;</CODE> objects to be modified once they are initialized -- in other words, by making <CODE>&lt;color&gt;</CODE> objects <I>immutable</I>:</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> Dylan object example, with immutable objects. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
define class &lt;color&gt; (&lt;object&gt;)
  constant slot red :: &lt;integer&gt; = 0, init-keyword: red:;
  constant slot green :: &lt;integer&gt; = 0, init-keyword: green:;
  constant slot blue :: &lt;integer&gt; = 0, init-keyword: blue:;
end class &lt;color&gt;;
define constant black = make(&lt;color&gt;);
define constant white
  = make(&lt;color&gt;, red: 2 ^ 24 - 1, green: 2 ^ 24 - 1, blue: 2 ^ 24 - 1);
define variable color = black;
define method whiteness-test(color :: &lt;color&gt;)
  if (color = white) format-out(&quot;It's white!\n&quot;) end;
end method whiteness-test;
color := white;
whiteness-test(color);
</TD></TR></TABLE></PRE>
<P> </P>
<P> You can consider Dylan as always using pointers, even to objects such as integers and characters. Integers and characters are, by definition, immutable objects: There are no slots that you can change in an integer or character object. Thus, there is no danger of setting 6 to 9. Built-in immutable objects can have their pointers optimized away by the compiler: The compiler just has to arrange that <BR>6 = 6 and 9 = 9, whether there is only one 6 object pointed to by all the variables with the value 6, or copies of 6 are stored in each of those variables (saving the need for a pointer).</P>
<P>Another difficulty in the Dylan model is this potentially embarrassing <BR>situation:</P>
<PRE>
color := make(&lt;color&gt;, red: 2 ^ 24 - 1, green: 2 ^ 24 - 1, blue: 2 ^ 24 - 1);
if (color = white) format-out(&quot;It's white!\n&quot;) end;
</PRE>
<P> The preceding expression might not say "It's white!", because <CODE>make</CODE> might return a new object with white RGB values, and that object would not be <CODE>=</CODE> to the object named <CODE>white</CODE>. The equivalent C code would be:</P>
<PRE>
Color* make_color(int r, int g, int b) {
  Color* c = (Color*)malloc(sizeof(Color));
  c-&gt;red = r; c-&gt;green = g; c-&gt;blue = b;
  return c;
}
static Color _white = {16777215, 16777215, 16777215};
Color* const white = &amp;_white;
Color* color = make_color(16777215, 16777215, 16777215);
if (color == white) { printf(&quot;It's white!\n&quot;); };
</PRE>
<P> Because the preceding code is comparing the pointer stored in <CODE>white</CODE> to the pointer stored in <CODE>color</CODE>, it will clearly not say "It's white!". The default implementation of <CODE>=</CODE> in Dylan is to compare pointers. </P>
<P>There are several solutions to this difficulty in Dylan. One is to customize the <CODE>=</CODE> comparison operator for our class to do a comparison more thorough than the default comparison:</P>
<PRE>
define met<CODE>h</CODE>od \= (o1 :: &lt;color&gt;, o2 :: &lt;color&gt;)
  o1.red = o2.red &amp; o1.green = o2.green &amp; o1.blue = o2.blue;
end met<CODE>h</CODE>od \=;
</PRE>
<P> Now, using <CODE>=</CODE> will compare colors by checking their individual RGB components, and our whiteness test will work. </P>
<P>Note that Dylan also provides the <CODE>==</CODE> comparison operator, which always compares pointers. This comparison is useful when you want to check object identity. But, as we have seen, it is not always the appropriate default for comparison of equality of objects. The compiler can avoid calling our <CODE>\=</CODE> method altogether if the same object is compared to itself. It can do so because, with the exception of IEEE NaNs (nonnumbers), values that are <CODE>==</CODE> must also be <CODE>=</CODE>.</P>
<P>Another approach that you can use if your objects are immutable is to make sure that they are unique. The <CODE>m<A NAME=MARKER-2-929></A>ake</CODE> function is not required to return a new object each time, as shown in the Dylan object example, with unique, immutable objects.</P>
<P>This advanced use of <CODE>make</CODE> and tables ensures that there is always only one instance of each color. Thus, when we make another white, it will always be <I>the</I> white, and our whiteness test will work with the default <CODE>=</CODE> comparison. The choice of solution depends on whether you will be doing more making or more <BR>comparing. </P>
<P></P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> Dylan object example, with unique, immutable objects. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
define class &lt;color-table&gt; (&lt;table&gt;)
end class &lt;color-table&gt;;
define method table-protocol(&lt;color-table&gt;)
  local method color-hash(color :: &lt;color&gt;)
    let (red-id, red-state) = object-hash(color.red);
    let (grn-id, grn-state) = object-hash(color.green);
    let (blu-id, blu-state) = object-hash(color.blue);
    let (merge-id, merge-state) =
      merge-hash-codes(red-id, red-state,
                       grn-id, grn-state, ordered: #t);
    merge-hash-codes(merge-id, merge-state,
                     blu-id, blu-state, ordered: #t);
  end;
  local method color-test(o1 :: &lt;color&gt;, o2 :: &lt;color&gt;)
    o1.red = o2.red &amp; o1.green = o2.green &amp; o1.blue = o2.blue;
  end;
  values(color-test, color-hash)
end method table-protocol;
define variable color-table = make(&lt;color-table&gt;);
define method make(class == &lt;color&gt;, #key red, green, blue)
  let prototype = next-method();
  element(color-table, prototype, default: #f) |
    (color-table[prototype] := prototype);
end method make;
</TD></TR></TABLE></PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_347.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_345.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_113.HTM">
<LINK REL=PREV HREF="DB_115.HTM">
<LINK REL=NEXT HREF="DB_117.HTM">
<TITLE>9.3.3   Method dispatch and unions</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING116></A>

<DIV>
<P><A HREF="DB_117.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_115.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING116-0></A>
<H1>9.3.3   <A NAME=MARKER-9-304></A>Method <A NAME=MARKER-2-305></A>dispatch and unions</H1>
<P> When a type is a union, Dylan uses the following rules:</P>
<P>1.  An object is an instance of a union if it is an instance of any of the types that make up that union.</P>
<P>2.  If none of the types that make up a union is a subtype of any other, then </P>
<UL>
<UL>
<LI><P>A nonunion type is a proper subtype of a union if the nonunion type is a subtype of any of the types that make up the union.</P>
<LI><P>A union is a proper subtype of a nonunion type if all types that make up the union are subtypes of the nonunion type, and if all the types that make up the union, taken together, are not equivalent to the nonunion type.</P>
<LI><P>A union is a proper subtype of another union if <I>each</I> of the types that make up the first union is a subtype of <I>one</I> of the types that make up the other union, and if the two unions are not equivalent.</P>
</UL>
</UL>
<P> For example, suppose that we have these definitions:</P>
<PRE>
define constant &lt;false-or-integer&gt; = type-union(&lt;integer&gt;, singleton(#f));
<I>// Method 1
</I>define method say (x :: &lt;false-or-integer&gt;) ... end method say;
<I>// Method 2
</I>define method say (x :: &lt;integer&gt;) ... end method say;
</PRE>
<P> Now, if <CODE>say</CODE> is called with an argument that is an integer, both methods are applicable, and method 2 is more specific than method 1. If <CODE>say</CODE> is called with an argument of <CODE>#f</CODE>, only method 1 is applicable.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_117.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_115.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

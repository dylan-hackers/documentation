<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_295.HTM">
<LINK REL=PREV HREF="DB_306.HTM">
<LINK REL=NEXT HREF="DB_308.HTM">
<TITLE>19.12   Slot accessors</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING307></A>

<DIV>
<P><A HREF="DB_308.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_306.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING307-0></A>
<H1>19.12   Sl<A NAME=MARKER-2-794></A>ot accessors</H1>
<P> Dylan does allow you to omit definition of a generic function. As we mentioned earlier, if you define a method without also defining a generic function, Dylan implicitly creates a generic function with the most general types for the parameters and return values that are compatible with the method. The most common case of implicit generic functions is for the slot-accessor methods that are created when a new class is defined. Because these generic functions typically have only a single method and are <B>sealed</B> by default (see <A HREF="DB_304.HTM#MARKER-9-782">Section 19.9</A>), the compiler can make extensive optimizations for slot accessors, ideally making slot access no more expensive than an array reference or structure-member access in other languages.</P>
<P>Even when a slot is inherited by subclassing, a good Dylan compiler will use a <A NAME=MARKER-2-795></A><B>coloring algorithm</B> to assign slots to the same offset in each subclass, keeping the cost of slot access to a minimum. You can use primary classes (see <A HREF="DB_308.HTM#MARKER-9-798">Section 19.13</A>) to guarantee efficient slot access.When a program defines explicit methods for a slot getter or setter generic function, of course, the overhead is greater. </P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-755></A>C++:</B> Dylan classes are similar to virtual base classes with virtual data members in that the offsets of their data members are not fixed, and access to the data members can be overridden. See <A HREF="DB_347.HTM#MARKER-9-930">Section B.2</A> in <A HREF="DB_345.HTM#MARKER-9-926">Appendix B,  <I>Dylan Object Model for C and C++ Programmers</I></A>, for a more detailed analogy.</P>
</TD></TR></TABLE><P> </P>
<P> In the <CODE>&lt;sixty-unit&gt;</CODE> class, we specified an initial value for <CODE>total-seconds</CODE>; hence, there is no need to check that the slot has been initialized before it is accessed. In some situations, it may not be feasible to give a default or initial value for a slot. Dylan permits this omission and will ensure that the slot is initialized before that slot is used; of course, this check does not come for free, so it is preferable to provide initial values where possible. In fact, because we always expect to initialize the <CODE>total-seconds</CODE> slot when we make a new <CODE>&lt;sixty-unit&gt;</CODE>, it would be more accurate to specify <CODE>&lt;sixty-unit&gt;</CODE> as follows:</P>
<PRE>
define open abstract class &lt;sixty-unit&gt; (&lt;object&gt;)
  slot total-seconds :: &lt;integer&gt;,
    required-init-keyword: total-seconds:,
end class &lt;sixty-unit&gt;;
</PRE>
<P> That is, rather than giving the slot an initial value of <CODE>0</CODE> and an optional <BR><CODE>init-keyword:</CODE>, we simply require that the slot be initialized when we make a <CODE>&lt;sixty-unit&gt;</CODE> object. Of course, the initial value must obey the type constraint of <CODE>&lt;integer&gt;</CODE>. The compiler can still make the inference that the slot will always be initialized and will always have an integer value.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-750></A>C:</B> Dylan always ensures that a slot is initialized before that slot is accessed, automatically inserting a run-time check when it cannot prove at compile time that the slot is always properly initialized. C puts this burden of safety on the programmer, and that can be the source of subtle bugs. A number of debugging and analysis tools are available as addons to C, to help the programmer with this task.</P>
</TD></TR></TABLE><P> </P>
<P> Always initializing slots, either with a default value or required init-keyword, will make slot access efficient.</P>
<P>Finally, in many cases, slots hold values that will not change over the lifetime of each instance (although they may be different values for each instance). In the case of the <CODE>&lt;sixty-unit&gt;</CODE> class, we never change the value of <CODE>total-<BR>seconds</CODE>. When adding two instances, we create a new one to hold the new value, rather than changing one of the argument instances (that way, we do not have to worry about changing an instance that may still be in use by some other part of the program). In such cases, declaring the slot to be <A NAME=MARKER-2-796></A><CODE>constant</CODE> both documents and enforces this intent. Furthermore, the compiler can often make additional optimizations for slots that are known never to be modified. The final definition of <CODE>&lt;sixty-unit&gt;</CODE> is as follows:</P>
<PRE>
define open abstract class &lt;sixty-unit&gt; (&lt;object&gt;)
  constant slot total-seconds :: &lt;integer&gt;,
    required-init-keyword: total-seconds:,
end class &lt;sixty-unit&gt;;
</PRE>
<P> (The <CODE>constant</CODE> declaration is simply shorthand for the slot option <CODE>setter: #f</CODE>, meaning that there is no way to set the slot.)</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_308.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_306.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_295.HTM">
<LINK REL=PREV HREF="DB_307.HTM">
<LINK REL=NEXT HREF="DB_309.HTM">
<TITLE>19.13   Primary classes</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING308></A>

<DIV>
<P><A HREF="DB_309.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_307.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING308-0></A>
<H1>19.13   <A NAME=MARKER-10-797></A><A NAME=MARKER-9-798></A>Prim<A NAME=MARKER-2-799></A>ary classes</H1>
<P> Classes have one additional variation that you can use to optimize performance. A class that is defined as <CODE>primary</CODE> allows the compiler to generate the most efficient code for accessing the slots defined in the primary class (whether the accessor is applied to the primary class or to one of that class's subclasses). However, a primary class cannot be combined with any other primary class (unless one is a subclass of the other). This restriction implies that you should delay declaring a class to be primary until you are sure of your inheritance design. Also, because sealed classes are already highly optimized, the <CODE>primary</CODE> declaration is of most use for open classes.</P>
<P>As an example, consider the class <CODE>&lt;sixty-unit&gt;</CODE>, and its slot <CODE>total-<BR>seconds</CODE>, as used in this method for <CODE>decode-total-seconds</CODE>:</P>
<PRE>
define method decode-total-seconds 
    (sixty-unit :: &lt;sixty-unit&gt;)
 =&gt; (hours :: &lt;integer&gt;, minutes :: &lt;integer&gt;, seconds :: &lt;integer&gt;)
  decode-total-seconds(sixty-unit.total-seconds);
end method decode-total-seconds; 
</PRE>
<P> Although the generic function for the slot accessor <CODE>total-seconds</CODE> is sealed, and it is trivial for the compiler to infer that its argument is a <CODE>&lt;sixty-unit&gt;</CODE> in the call <CODE>sixty-unit.total-seconds</CODE>, because <CODE>&lt;sixty-unit&gt;</CODE> is declared open, the <BR>compiler cannot emit the most efficient code for that call. Because an open class could be mixed with any number of other classes, there is no guarantee that the slots of every object that is a <CODE>&lt;sixty-unit&gt;</CODE> will always be stored in the same order --there is no guarantee that <CODE>total-seconds</CODE> will always be the first slot in an object that is an indirect instance of <CODE>&lt;sixty-unit&gt;</CODE>, for instance. </P>
<P>Declaring a class <CODE>primary</CODE> is essentially making a guarantee that the compiler can always put the primary class's slots in the same place in an instance, <BR>and that any other superclasses will have to adjust:</P>
<PRE>
define abstract open primary class &lt;sixty-unit&gt; (&lt;object&gt;)
  constant slot total-seconds :: &lt;integer&gt;,
    required-init-keyword: total-seconds:;
end class &lt;sixty-unit&gt;;
</PRE>
<P> By adding the <CODE>primary</CODE> declaration to the definition, any library that subclasses <CODE>&lt;sixty-unit&gt;</CODE> is guaranteed to put <CODE>total-seconds</CODE> at the same offset. Hence, the compiler can turn the call <CODE>sixty-unit.total-seconds</CODE> into a single machine instruction (load with constant offset), without concern over which subclass of <CODE>&lt;sixty-unit&gt;</CODE> was passed as an argument.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-747></A>C++: </B>A primary class is like an ordinary base class in C++. Because only one primary class is allowed as a base class, its data members can be assigned the same fixed offset for all derived classes. See <A HREF="DB_347.HTM#MARKER-9-930">Appendix B.2,  <I>The concept of classes</I></A>, for a more detailed analogy.</P>
</TD></TR></TABLE><P> </P>
<P> It is permissible to make subclasses of a primary class also primary, essentially freezing the assignment of all the slots in the subclass too. What is not permissible is to multiply inherit from more than one primary class; as you can see, such behavior would lead to a conflict between the fixed slot assignments.</P>
<P>Because primary classes restrict extension in this way, you should use them sparingly in libraries intended to be software components. Primary classes are of most benefit in large, modular programs, where all the clients of each component are known, and the need for extensibility is bounded; typically that occurs toward the end of a project, when you are tuning for performance.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_309.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_307.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

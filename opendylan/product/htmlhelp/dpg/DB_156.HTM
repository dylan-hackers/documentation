<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_155.HTM">
<LINK REL=PREV HREF="DB_155.HTM">
<LINK REL=NEXT HREF="DB_157.HTM">
<TITLE>11.4.1   Reversal of sequences</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING156></A>

<DIV>
<P><A HREF="DB_157.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_155.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING156-0></A>
<H1>11.4.1   <A NAME=MARKER-9-419></A>Reversal of sequences</H1>
<P> Dylan provides two generic functions for reversing sequences: <A NAME=MARKER-2-420></A><CODE>reverse</CODE>, and <A NAME=MARKER-2-421></A><CODE>reverse!</CODE>. They both achieve the same objective, but <CODE>reverse!</CODE> is allowed to modify its argument, whereas <CODE>reverse</CODE> never modifies its argument. </P>
<PRE>
<I>?</I> reverse(&quot;lever&quot;);
<I>&quot;revel&quot;</I>
<I>?</I> define variable *switch* = vector(&quot;switch&quot;, &quot;on&quot;);
<I>?</I> reverse(*switch*);
<I>#[&quot;on&quot;, &quot;switch&quot;]</I>
<I>?</I> *switch*;
<I>#[&quot;switch&quot;, &quot;on&quot;]</I>
<I>? </I>reverse!(*switch*);
<I>#[&quot;on&quot;, &quot;switch&quot;]</I>
</PRE>
<P> After the call to <CODE>reverse!</CODE>, the value of <CODE>*switch*</CODE> is not defined. Only the return value from <CODE>reverse!</CODE> will be meaningful. If we want <CODE>*switch*</CODE> to contain the reversed sequence, we must instead write</P>
<PRE>
<I>?</I> *switch* := reverse!(*switch*);
<I>#[&quot;on&quot;, &quot;switch&quot;]</I>
<I>?</I> *switch*;
<I>#[&quot;on&quot;, &quot;switch&quot;]</I>
</PRE>
<P> Note that <CODE>reverse!</CODE> cannot change the object to which <CODE>*switch*</CODE> refers; however, <CODE>reverse!</CODE> is allowed to alter the contents of that object. Also note that <CODE>reverse!</CODE> may not return the same object as that you provide as its argument. Consider the case of using <CODE>reverse!</CODE> on a list to see how this behavior can be useful. </P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Conventio<A NAME=MARKER-2-363></A>n:</B> Dylan has a convention of putting an exclamation point at the ends of the names of functions that can destructively modify their arguments. For example, <CODE>reverse!</CODE> takes a sequence, and returns a sequence that has the same elements but in reverse order. The <CODE>reverse!</CODE> generic function may change the sequence that is its argument. In contrast, the <CODE>reverse</CODE> generic function performs a similar operation, but does not destructively modify its argument. Setters are an exception to this convention: They modify their argument, but do not typically end with <CODE>!</CODE>.</P>
</TD></TR></TABLE><P> </P>
<P> How can we write our own version of <CODE>reverse</CODE> using the iteration techniques presented so far?</P>
<PRE>
define method my-reverse (seq :: &lt;sequence&gt;) =&gt; (reversed-seq :: &lt;sequence&gt;)
  let reversed-seq = make(type-for-copy(seq), size: seq.size);
  for (destination-index from seq.size - 1 to 0 by -1,
       source-index from 0)
    reversed-seq[destination-index] := seq[source-index];
  end for;
  reversed-seq;
end method my-reverse;
</PRE>
<P> Once again, this algorithm is fine for vectors and strings, but has poor performance for lists. Here is a special <CODE>my-reverse</CODE> method for lists:</P>
<PRE>
define method my-reverse (old-list :: &lt;list&gt;) =&gt; (reversed-list :: &lt;list&gt;)
  let reversed-list = #();
  for (old-element in old-list)
    reversed-list := pair(old-element, reversed-list); 
  end for;
  reversed-list;
end method my-reverse;
</PRE>
<P> It is easy to build up a list from its end to its start, and that is exactly what we do in the preceding method. We start with the empty list, and add pairs to the reversed list whose heads are the elements of the argument. We follow the old list from its start to its end, while we build the new list from its end to its start, thus reversing the list. </P>
<P>It is important to remember that, even though we created a new sequence to contain the elements of the old sequence, we still share those old elements with the new sequence. If two elements of a collection refer to the same object, then modifying the element of one of the collections affects the value of the element of the other collection. We illustrate this behavior in <A HREF="DB_157.HTM#MARKER-9-422">Section 11.4.2</A>.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_157.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_155.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

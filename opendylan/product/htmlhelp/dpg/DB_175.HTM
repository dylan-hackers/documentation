<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_174.HTM">
<LINK REL=PREV HREF="DB_174.HTM">
<LINK REL=NEXT HREF="DB_176.HTM">
<TITLE>12.2.1   Parameters, arguments, and return values</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING175></A>

<DIV>
<P><A HREF="DB_176.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_174.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING175-0></A>
<H1>12.2.1   Parameters, arguments, and return values</H1>
<P> In Dylan, a function is called with zero or more <B>arguments<A NAME=MARKER-2-501></A></B>. The function can perform computations, which may have side effects. It then <B>returns</B> zero or more <BR><B>values<A NAME=MARKER-2-502></A></B> to its caller. Each argument and each returned value is an object.</P>
<P>A function has zero or more <B>parameters<A NAME=MARKER-2-503></A></B> that determine the number and types of arguments that the function takes. Following is a simplified description of what happens when a function is called (for a generic function, this description applies to the method that it invokes):</P>
<P>1.  An implicit <B>body<A NAME=MARKER-2-504></A></B> is entered. A body establishes the scope for all local variables bound inside the body.</P>
<P>2.  The parameters are matched with the arguments to the function.</P>
<P>3.  A local variable is created with the name of each parameter.</P>
<P>4.  Each parameter -- that is, each local variable with the name of a parameter -- is initialized, or bound, to one of the arguments. (In some cases, the parameter is bound to a list of arguments, or to a default value.)</P>
<P>5.  The code that makes up the actual body of the function is executed.</P>
<P> A function can have a <B>value declaration<A NAME=MARKER-2-505></A></B> that determines the number and types of values the function returns. If there is no explicit declaration, a default declaration allows the function to return any number of values of any type. Following is a simplified description of what happens when a function returns (for a generic function, this description applies to the method that it invokes):</P>
<P>1.  The values returned by the last expression in the function's implicit body are matched with the values declared in the value declaration.</P>
<P>2.  The function's implicit body is exited, ending the scope of all local variables (including parameters) established in that body.</P>
<P>3.  The values specified by the value declaration are returned to the caller of the function. (Depending on the value declaration, the number of values returned to the function's caller might be more or less than the number of values returned by the last expression in the function's body.)</P>
<P> Note these two important implications of the way that arguments are passed:</P>
<UL>
<LI><P>All bindings<A NAME=MARKER-2-506></A> of arguments to parameters are local to the body of the function called. Assignment to a parameter inside the called function's body does not affect any variables outside the body that have the same name.</P>
<P>For example, consider these definitions:</P>
</UL>
<PRE>
define method calling-function ()
  let x = 1;
  let y = 2;
  format-out(&quot;In calling function, before call: x = %d, y = %d\n&quot;, 
             x, y);
  called-function(x, y);
  format-out(&quot;In calling function, after call: x = %d, y = %d\n&quot;, x, y);
end method calling-function;
define method called-function (x, y)
  x := 3;
  y := 4;
  format-out(&quot;In called function, before return: x = %d, y = %d\n&quot;, 
             x, y);
end method called-function;
</PRE>
<P>A call to <CODE>calling-function</CODE> produces the following output:</P>
<PRE>
<I>In calling function, before call: x = 1, y = 2
In called function, before return: x = 3, y = 4
In calling function, after call: x = 1, y = 2</I>
</PRE>
<UL>
<LI><P>Although <I>parameters</I> are local to a function, all <I>arguments</I> and <I>return values</I> are shared between a function and its caller. If an argument or return value is a <B>mutable<A NAME=MARKER-2-507></A></B> object -- one that can be changed -- then any changes that a function makes to that object are visible to its caller.</P>
<P>Consider the following definitions:</P>
</UL>
<PRE>
define class &lt;test&gt; (&lt;object&gt;)
  slot test-slot, required-init-keyword: test-slot:;
end class &lt;test&gt;;
define method calling-function ()
  let x = make(&lt;test&gt;, test-slot: &quot;before&quot;);
  format-out(&quot;In calling function, before call: x.test-slot = %s\n&quot;,
             x.test-slot);
  called-function(x);
  format-out(&quot;In calling function, after call: x.test-slot = %s\n&quot;,
             x.test-slot);
end method calling-function;
define method called-function (x :: &lt;test&gt;)
  x.test-slot := &quot;after&quot;;
  format-out(&quot;In called function, before return: x.test-slot = %s\n&quot;,
             x.test-slot);
end method called-function;
</PRE>
<P>Note here that we have redefined the <CODE>calling-function</CODE> method, and have defined a new <CODE>called-function</CODE> method, which we first defined in the previous example. Our new <CODE>called-function</CODE> method has one parameter, whereas the previous method had two. The parameter list of this new method is not compatible with that of the previous method, and, if we actually tried to define the second <CODE>called-function</CODE> method, Dylan would signal an error. For more information on compatibility of parameter lists for generic functions and methods, see <A HREF="DB_179.HTM#MARKER-9-529">Section 12.2.5</A>.</P>
<P>A call to <CODE>calling-function</CODE> now produces the following output:</P>
<PRE>
<I>In calling function, before call: x.test-slot = &quot;before&quot;
In called function, before return: x.test-slot = &quot;after&quot;
In calling function, after call: x.test-slot = &quot;after&quot;</I>
</PRE>
<P>In this case, <CODE>x</CODE> in the calling function and <CODE>x</CODE> in the called function are different variables. But the <I>values</I> of both variables are the same object: the instance of <CODE>&lt;test&gt;</CODE> that we make in the calling function. The change to the slot value <BR>of this object that we make in the called function is visible to the calling function.</P>
<P>It is equally proper to think of arguments that are <B>immutable<A NAME=MARKER-2-508></A></B>, like integers, as being shared between a function and its caller. By definition, however, a function cannot make any changes to such objects that are visible to the function's caller.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Compariso<A NAME=MARKER-2-439></A>n with C and C++:</B> As in Dylan, the parameters<A NAME=MARKER-2-440></A> of a C function are local to the body of the function, and assignment to a parameter does not affect the value of a variable that has the same name in the function's caller. But the relationship between <B>objects</B> and <B>values</B> is not the same in C and in Dylan. In C, a value can be an object (roughly meaning the contents of the object) or a <B>pointer<A NAME=MARKER-2-441></A></B> to an object (roughly meaning the location of the object in memory). The value of a parameter in C is always a copy of the corresponding argument. When a C structure is an argument to a function, the value of the corresponding parameter is a copy of the structure; it is not the structure itself. If the function changes the value of a member of this structure, the change is not visible to the caller, because the function is changing only its own copy of the structure. But if the argument is a pointer to a structure, the function can gain access to the caller's structure (by <B>dereferencing</B> the pointer). If the function changes the value of a member of such a structure by dereferencing the pointer, the change is visible to the caller.</P>
<P>In Dylan, a value is always an object, which has a unique identity. The value of a parameter is always the same object as the corresponding argument. When a function changes such an object (as by changing the value of a slot), the change is always visible to the caller. Dylan has no equivalent to C pointers.</P>
<P>In C++, a parameter declared using ordinary C syntax also receives a copy of a structure or an instance that is the corresponding argument. C++ has additional syntax for declaring that a parameter is a <B>reference<A NAME=MARKER-2-442></A></B> -- essentially an implicit pointer -- to the corresponding argument. In this case the argument is not copied, and if the function changes the object that the parameter refers to, the changes are visible to the caller. In some ways Dylan's argument-passing protocol is similar to C++ references.</P>
<P>In both C and C++, array<A NAME=MARKER-2-443></A> arguments are always passed as pointers. In Dylan, arrays are instances of the <CODE>&lt;array&gt;</CODE> class, and array arguments are treated like all other arguments.</P>
<P>For more comparisons between Dylan and C objects, see <A HREF="DB_345.HTM#MARKER-9-926">Appendix B,  <I>Dylan Object Model for C and C++ Programmers</I></A>.</P>
</TD></TR></TABLE>
</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_176.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_174.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_295.HTM">
<LINK REL=PREV HREF="DB_298.HTM">
<LINK REL=NEXT HREF="DB_300.HTM">
<TITLE>19.4   Limited types</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING299></A>

<DIV>
<P><A HREF="DB_300.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_298.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING299-0></A>
<H1>19.4   <A NAME=MARKER-9-771></A>Lim<A NAME=MARKER-2-772></A>ited types</H1>
<P> Some of Dylan's built-in types are extremely general. When these types are used, the compiler's type inferencing is thwarted, and less efficient code will be generated. The place where this situation is most obvious is in the <CODE>&lt;collection&gt;</CODE> types, where the elements of a collection are essentially like multiple slots, all with the same type constraint. For the built-in collections, elements typically have a general default type (often simply <CODE>&lt;object&gt;</CODE>), and there can be an arbitrary number of them. The <CODE>limited</CODE> mechanism is a way to specify that you expect to store objects of a particular type in the collection, and to specify how many elements will be in the collection.</P>
<P>As an example, in <A HREF="DB_262.HTM#MARKER-9-709">Section 17.2</A>, page <A HREF="DB_264.HTM#MARKER-9-701">259</A>, the <CODE>generate-gates</CODE> method returns a <CODE>&lt;vector&gt;</CODE>. Without further information, the compiler must assume that that vector might contain objects of any types. As a result, the following code in the <CODE>build-simple-airport</CODE> method from <A HREF="DB_271.HTM#MARKER-9-712">Section 17.5</A>, page <A HREF="DB_271.HTM#MARKER-9-703">277</A>, will be <BR>inefficient:</P>
<PRE>
  let gates = generate-gates(gates-per-terminal, capacity);
  ...
  for (gate in gates)
    gate.connected-to := taxiway-vector;
  end for;
</PRE>
<P> Because the compiler can infer only that <CODE>gates</CODE> is a <CODE>&lt;vector&gt;</CODE>, it must generate extra code to determine whether each <CODE>gate</CODE> has a <CODE>connected-to</CODE> method on it. We can use limited types to constrain <CODE>gate-instances</CODE> as follows:</P>
<PRE>
define constant &lt;gate-vector&gt; = limited(&lt;vector&gt;, of: &lt;gate&gt;);
define method generate-gates
    (gates-per-terminal :: &lt;vector&gt;, default-gate-capacity :: &lt;size&gt;)
 =&gt; (gates :: &lt;gate-vector&gt;)
  let result = make(&lt;gate-vector&gt;, size: reduce1(\+, gates-per-terminal));
  ...
  values(result);
end method generate-gates;
</PRE>
<P> With the limited constraint of the return value of <CODE>generate-gates</CODE>, the compiler can ensure that only gate objects will ever be stored in the vector; hence, it can be sure that each <CODE>gate</CODE> will be a <CODE>&lt;gate&gt;</CODE> and will have a <CODE>connected-to</CODE> method. </P>
<P>Note that limited-collection types are instantiable types; that is, you can make an object of a limited type. This capability is different from similar constructs in certain other languages, in which those constructs are only an assertion about the range or type of values to be stored in the collection. Having declared the return value of <CODE>generate-gates</CODE> to be a <CODE>&lt;gate-vector&gt;</CODE>, it would be an error to return a <CODE>&lt;vector&gt;</CODE> instead; hence, we changed the argument to <CODE>make</CODE> when constructing <CODE>result</CODE> to be <CODE>&lt;gate-vector&gt;</CODE> instead of the original <CODE>&lt;vector&gt;</CODE>.</P>
<P>If <CODE>&lt;gate&gt;</CODE> and <CODE>connected-to</CODE> are not <B>open</B> (as described in <A HREF="DB_304.HTM#MARKER-9-782">Section 19.9</A> and <A HREF="DB_305.HTM#MARKER-9-786">Section 19.10</A>), the compiler can infer that <CODE>connected-to</CODE> is used here to set a slot in the gate instance and to further optimize the code generated. We do not delve into the exact details of what the compiler has to know to make this optimization, but it is worth noting that, if either the class or the generic function were open, the optimization could not be made.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison <A NAME=MARKER-2-748></A>with C++:</B> The Dylan limited-collection types provide a capability similar to that offered by the C++ template classes. Unlike in C++, the base type of a limited-collection type (the equivalent of a C++ class template -- in the example above, <CODE>&lt;vector&gt;</CODE>) is also a valid type. Dylan's dynamic capabilities mean that Dylan can defer determining the element type of a collection until run time, in effect adapting the class template as it goes along. By using a limited type, the compiler can generate more efficient code.</P>
</TD></TR></TABLE><P> </P>
<P> Another use of limited types is to allow compact representations. We can use <CODE>limited</CODE> with the built-in type <CODE>&lt;integer&gt;</CODE> to specify numbers with a limited range that can be stored more compactly than integers. It is especially useful to use a limited range in combination with a limited collection; for example,</P>
<PRE>
define constant &lt;signed-byte-vector&gt; 
  = limited(&lt;simple-vector&gt;,
            of: limited(&lt;integer&gt;, min: -128, max 127));
</PRE>
<P> In the preceding example, we define a type that can be represented as a one-dimensional array of 8-bit bytes.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-753></A>C:</B> C provides efficient data representations, because its data types typically map directly to underlying hardware representations. A drawback of C is that its efficient data representations are often not portable: The size of a <CODE>short int</CODE> may vary across platforms, for instance. Dylan takes the more abstract approach of describing the requirements of a data type, and letting the compiler choose the most efficient underlying representation. A drawback of the Dylan approach is that it cannot easily be used for low-level systems programming, where data structures must map reliably to the underlying hardware. Most Dylan systems provide a foreign-function interface to allow calling out to C or some other language more suitable to these low-level tasks. Some Dylan systems augment the language with machine-level constructs that provide the level of control necessary while staying within the object model as much as possible.</P>
</TD></TR></TABLE><P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-757></A>Java:</B> Java recognizes that portable programs need well-defined data types, rather than types that map to the particular underlying hardware differently in each implementation. However, Java retains some of C's concreteness in simply specifying four distinct sizes of integer (in terms of how many binary digits they hold), and forcing the programmer to convert integer types to objects manually, when object-oriented operations are to be performed. In contrast, Dylan's limited-integer types specify, at the program level, the abstract requirements of the type, giving the compiler freedom to map the program requirements as efficiently as possible to the underlying architecture. </P>
</TD></TR></TABLE>
</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_300.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_298.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

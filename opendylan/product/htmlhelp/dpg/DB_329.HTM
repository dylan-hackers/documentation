<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=PREV HREF="DB_328.HTM">
<LINK REL=NEXT HREF="DB_330.HTM">
<TITLE>21 Macros</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING329></A>

<DIV>
<P><A HREF="DB_330.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_328.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>Dylan Programming</P>

</DIV>
<A NAME=HEADING329-0></A>
<H1>21 <A NAME=MARKER-9-863></A>Mac<A NAME=MARKER-2-864></A>ros</H1>
<P> The term <B>macro</B>, as used in computer programming, originally stood for <BR><B>macro-instruction</B>, meaning an instruction that represented a sequence of several machine (or micro) instructions. Over time, the term has evolved to mean any word or phrase that stands for another phrase (usually longer, but built of simpler components). Macros can be used for abbreviation, abstraction, simplification, or structuring. Many application programs, such as word processors or spreadsheets, offer a macro language for writing scripts or subroutines that bundle a number of simpler actions into one command.</P>
<P>Many computer languages support a macro facility for creating shorthand notations for commonly used, longer phrases. They range from simple, text-based abbreviations to full languages, permitting computed replacements. Macros are processed before the program is compiled by <B>expanding</B> each macro into its replacement phrase as that macro is encountered until there are no more macros. You can use macros to extend the base language by defining more sophisticated phrases in terms of simpler, built-in phrases.</P>
<P>The primary use of macros in programming languages is to extend or adapt the language to allow a more concise or readable solution for a particular problem domain. A simple program rarely needs macros. More complicated programs, including the implementation of a Dylan compiler and run-time system, will use macros often. Macros have no visible run-time cost or effect -- they are transformations that take place during the compilation of a program (hence, they <I>can</I> increase compilation time). Although macros may take the form of function calls, they are not functions -- they cannot be passed as functional arguments, and they cannot be invoked in a run-time image as a function can. Although macros may have parameters, they do not take arguments the way functions do. The arguments to a macro are not evaluated; they are simply program phrases that can be substituted in the replacement phrase.</P>
<P>Dylan provides a macro facility that is based on pattern matching and template substitution. This facility is more powerful than is a simple textual substitution facility, but is simpler than a <I>procedural-macro</I> facility, which allows arbitrary computations to construct replacement phrases. Dylan's macro facility is closely integrated with the Dylan language syntax, and permits most macro needs to be satisfied. Dylan designers have also planned for a full procedural macro capability, so that it can be added compatibly at a later time if there is sufficient demand.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison <A NAME=MARKER-2-859></A>with C and C++:</B> C and C++ macros are text substitutions, performed by a preprocessor. The preprocessor has no understanding of the language; it simply splices together text fragments to create replacement phrases.</P>
<P>Dylan macros are written in terms of Dylan language elements; the macros choose their transformation by pattern matching, and they substitute program fragments.</P>
<P>Language-based macros are more powerful than -- and avoid a number of common pitfalls of -- text-substitution macros. These pitfalls are described in later comparisons in this chapter.</P>
</TD></TR></TABLE>
</DIV>

<DIV>

<DIV>

<!-- TOC --><DL>
<DL>
<DT><A REL=BELOW HREF="DB_330.HTM#HEADING330-0"><B>21.1  </B> - Patterns and templates</A>
<DD>
<DT><A REL=BELOW HREF="DB_331.HTM#HEADING331-0"><B>21.2  </B> - Macro hygiene</A>
<DD>
<DT><A REL=BELOW HREF="DB_332.HTM#HEADING332-0"><B>21.3  </B> - Evaluation in macros</A>
<DD>
<DT><A REL=BELOW HREF="DB_333.HTM#HEADING333-0"><B>21.4  </B> - Constraints</A>
<DD>
<DT><A REL=BELOW HREF="DB_334.HTM#HEADING334-0"><B>21.5  </B> - More complex rules</A>
<DD>
<DT><A REL=BELOW HREF="DB_335.HTM#HEADING335-0"><B>21.6  </B> - More hygiene</A>
<DD>
<DT><A REL=BELOW HREF="DB_336.HTM#HEADING336-0"><B>21.7  </B> - Auxiliary macros</A>
<DD>
<DT><A REL=BELOW HREF="DB_337.HTM#HEADING337-0"><B>21.8  </B> - Summary</A>
<DD>
</DL>
</DL>


</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_330.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_328.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

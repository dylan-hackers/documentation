<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_320.HTM">
<LINK REL=PREV HREF="DB_322.HTM">
<LINK REL=NEXT HREF="DB_324.HTM">
<TITLE>20.2.3   Definition of a recovery protocol</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING323></A>

<DIV>
<P><A HREF="DB_324.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_322.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING323-0></A>
<H1>20.2.3   <A NAME=MARKER-9-835></A>Definition of a recovery protocol</H1>
<P> With the new definition of our <CODE>+</CODE> method on <CODE>&lt;time-offset&gt;</CODE> and <CODE>&lt;time-of-day&gt;</CODE>, if we add 5 hours to 10:00 P.M., a condition instance is signaled. The <CODE>say-corrected-time</CODE> method handles that condition, and prints a suitable error message. By the time the handler in <CODE>say-corrected-time</CODE> takes control, the addition that we were performing has been aborted. In fact, we are no longer even executing within the <CODE>correct-arrival-time</CODE> method. We have ceased executing there because handlers established using the <CODE>exception</CODE> clause of <CODE>block</CODE> perform nonlocal exits out of the current computation back to the block where the handler was established. Suppose that we, instead of aborting the addition, wanted to continue with the addition, perhaps modifying the value returned by the <CODE>+</CODE> method such that it would still be within the correct 24-hour range for <CODE>&lt;time-of-day&gt;</CODE> instances. In this section, we modify <CODE>say-corrected-time</CODE> to use a different technique for establishing a handler that does not abort the computation in progress, and we modify the <CODE>+</CODE> method for <CODE>&lt;time-offset&gt;</CODE> and <CODE>&lt;time-of-day&gt;</CODE> to offer and implement a way to modify the value returned to be a legal time of day.</P>
<P>First, we must find a way to execute a handler in the context of the signaler, instead of at the point where the handler was established. Then, we must find a way to activate special code in the <CODE>+</CODE> method to return a legal <CODE>&lt;time-of-day&gt;</CODE> instance as a way of recovering from the time-boundary exception.</P>
<UL>
<LI><P>The <A NAME=MARKER-2-836></A><CODE>let</CODE> <CODE>handler</CODE> local declaration provides a way to establish a handler that will execute in the context of the signaler, just as though the handler was invoked with a normal function call by the signaler.</P>
<LI><P>The restart protocol provides a structured way for a handler to recover from the exception, and to continue with the computation in progress. </P>
</UL>
<P> In this case, continuing with the computation means that the <CODE>+</CODE> method will return a legal <CODE>&lt;time-of-day&gt;</CODE> instance to <CODE>correct-arrival-time</CODE>, and <CODE>correct-arrival-time</CODE> will finish any additional processing and return normally to its caller. </P>
<P>To recover from an exception, we use a signaling and handling technique as similar to that we used to indicate the exception in the first place. This time, we signal a particular condition that is a subclass of <A NAME=MARKER-2-837></A><CODE>&lt;restart&gt;</CODE>, to indicate how the exception handler wishes to recover. We use a <A NAME=MARKER-2-838></A><B>restart handler</B> to implement the particular recovery action. You can think of a restart as a special condition that represents an opportunity to recover from an exception. Establishing a restart handler is a way to offer such an opportunity to other handlers, and to specify the implementation of the restart. Any handler, when activated, might signal a restart to request that a particular recovery action take place. Restart signaling and handling connects recovery requests with recovery actions.</P>
<P>For example, adding 5 hours to 10:00 P.M. is an error for <CODE>&lt;time-offset&gt;</CODE> and <CODE>&lt;time-of-day&gt;</CODE> instances. One way to recover from this error would be to wrap around the result to 3:00 A.M. Here, we define the restart class <CODE>&lt;return-modulus-restart&gt;</CODE>, which represents an offer to return from a time-of-day computation by wrapping the result:</P>
<PRE>
define class &lt;return-modulus-restart&gt; (&lt;restart&gt;)
end class &lt;return-modulus-restart&gt;;
</PRE>
<P> Using the <CODE>exception</CODE> clause of <CODE>block</CODE>, we redefine the <CODE>+</CODE> method to establish and implement the restart handler:</P>
<PRE>
define constant $seconds-per-day = $hours-per-day * $seconds-per-hour;
define method \+ (offset :: &lt;time-offset&gt;, time-of-day :: &lt;time-of-day&gt;)
 =&gt; (sum :: &lt;time-of-day&gt;)
  let sum 
    = make(&lt;time-of-day&gt;,
           total-seconds: offset.total-seconds + time-of-day.total-seconds);
  block ()
    if (sum &gt;= $midnight &amp; sum &lt; $tomorrow)
      sum;
    else 
      error(make(&lt;time-boundary-error&gt;, invalid-time: sum,
                 min-time: $midnight, time-limit: $tomorrow));
    end if;
 <I> // Establish restart handler
</I>  exception (restart :: &lt;return-modulus-restart&gt;)
    make(&lt;time-of-day&gt;,
         total-seconds: modulo(sum.total-seconds, $seconds-per-day));
  end block;
end method \+;
</PRE>
<P> If a handler (established with <CODE>let handler</CODE>) signals a <CODE>&lt;return-modulus-restart&gt;</CODE> during the handling of the <CODE>&lt;time-boundary-error&gt;</CODE> exception, then the sum will be wrapped around so that it will stay within the bounds of the time-of-day specification, and the result will be returned from the <CODE>+</CODE> method. </P>
<P>Next, we want to write a handler using <CODE>let handler</CODE> that will invoke the restart. However, before we invoke the restart, we want to confirm that the restart is currently established. Signaling a restart that is not currently established is an error. The <CODE>available-restart</CODE> method that follows returns an instance of a a given restart, if that restart is currently established; otherwise, <CODE>available-restart</CODE> returns false:</P>
<PRE>
define method available-restart 
    (restart-class :: &lt;class&gt;, exception-instance :: &lt;condition&gt;)
 =&gt; (result :: false-or(&lt;restart&gt;))
  block (return)
    local method check-restart (type, test, function, initargs)
<I>      // Make an instance of the restart, so we can see whether it matches
      // our search criteria
</I>      if (subtype?(type, restart-class))
        let instance = apply(make, type, condition:, exception-instance,
                             initargs | #[]);
        if (test(instance)) return(instance); end;
      end if;
    end method;
<I>    // The built-in Dylan function do-handlers will call check-restart
    // for every handler currently established, in order (first is nearest
    // to the signaler)
</I>    do-handlers(check-restart);
    #f;
  end block;
end method available-restart;
</PRE>
<P> Dylan provides the <A NAME=MARKER-2-839></A><CODE>do-handlers</CODE> function, which iterates over all the currently established handlers, calling its argument (a function) on all the relevant information about the handler, including all the information necessary to instantiate a restart instance for restart handlers. The <CODE>check-restart</CODE> local method returns from <CODE>available-restart</CODE> with a restart instance only when a matching restart that accepts is found. All restarts take a <CODE>condition</CODE> init-keyword argument, which, if supplied, should be the original exception that occurred. If the handler that created the restart provided the original exception condition as an init- keyword argument, then restart handlers can handle restart conditions for only particular exceptions. If none of the established handlers match and accept the restart that we seek, then <CODE>available-restart</CODE> returns false. Note that you should establish restart handlers for instantiable restart classes only, because the restart classes will be instantiated by restart-savvy handlers. If the restart classes cannot be instantiated, then the recovery process will not operate correctly.</P>
<P>Next, we need to define a method to be called by the exception handler to invoke the restart whether it is available. If the restart is not available, the method will call the <CODE>next-handler</CODE> method, which will allow another handler the opportunity to decide if it will handle the exception. In other words, if the <CODE>&lt;return-modulus-restart&gt;</CODE> restart is not established, the handler for <CODE>&lt;time-error&gt;</CODE> established by <CODE>say-corrected-time</CODE> will <B>decline</B> to handle the <CODE>&lt;time-<BR>boundary-error&gt;</CODE> condition being signaled.</P>
<PRE>
define method invoke-modulus-restart-if-available 
    (condition :: &lt;time-error&gt;, next-handler :: &lt;function&gt;)
  let restart = available-restart(&lt;return-modulus-restart&gt;, condition);
  if (restart) error(restart); else next-handler(); end;
end method invoke-modulus-restart-if-available;
</PRE>
<P> No return values are declared for <CODE>invoke-modulus-restart-if-available</CODE>, because we cannot be certain what <CODE>next-handler</CODE> might return. Our handler method must be prepared to return any number of objects of any types. Next, we establish a handler using the <CODE>let handler</CODE> local declaration:</P>
<PRE>
define method say-corrected-time
    (arrival-time :: &lt;time-of-day&gt;, 
     #key weather-delay :: &lt;time-offset&gt; = $no-time,
     traffic-delay :: &lt;time-offset&gt; = $no-time)
 =&gt; ()
  let handler (&lt;time-error&gt;) = invoke-modulus-restart-if-available;
  say(correct-arrival-time(arrival-time, weather-delay, traffic-delay));
end method say-corrected-time;
</PRE>
<P> The <A NAME=MARKER-2-840></A><CODE>let handler</CODE> local declaration establishes a handler for the <CODE>&lt;time-error&gt;</CODE> condition and for all that condition's subclasses. When the <CODE>error</CODE> function inside the <CODE>+</CODE> method signals the <CODE>&lt;time-boundary-error&gt;</CODE> condition instance, Dylan conducts a search for the nearest matching handler that accepts. In this case, the nearest matching handler that accepts is the handler established by <CODE>say-<BR>corrected-time</CODE>. Because this handler was established by a <CODE>let handler</CODE> local declaration, instead of by the <CODE>exception</CODE> clause of <CODE>block</CODE>, no nonlocal exit takes place. Instead, the function specified in the <CODE>let handler</CODE> local declaration is invoked in the context of the signaler. The <CODE>error</CODE> function essentially performs a regular function call on the function associated with the nearest matching handler. The function is passed the condition instance being signaled, and the <CODE>next-handler</CODE> function that might be used to decline handling this condition. In our example, the <CODE>invoke-modulus-restart-if-available</CODE> function will be called from <CODE>error</CODE>. Once called, <CODE>invoke-modulus-restart-if-available</CODE> will first see whether the <CODE>&lt;return-modulus-restart&gt;</CODE> restart is established. If the restart is established, we will invoke it by signaling an instance of the restart. If the restart is not established, we decline to process the <CODE>&lt;time-boundary-error&gt;</CODE> condition in this handler. Assuming that no other handlers exist, the debugger will be invoked.</P>
<P>If the restart is signaled, a nonlocal exit to the restart exception clause in <CODE>+</CODE> method is initiated, which returns the sum suitably wrapped such that it lies within the 24-hour boundary. </P>
<P><A HREF="#MARKER-9-815">Figure 20.2</A> shows the state of execution after the handler function for <CODE>&lt;time-error&gt;</CODE> is invoked, and the state after the restart handler function for <CODE>&lt;return-modulus-restart&gt;</CODE> is invoked. As you can see, although establishing a handler with <CODE>let handler</CODE> can be far removed from the signaler, the handler function itself is executed in the context of the signaler.</P>
<P>  </P>
<TABLE BORDER=1><CAPTION><P>Figure 20.2   <A NAME=MARKER-9-815></A>Context transition from handler to restart handler.</P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB32IM33.GIF></P>
</TD></TR></TABLE><P> </P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_324.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_322.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

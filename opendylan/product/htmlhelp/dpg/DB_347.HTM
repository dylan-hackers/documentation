<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_345.HTM">
<LINK REL=PREV HREF="DB_346.HTM">
<LINK REL=NEXT HREF="DB_348.HTM">
<TITLE>B.2   The concept of classes</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING347></A>

<DIV>
<P><A HREF="DB_348.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_346.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING347-0></A>
<H1>B.2   <A NAME=MARKER-9-930></A>The concept of <A NAME=MARKER-2-931></A>classes</H1>
<P> If you are familiar with the class concepts of C++, you may be confused by Dylan's class model. In Dylan, all base classes are effectively virtual base classes, with "virtual" data members. When a class inherits another class more than once (because of multiple inheritance), only a single copy of that base class is included. Each of the multiple-inheritance paths can contribute to the implementation of the derived class. The Dylan class model favors this mix-in style of programming.</P>
<P>Here is an example of such a program, followed by the equivalent C++:</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> Mix-in example in Dylan. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
define class &lt;window&gt; (&lt;object&gt;)
  slot width :: &lt;integer&gt;;
  slot height :: &lt;integer&gt;;
end class &lt;window&gt;;
</TD></TR><TR VALIGN=TOP><TD>define class &lt;border-window&gt; (&lt;window&gt;)
  slot border-width :: &lt;integer&gt;;
end class &lt;border-window&gt;;
define method width(window :: &lt;border-window&gt;)
  next-method() - 2 * window.border-width;
end method width;
define method height(window :: &lt;border-window&gt;)
  next-method() - 2 * window.border-width;
end method height;
</TD></TR><TR VALIGN=TOP><TD>define class &lt;label-window&gt; (&lt;window&gt;)
  slot label-height :: &lt;integer&gt;;
  slot label-text :: &lt;string&gt;;
end class &lt;label-window&gt;;
define method height(window :: &lt;label-window&gt;)
  next-method() - window.label-height;
end method height;
</TD></TR><TR VALIGN=TOP><TD>define class &lt;border-label-window&gt;
    (&lt;border-window&gt;, &lt;label-window&gt;, &lt;window&gt;)
end class &lt;border-label-window&gt;;
</TD></TR></TABLE></PRE>
<P> The example is a greatly simplified sketch of a computer-display windowing system, where a window may have a border (outline decoration), or a title (such as the title bar of a window), or both. (We omit any further detail, such as scroll bars.) One chore in such a system is to compute the available display area of a window from that window's overall size and from the sizes of the window's <BR>components.</P>
<P>Note that calling <CODE>height</CODE> on an instance of <CODE>&lt;border-label-window&gt;</CODE> will automatically perform the actions appropriate for a window with a border and a label. First, the method for <CODE>&lt;border-window&gt;</CODE> will be called, subtracting out the border width; when it calls <CODE>next-method</CODE>, to get the underlying window width, the method for <CODE>&lt;label-window&gt;</CODE> will be called, subtracting out the label height; finally, when it calls <CODE>next-method</CODE>, the method for getting the value of the <CODE>height</CODE> slot in the underlying window will be called.</P>
<P>This example is a classic one of the mix-in style -- the full functionality of the <CODE>&lt;border-label-window&gt;</CODE> class is the result of the combination of the individual pieces of <CODE>&lt;border-window&gt;</CODE> and <CODE>&lt;label-window&gt;</CODE> functionality.</P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> C++ equivalent of the mix-in example.<EM> </EM></P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
class Window {
private:
  int _width;
  int _height;
public:
  virtual int width() { return _width; }
  virtual int height() { return _height; }
};
</TD></TR><TR VALIGN=TOP><TD>class BorderWindow : public virtual Window {
private:
  int _border_width;
public:
  virtual int border_width() { return _border_width; }
  virtual int width();
  virtual int height();
};
int BorderWindow::width() {
  return Window::width() - 2 * border_width();
}
int BorderWindow::height() {
  return Window::height() - 2 * border_width();
}
</TD></TR><TR VALIGN=TOP><TD>class LabelWindow : public virtual Window {
private:
  int _label_height;
  char *_label_text;
public:
  virtual int label_height() { return _label_height; }
  virtual char* label_text() { return _label_text; }
  virtual int height();
};
</TD></TR><TR VALIGN=TOP><TD>int LabelWindow::height() {
  return Window::height() - label_height();
}
</TD></TR><TR VALIGN=TOP><TD>class BorderLabelWindow : 
  public virtual BorderWindow, 
  public virtual LabelWindow,
  public virtual Window {
public:
  virtual int height();
};
<I>  // Have to generate &quot;combined&quot; method by hand in C++
</I>int BorderLabelWindow::height() {
  return Window::height() - 2 * border_width() - label_height();
}
</TD></TR></TABLE></PRE>
<P> It may be helpful for C++ programmers to consider that:</P>
<UL>
<LI><P>Dylan base classes are always virtual. </P>
<LI><P>In Dylan, data members are accessed through virtual functions, so it is always possible to override access to a data member in a derived class, and to modify the returned value (or, by overriding the setter, to modify the value to be stored). </P>
<LI><P>Dylan's <CODE>next-method</CODE> allows you to use automatic method combination when you are programming in a mix-in style.</P>
</UL>
<P> Note that the C++ equivalent of the mix-in example is incomplete. It is intended only as a guide to how you can think of Dylan classes. In particular, we have not modeled the slot setter virtual functions that Dylan classes define automatically, and we have not gone into how instances of the classes are constructed. In Dylan, we would simply give init-keywords for each of the slots, and the automatically generated constructor would fill them in for any of the derived classes. In contrast, constructors for virtual base classes are a particularly difficult aspect of C++: They make it hard to model what is done in Dylan accurately. In general, the mix-in style of programming is more difficult to do in C++, because that language's support for it is quite limited.</P>
<P>Note also that the C++ code is provided only as a model of Dylan execution, so that you can understand the semantics of Dylan classes in C++ terms. Good Dylan compilers use library compilation, type inferencing, and partial evaluation to optimize out the overhead normally associated with virtual classes and virtual functions, while preserving the dynamic execution semantics.</P>
<A NAME=LINK-c-comparisons-lastpage></A>
</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_348.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_346.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

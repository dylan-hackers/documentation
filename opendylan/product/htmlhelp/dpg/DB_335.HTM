<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_329.HTM">
<LINK REL=PREV HREF="DB_334.HTM">
<LINK REL=NEXT HREF="DB_336.HTM">
<TITLE>21.6   More hygiene</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING335></A>

<DIV>
<P><A HREF="DB_336.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_334.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING335-0></A>
<H1>21.6   More <A NAME=MARKER-2-879></A>hygiene</H1>
<P> We shall make one more note about hygiene: In a textual substitution macro, there is a chance that the global variables that the macro uses (in this case, the helper function <CODE>define-aircraft</CODE>) could be confused with a surrounding local variable of the same name where the macro is called. This confusion does not happen in a Dylan macro. The global variables used in a Dylan macro always denote what they denoted at the time that the macro was defined, rather than at the time that the macro is called. It is as though the variables were automatically renamed so that conflicts will be avoided.</P>
<P>You will also notice this feature if you export a macro from a module. Only the macro needs to be exported. Its global references still refer to the proper (module-private) values that they had at the time the macro was defined, just as occurs when a function exported from a module calls module-private subroutines.</P>
<P>Occasionally, you will want to circumvent macro hygiene. You may want to define a macro that creates a variable that <I>is </I>visible at the macro call. Here is a simple statement macro that repeats its body until you ask it to <CODE>stop!</CODE>:</P>
<PRE>
define macro repeat
  { repeat ?:body end }
 =&gt; { block (?=stop!)
        local method again() ?body; again() end;
        again();
      end }
end macro repeat;
</PRE>
<P> The term <CODE>?=stop!</CODE> says that the local variable <CODE>stop!</CODE>, which is the block exit variable, will be visible when the macro is called exactly as <CODE>stop!</CODE>; there will be no hygienic renaming. Here is an example that uses the macro to count to 100:</P>
<PRE>
begin
  let i = 0;
  repeat
    if (i == 100) stop!() end;
    i := i + 1;
  end;
end;
</PRE>
<P> Note that the <CODE>body</CODE> constraint invokes the Dylan parser to match the code properly between the <CODE>repeat</CODE> and the corresponding <CODE>end</CODE>. It is not confused by the <CODE>end</CODE> of the <CODE>if</CODE> statement, as a text-based macro might be. The expanded view of the preceding code might look like this:</P>
<PRE>
begin
  let i = 0;
  <EM>block (<CODE>stop!)
</CODE></EM>    <EM>local method again()
</EM>      if (i == 100) stop!() end;
      i := i + 1;
       <EM>again()
</EM>    <EM>end;
</EM>    <EM>again();
</EM>  <EM>end</EM>;
end;
</PRE>
<P> Note that we have shown the local variable <CODE>stop!</CODE> introduced by the macro <CODE>block</CODE> in <CODE>code font</CODE> rather than in <EM>underline italic</EM>, because it is visible to the body and is exactly the <CODE>stop!</CODE> called in the <CODE>if</CODE> to stop the repetition. The local variable <EM>again</EM>, on the other hand, is not visible to the body code. We could use <CODE>again</CODE> instead of <CODE>i</CODE> as our repetition count without a problem.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparis<A NAME=MARKER-2-860></A>on with C:</B> All C macros have the syntax of function calls, making it impossible to write language extensions such as <CODE>repeat</CODE>. By using language-based constraints, such as the <CODE>body</CODE> constraint used here, Dylan macros can match language forms, and thus can create extensions that are consistent with the base language.</P>
</TD></TR></TABLE><P> Note that we would have to document how <CODE>repeat</CODE> works for other users, or they might be surprised if they tried to use <CODE>stop!</CODE> instead of <CODE>i</CODE> in the example.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_336.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_334.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_145.HTM">
<LINK REL=PREV HREF="DB_151.HTM">
<LINK REL=NEXT HREF="DB_153.HTM">
<TITLE>11.3.7   Using map and curry</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING152></A>

<DIV>
<P><A HREF="DB_153.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_151.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING152-0></A>
<H1>11.3.7   <A NAME=MARKER-9-410></A>Using <EM><A NAME=MARKER-2-411></A>map</EM> and <EM>curry</EM></H1>
<P> Perhaps the easiest way to implement our simple sequence copier is to use the <CODE>map</CODE> function. The <CODE>map</CODE> function takes the same arguments as does <CODE>do</CODE>. However, instead of ignoring the return value of the function that you provide, <CODE>map</CODE> gathers into a new collection all the results of calling the provided function. The new <BR>collection will be an instance of the <CODE>type-for-copy</CODE> of the first collection argument to <CODE>map</CODE>.</P>
<PRE>
define method my-copy-sequence 
    (old-sequence :: &lt;sequence&gt;) =&gt; (new-sequence :: &lt;sequence&gt;)
  map(identity, old-sequence);
end method my-copy-sequence;
</PRE>
<P> The <A NAME=MARKER-2-412></A><CODE>identity</CODE> function simply returns its argument without making any changes. A more interesting example is to define a method that multiplies a number by each element of a vector, yielding a new vector with the products. Here is a sample call to <CODE>scalar-multiply</CODE>, which we define next:</P>
<PRE>
<I>?</I> scalar-multiply(3, #[4, 5, 6]);
<I>#[12, 15, 18]</I>
</PRE>
<P> Here is our definition of <CODE>scalar-multiply</CODE>, using <CODE>map</CODE>:</P>
<PRE>
define method scalar-multiply 
    (scalar :: &lt;number&gt;, old-vector :: &lt;vector&gt;) =&gt; (result :: &lt;vector&gt;)
  map(method (vector-element) scalar * vector-element end,
      old-vector);
end method scalar-multiply;
</PRE>
<P> We use the <A NAME=MARKER-2-413></A><CODE>method</CODE> statement to create a kind of function (a closure) that multiplies <CODE>scalar</CODE> by an element of the vector provided by <CODE>map</CODE>. The <CODE>map</CODE> iterator then calls that function on each element of <CODE>old-vector</CODE>, collecting the results in a new sequence. A variant of <CODE>map</CODE>, called <CODE>map-into</CODE>, replaces elements in an existing collection, rather than creating a new collection for the results. See <A HREF="DB_254.HTM#MARKER-9-693">Section 16.1.2, page 247</A>, for an example of the use of <CODE>map-into</CODE>.</P>
<P>We can define this method more succinctly using <A NAME=MARKER-2-414></A><CODE>curry</CODE>, which is a function that generates a function:</P>
<PRE>
define method scalar-multiply 
    (scalar :: &lt;number&gt;, old-vector :: &lt;vector&gt;) =&gt; (result :: &lt;vector&gt;)
  map(curry(\*, scalar), old-vector);
end method scalar-multiply;
</PRE>
<P> The <CODE>curry</CODE> function in this example creates exactly the same method as the one that we created in the previous definition of <CODE>scalar-multiply</CODE>. That is, <CODE>curry(\*, scalar)</CODE> builds a function that multiplies its argument by <CODE>scalar</CODE>. This generated function is then used by <CODE>map</CODE> to compute the value of each element of the new sequence. </P>
<P>Mapping functions such as <CODE>do</CODE> and <CODE>map</CODE> work well when you want to operate over the entire collection. The <CODE>map</CODE> function works well only if there is a one-to-one correspondence between input-collection sizes and output-collection size. However, the other techniques that we have presented, such as using <CODE>for</CODE> and <CODE>while</CODE>, can work better when you want to operate on only part of a sequence. In <A HREF="DB_153.HTM#MARKER-9-415">Section 11.3.8</A>, we take another look at how a <CODE>for</CODE> loop can help us to solve the problem of iterating over only part of a collection.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_153.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_151.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

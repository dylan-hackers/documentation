<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_63.HTM">
<LINK REL=PREV HREF="DB_79.HTM">
<LINK REL=NEXT HREF="DB_81.HTM">
<TITLE>5.6   Definition of a generic function</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING80></A>

<DIV>
<P><A HREF="DB_81.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_79.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING80-0></A>
<H1>5.6   <A NAME=MARKER-9-229></A>Definition of a generic function</H1>
<P> We repeat the definitions of the methods for <CODE>say-time-of-day</CODE> and <CODE>say-time-offset</CODE> here:</P>
<PRE>
define method say-time-of-day (time :: &lt;time-of-day&gt;) =&gt; ()
  let(hours, minutes) = decode-total-seconds(time);
  format-out
    (&quot;%d:%s%d&quot;, hours, if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end, minutes);
end method say-time-of-day;
define method say-time-offset (time :: &lt;time-offset&gt;) =&gt; ()
  let(hours, minutes) = decode-total-seconds(time);
  format-out(&quot;%s %d:%s%d&quot;,
             if (past?(time)) &quot;minus&quot; else &quot;plus&quot; end, 
             hours, 
             if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end,
             minutes);
end method say-time-offset;
</PRE>
<P> Now that <CODE>decode-total-seconds</CODE> has an applicable method for instances of <CODE>&lt;time-offset&gt;</CODE> and <CODE>&lt;time-of-day&gt;</CODE>, both these methods work correctly:</P>
<PRE>
<I>? </I>say-time-of-day(*my-time-of-day*);
<I>0:02</I>
<I>? </I>say-time-of-day(*your-time-of-day*);
<I>8:30</I>
<I>? </I>say-time-offset(*my-time-offset*);
<I>plus 15:20</I>
<I>? </I>say-time-offset(*your-time-offset*);
<I>minus 6:45</I>
</PRE>
<P> We have defined two methods: <CODE>say-time-offset</CODE> and <CODE>say-time-of-day</CODE>. A method defined with <CODE>define method</CODE> cannot exist without a <A NAME=MARKER-2-230></A><B>generic function</B>. When you define a method, and no generic function of that name exists, Dylan automatically creates a generic function. When we defined these two methods, there were no generic functions with those names defined, so Dylan created module variables named <CODE>say-time-of-day</CODE> and <CODE>say-time-offset</CODE>, created the generic functions, stored the generic functions in the module variables, and added the methods to the generic functions.</P>
<P>These two methods are logically related to each other, but have no explicit relationship in the code, other than in the similarity of their names. A cleaner approach is to abstract the concept of what these methods are trying to do -- that is, to describe an object. To introduce this abstraction, we define a new generic function. </P>
<P>We use <A NAME=MARKER-2-231></A><CODE>define generic</CODE> to define the generic function explicitly: </P>
<PRE>
<I>// Given an object, print a description of the object
</I>define generic say (any-object :: &lt;object&gt;) =&gt; ();
</PRE>
<P> This generic function has a name: <CODE>say</CODE>. It receives one argument: the object to describe. That argument must be of the type <CODE>&lt;object&gt;</CODE>. All objects are of the type <CODE>&lt;object&gt;</CODE>, so this generic function does not restrict the type of its argument. </P>
<P>Our definition for the generic function <CODE>say</CODE> is similar to that of the generic function that Dylan would have created automatically if we had defined a method for <CODE>say</CODE> before we defined the generic function <CODE>say</CODE>. (The only difference is that the automatically defined generic function would have a more general value declaration.) However, defining the generic function explicitly enables us to formalize its purpose, to name the parameter, to specify a type constraint on the parameter, to specify the return values and their types, and to give comments about the generic function as a whole. The generic function defines the <A NAME=MARKER-2-232></A><B>contract</B> that all methods for this generic function must obey. The contract of the <CODE>say</CODE> generic function is as follows:</P>
<P>The <CODE>say</CODE> generic function receives one required argument, which must be of the type <CODE>&lt;object&gt;</CODE>. It prints a description of the object. The <CODE>say</CODE> generic function returns no values. </P>
<P> Dylan requires all the methods for a generic function to have congruent parameter lists and values declarations. See <A HREF="DB_179.HTM#MARKER-9-529">Section 12.2.5, page 176</A>.</P>
<P>Now, we define two methods for <CODE>say</CODE>. The method for <CODE>say</CODE> on <CODE>&lt;time-of-day&gt;</CODE> fulfills the same purpose (and has the same body) as the <CODE>say-time-of-day</CODE> method, which we remove from the library with an editor or a gesture in the <BR>environment. </P>
<PRE>
define method say (time :: &lt;time-of-day&gt;) =&gt; ()
  let (hours, minutes) = decode-total-seconds(time); 
  format-out
    (&quot;%d:%s%d&quot;, hours, if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end, minutes);
end method say;
</PRE>
<P> Similarly, the method for <CODE>say</CODE> on <CODE>&lt;time-offset&gt;</CODE> is intended to replace <CODE>say-time-offset</CODE>, which we remove.</P>
<PRE>
define method say (time :: &lt;time-offset&gt;) =&gt; ()
  let(hours, minutes) = decode-total-seconds(time);
  format-out(&quot;%s %d:%s%d&quot;,
             if (past?(time)) &quot;minus&quot; else &quot;plus&quot; end, 
             hours, 
             if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end,
             minutes);
end method say-time-offset;
</PRE>
<P> </P>
<P> <A HREF="#MARKER-9-197">Figure 5.5</A> shows that the generic function <CODE>say</CODE> has two methods defined for it.</P>
<P> </P>
<TABLE BORDER=1><CAPTION><P>Figure 5.5   <A NAME=MARKER-9-197></A>Methods for the <CODE>say</CODE> generic function. </P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB80IM12.GIF></P>
</TD></TR></TABLE><P> We can call <CODE>say</CODE>:</P>
<PRE>
<I>? </I>say(*my-time-of-day*);
<I>0:02</I>
</PRE>
<P> </P>
<P> In the preceding call, the argument is of the type <CODE>&lt;time-of-day&gt;</CODE>, so the method on <CODE>&lt;time-of-day&gt;</CODE> is the only applicable method. That method is invoked.</P>
<PRE>
<I>? </I>say(*my-time-offset*);
<I>plus 15:20</I>
</PRE>
<P> </P>
<P> In the preceding call, the argument is of the type <CODE>&lt;time-offset&gt;</CODE>, so the method on <CODE>&lt;time-offset&gt;</CODE> is the only applicable method. That method is invoked.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_81.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_79.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

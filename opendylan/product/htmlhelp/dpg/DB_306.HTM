<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_295.HTM">
<LINK REL=PREV HREF="DB_305.HTM">
<LINK REL=NEXT HREF="DB_307.HTM">
<TITLE>19.11   Sealed domains</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING306></A>

<DIV>
<P><A HREF="DB_307.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_305.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING306-0></A>
<H1>19.11   <A NAME=MARKER-9-789></A>Sealed d<A NAME=MARKER-2-790></A>omains</H1>
<P> When you define a protocol that is meant to be extended by many libraries, both the base classes and the generic functions that make up the protocol must be open. This simple exigency might make it seem that there is no hope of optimizing such a protocol -- however, there is hope. You use the <CODE>define sealed domain</CODE> form to seal selectively subsets or <B>branches</B> of the protocol, permitting the compiler to make all the optimizations that would be possible if the classes and generic functions were sealed, but only for the particular subset or branch in question.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Advanced topic:</B> Sealed domains are one of the most difficult concepts of the Dylan language to understand fully. It is reasonable to defer careful reading of this section until you are faced with a situation similar to the example -- an imported open class and generic function that will be specialized by your library.</P>
</TD></TR></TABLE><P> </P>
<P> As an example, consider the <CODE>say</CODE> protocol as used in the <CODE>time</CODE> library. Because the <CODE>say</CODE> generic function is defined to be open, even if the compiler can infer that the argument to <CODE>say</CODE> is a <CODE>&lt;time&gt;</CODE> or <CODE>&lt;time-offset&gt;</CODE>, it must insert code to choose the appropriate method to call at run time on the off chance that some other library has added or removed methods for <CODE>say</CODE>. The solution is to add the following definition to the <CODE>time</CODE> library:</P>
<PRE>
<I>// Declare the say generic function sealed, for all time classes
</I>define sealed domain say (&lt;time&gt;);
</PRE>
<P> This statement is essentially a guarantee to the compiler that the only methods on <CODE>say</CODE> that are applicable to <CODE>&lt;time&gt;</CODE> objects (and also to <CODE>&lt;time-of-day&gt;</CODE> and <CODE>&lt;time-offset&gt;</CODE> objects, because <CODE>&lt;time-of-day&gt;</CODE> and <CODE>&lt;time-offset&gt;</CODE> are subclasses of <CODE>&lt;time&gt;</CODE>) are those that are defined explicitly in the <CODE>time</CODE> library (and in any libraries from which that one imports). Thus, when the compiler can prove that the argument to <CODE>say</CODE> is a <CODE>&lt;time-offset&gt;</CODE>, it can call the correct method directly, without any run-time dispatch overhead.</P>
<P>Another way to get the same effect as a sealed domain, which is also self-documenting, is to use <CODE>define sealed method</CODE><A NAME=MARKER-2-791></A> when defining individual methods on the protocol. So, for instance, in the case of the <CODE>time</CODE> library, we might have defined the two methods on <CODE>say</CODE> as follows:</P>
<PRE>
define sealed method say (time :: &lt;time&gt;)
  let (hours, minutes) = decode-total-seconds (time); 
  format-out(&quot;%d:%s%d&quot;, hours, if (minutes &lt; 10) &quot;0&quot; else &quot; &quot; end, minutes);
end method say;
define sealed method say (time :: &lt;time-offset&gt;) =&gt; ()
  format-out(&quot;%s &quot;, if (time.past?) &quot;minus&quot; else &quot;plus&quot; end);
  next-method();
end method say;
</PRE>
<P> Defining a sealed method is the same as defining the generic function to be sealed over the domain of the method's specializers. In effect, this technique says that you do not intend anyone to add more specific methods in that domain, or to create classes that would change the applicability of the sealed methods.</P>
<P>With either the <CODE>define sealed domain</CODE> form or the sealed methods, the use of <CODE>say</CODE> on <CODE>&lt;time&gt;</CODE> objects will be as efficient as it would be were <CODE>say</CODE> not an open generic function after all. At the same time, other libraries that create new classes can still extend the <CODE>say</CODE> protocol to cover those classes.</P>
<P>Sealed domains impose <A NAME=MARKER-2-792></A>restrictions on the ability of other libraries to create new methods, to remove new methods, and to create new classes: </P>
<P>You cannot add methods to an open generic function imported from another library that would fall into the sealed domain of <I>any</I> other library. You can avoid this restriction by ensuring that at least one of the specializers of your method is a subtype of a type defined in your library. </P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-749></A>C++:</B> A C++ compiler could optimize out the dispatching of a virtual function by analyzing the entire scope of the argument on which the virtual function dispatches, and proving that argument's exact class. Unfortunately, that scope is often the entire program, so this optimization often can be performed only by a linker. Even a linker cannot make this optimization when a library is compiled, because the classes of a library can be subclassed by a client. The complexity is compounded for dynamic-link libraries, where there may be multiple clients at once. As a result, this optimization is rarely achieved in C++.</P>
<P>In Dylan, sealed classes, sealed generic functions, and sealed domains explicitly state which generic functions and classes may be extended, and, more important, which cannot. The library designer plans in advance exactly what extensibility the library will have. The Dylan compiler can then optimize dispatching on sealed generic functions and classes and within sealed domains with the assurance that no client will violate the assumptions of the optimization. The sealing restrictions against subclassing or changing method applicability are automatically enforced on each client of a Dylan library. </P>
</TD></TR></TABLE><P> </P>
<P> When you seal a domain of a generic function imported from another library, you will not cause conflicts with other libraries, as long as both of the following conditions hold:</P>
<P>1.  At least one of the types in the sealed domain is a subtype of a class defined in your library</P>
<P>2.  No additional subtypes can be defined for any of the types in the sealed domain </P>
<P> In the case of a type that is a class, the first condition means that you must have defined either the class or one of its superclasses in your library. The second condition means that the classes in the domain must not have any open subclasses (a degenerate case of which is a leaf class -- a class with no subclasses at all). </P>
<P>If you need to seal a domain over a class that has open subclasses, you will need a thorough understanding of the sealing constraints detailed in <I>The Dylan Reference Manual</I>, but these two simple rules should handle many common cases. </P>
<P>In our example, we obeyed both rules of thumb: our methods for <CODE>say</CODE> are on classes we defined, and our sealing was over classes that will not be further subclassed. The rules of thumb not only keep you from violating sealing constraints, they make for good protocol design: a library that extends a protocol really should extend it only for classes it fully understands, which usually means classes it creates.</P>
<P>As an example of the <A NAME=MARKER-2-793></A>restriction on subclassing open classes involved in a sealed domain, if the <CODE>&lt;time&gt;</CODE> class were an open class, we still could not add the following class in a library that used the <CODE>time</CODE> library:</P>
<P> </P>
<PRE>
define class &lt;place-and-time&gt; (&lt;position&gt;, &lt;time&gt;)
end class &lt;place-and-time&gt;;
</PRE>
<P> </P>
<P> As far as the compiler is concerned, it "knows" that the only <CODE>say</CODE> method applicable to a <CODE>&lt;time&gt;</CODE> is the one in the <CODE>time</CODE> library. (That is what we have told it with our <CODE>sealed domain</CODE> definition.) It would be valid to pass a <CODE>&lt;place-and-time&gt;</CODE> object as an argument to a function that accepted <CODE>&lt;time&gt;</CODE> objects, but within that function the compiler might have already optimized a call to <CODE>say</CODE> to the method for <CODE>&lt;time&gt;</CODE> objects (based on <CODE>&lt;time&gt;</CODE> being in the sealed domain of <CODE>say</CODE>). But there is also a method for <CODE>say</CODE> on <CODE>&lt;position&gt;</CODE>, and, more important, we probably will want to define a method specifically for <CODE>&lt;place-and-time&gt;</CODE>. Because of this ambiguity, the class <CODE>&lt;place-and-time&gt;</CODE> cannot be defined in a separate library, and the compiler will signal an error.</P>
<P>Note that the class <CODE>&lt;place-and-time&gt;</CODE> could be defined in the <CODE>time</CODE> library. The compiler can deal correctly with classes that may straddle a sealed domain, if they are known in the library where the sealed domain is defined. It would also be valid to subclass <CODE>&lt;time&gt;</CODE> in any way that did not change the applicability of methods in any sealed generic-function domains that include <CODE>&lt;time&gt;</CODE>. The actual rule involved depends on an analysis of the exact methods of the generic function, and the rule is complicated enough that you should just rely on your compiler to detect illegal situations.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_307.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_305.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

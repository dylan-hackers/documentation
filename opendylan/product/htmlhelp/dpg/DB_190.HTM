<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=PREV HREF="DB_189.HTM">
<LINK REL=NEXT HREF="DB_191.HTM">
<TITLE>13 Libraries and Modules</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING190></A>

<DIV>
<P><A HREF="DB_191.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_189.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>Dylan Programming</P>

</DIV>
<A NAME=HEADING190-0></A>
<H1>13 <A NAME=MARKER-9-610></A>Li<A NAME=MARKER-2-611></A>braries and Modules</H1>
<P> As you create a program, you will often discover subsets of your code that are candidates for sharing, reuse, or resale. Alternatively, you may be working on a large program that has been divided into pieces that can be implemented separately, either to allow parallel development, or to make the programming task more manageable. For either of these reasons, you can package your code into a <A NAME=MARKER-2-612></A><B>reusable software component</B> so that </P>
<UL>
<LI><P>Other programmers can easily add your component to their programs (which are called <B>client programs</B> of your component).</P>
<LI><P>You can develop your component independently from any clients. </P>
<LI><P>Clients can use your code without knowing or depending on the internal implementation of your component.</P>
<LI><P>You can sell your component to clients without revealing your source code.</P>
</UL>
<P> Two important principles of software engineering apply here: information hiding and protocols. The principle of <A NAME=MARKER-2-613></A><B>information hiding</B> says that you should try to minimize the information that is passed between components in a system, thus minimizing the interdependencies of components. A <A NAME=MARKER-2-614></A><B>protocol</B> is the interface definition of a software component. The purpose of establishing protocols is to define a uniform interface that clients can use, even if the implementation of a <BR>component is enhanced or modified. Dylan supports software components, information hiding, and protocols in terms of <B>libraries</B> and <B>modules</B>.</P>
<P>Many Dylan environments support simple or exploratory programming with a <B><A NAME=MARKER-2-615></A><CODE>dylan-user</CODE></B> module that includes both the standard Dylan language facilities and a common subset of Dylan libraries. Because all but the simplest programs usually grow into projects or are reused in new projects, it is good practice to create a unique library and module for each program or component. If you are writing a simple, stand-alone program or a simple component, you can use the simple library and module structure illustrated in <A HREF="DB_30.HTM#MARKER-9-88">Section 2.5, page 20</A>. You may want to skim this chapter, however, so you have an idea of the options available for more complex situations.</P>
<P>In this chapter, we start by describing the basic concepts of libraries (<A HREF="DB_191.HTM#MARKER-9-616">Section 13.1</A>), modules and namespaces (<A HREF="DB_192.HTM#MARKER-9-618">Section 13.2</A>), and programs and source records (<A HREF="DB_198.HTM#MARKER-9-625">Section 13.3</A>). In the remainder of the chapter, we illustrate the concepts of libraries and modules by considering the classes and methods for times that we defined in <A HREF="DB_103.HTM#MARKER-9-278">Chapter 8,  <I>A Simple Library</I></A>, and showing how they might be packaged into a reusable software component or library. We also show how the <CODE>sixty-unit</CODE> classes and methods could be a component substrate that the <CODE>time</CODE> library uses and shares with an <CODE>angle</CODE> library. Finally, we illustrate how to implement a <CODE>say</CODE> protocol that works with either or both of the <CODE>time</CODE> and <CODE>angle</CODE> libraries by creating a separate library that defines the shared protocol.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC --><DL>
<DL>
<DT><A REL=BELOW HREF="DB_191.HTM#HEADING191-0"><B>13.1  </B> - Libraries</A>
<DD>
<DT><A REL=BELOW HREF="DB_192.HTM#HEADING192-0"><B>13.2  </B> - Modules</A>
<DD>
<DT><A REL=BELOW HREF="DB_198.HTM#HEADING198-0"><B>13.3  </B> - Source code, modules, and libraries</A>
<DD>
<DT><A REL=BELOW HREF="DB_202.HTM#HEADING202-0"><B>13.4  </B> - Module definition</A>
<DD>
<DT><A REL=BELOW HREF="DB_206.HTM#HEADING206-0"><B>13.5  </B> - Library definition</A>
<DD>
<DT><A REL=BELOW HREF="DB_207.HTM#HEADING207-0"><B>13.6  </B> - Interchange files</A>
<DD>
<DT><A REL=BELOW HREF="DB_208.HTM#HEADING208-0"><B>13.7  </B> - The time-library file</A>
<DD>
<DT><A REL=BELOW HREF="DB_212.HTM#HEADING212-0"><B>13.8  </B> - Component library</A>
<DD>
<DT><A REL=BELOW HREF="DB_217.HTM#HEADING217-0"><B>13.9  </B> - Protocol design</A>
<DD>
<DT><A REL=BELOW HREF="DB_222.HTM#HEADING222-0"><B>13.10  </B> - Summary</A>
<DD>
</DL>
</DL>


</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_191.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_189.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

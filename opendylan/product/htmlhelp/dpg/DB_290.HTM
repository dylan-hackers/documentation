<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_288.HTM">
<LINK REL=PREV HREF="DB_289.HTM">
<LINK REL=NEXT HREF="DB_291.HTM">
<TITLE>18.4.2   Refined rules for method dispatch</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING290></A>

<DIV>
<P><A HREF="DB_291.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_289.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING290-0></A>
<H1>18.4.2   Refined rules for method dispatch</H1>
<P> In summary, the effect of multiple inheritance on method dispatch is to refine the rule for sorting methods according to specificity:</P>
<P>A method is <B>more specific</B> than another if the type of its specialized parameter is a proper subtype of the type of the other method's specialized parameter. (For definitions of proper subtype, see <A HREF="DB_113.HTM#MARKER-9-297">Section 9.3, page 111</A>.) If one type is not a proper subtype of the other, a method is more specific if the class of its specialized parameter precedes the class of the other method's specialized parameter in the class precedence list of the argument to the generic function. Otherwise, the methods are <B>unordered</B> for that parameter.</P>
<P> If the generic function has more than one required argument, Dylan uses this augmented rule for determining specificity in the usual way for sorting applicable methods with more than one argument. In essence, Dylan orders the applicable methods separately for each required argument, and then constructs an overall ordering by comparing the separate sorted lists. In the overall method ordering, a method is more specific than another if it satisfies two constraints:</P>
<P>1.  The method is <I>no less specific</I> than the other method for <I>all</I> required parameters. (The two methods might have the same types for some parameters.)</P>
<P>2.  The method is <I>more specific</I> than the other method for <I>some</I> required <BR>parameter.</P>
<P> Note that one method might be more specific than another for one parameter, but less specific for another parameter. These two methods are <A NAME=MARKER-2-741></A><B>ambiguous</B> in <BR>specificity and cannot be ordered. If the method-dispatch procedure cannot find any method that is more specific than all other methods, Dylan signals an error.</P>
<P>    </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-720></A>C++:</B> Multiple inheritance in C++ is different from multiple inheritance in Dylan. In C++, unless a base class is virtual, it is inherited multiple times if there is more than one path to the base class as a result of multiple inheritance. In Dylan, all base classes are effectively virtual.</P>
<P>C++ has nothing like Dylan's class precedence list for determining the precedence of two superclasses, neither of which is derived from the other. There is no implicit ordering of virtual members defined for such classes. C++ also has nothing like Dylan's <CODE>next-method</CODE> for invoking the next most specific virtual function. A C++ programmer must often explicitly provide the sort of method dispatch and combination that Dylan implements automatically. </P>
<P>For examples of similar Dylan and C++ programs that use multiple inheritance, see <A HREF="DB_347.HTM#MARKER-9-930">Section B.2, page 390</A>.</P>
</TD></TR></TABLE><TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-721></A>Java:</B> Java formalizes the concept of a <B>protocol</B> with its <B>interfaces</B>. An interface is like an abstract class and a set of required generic functions. A class that <B>implements</B> an interface must define methods for each of the generic functions specified by that interface. In a sense, an interface is like a specification for multiple inheritance, without the implementation. A class that implements an interface is considered to be of the interface type, but it must implement all the behaviors directly, rather than inheriting them from the interface -- which may mean that code has to be duplicated, rather than shared and reused.</P>
</TD></TR></TABLE>
</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_291.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_289.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_320.HTM">
<LINK REL=PREV HREF="DB_321.HTM">
<LINK REL=NEXT HREF="DB_323.HTM">
<TITLE>20.2.2   Simple condition handling</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING322></A>

<DIV>
<P><A HREF="DB_323.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_321.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING322-0></A>
<H1>20.2.2   Simple condition handling</H1>
<P> A <A NAME=MARKER-2-831></A><B>handler</B> can potentially resolve an exceptional situation, although a handler can decline to resolve a particular exception. If an application provides no handlers, then the generic function <CODE>default-handler</CODE> is called on the condition. There is a method on <CODE>&lt;condition&gt;</CODE> that just returns false, and there is a method on <CODE>&lt;serious-condition&gt;</CODE> (a superclass of <CODE>&lt;error&gt;</CODE>) that causes some kind of implementation-specific response to be invoked. Most development environments provide a debugger that deals with any serious conditions not handled by the application. Typically, the debugger describes the serious condition being signaled, and might provide any number of options for recovery (or might provide no recovery options). In a sense, the debugger is the handler of final resort.</P>
<P>In the following example, we establish a handler for the condition that we want to resolve, before calling the code that might signal that condition. We redefine the <CODE>correct-arrival-time</CODE> and <CODE>say-corrected-time</CODE> methods to take advantage of the Dylan exception protocol.</P>
<PRE>
define method correct-arrival-time 
    (arrival-time :: &lt;time-of-day&gt;, weather-delay :: &lt;time-offset&gt;,
     traffic-delay :: &lt;time-offset&gt;)
 =&gt; (sum :: &lt;time-of-day&gt;)
  traffic-delay + (weather-delay + arrival-time);
end method correct-arrival-time;
define method say-corrected-time
    (arrival-time :: &lt;time-of-day&gt;, 
     #key weather-delay :: &lt;time-offset&gt; = $no-time,
     traffic-delay :: &lt;time-offset&gt; = $no-time)
 =&gt; ()
  block ()
    say(correct-arrival-time(arrival-time, weather-delay, traffic-delay));
<I>  // We establish the handler in the following two lines
</I>  exception (condition :: &lt;time-error&gt;)
    say(condition);
  end block;
end method say-corrected-time;
</PRE>
<P> The <CODE>exception</CODE> clause of <A NAME=MARKER-2-832></A><CODE>block</CODE> establishes a handler for a condition, and all that condition's subclasses, for any code in the <CODE>block</CODE> body, and for any code called by the <CODE>block</CODE> body. We say that the handler is established within the <A NAME=MARKER-2-833></A><B>dynamic scope</B> of the <CODE>block</CODE> body. When an exception is signaled, Dylan starts a search to find the nearest handler available that matches the condition signaled, and that accepts the exception. The <B>nearest handler</B> is the one that was most recently established in the dynamic scope of the signaler. The handler matches the condition if the class associated with the handler (the handler class) is the same as the condition, or if the handler class is a superclass of the condition. You can associate a test with the handler so that the handler can selectively accept the condition. By default, a matching handler always accepts. If a handler established by the <CODE>exception</CODE> clause of <CODE>block</CODE> matches and accepts, then a nonlocal exit from the signaler occurs, with execution continuing in the body of the exception clause, which is executed in the context of the very beginning of the block. All the locals defined by the block are gone, but the exit procedure (if there is one) is still available. If there is relevant local state, it may be captured in slots of the condition prior to signaling of the condition. The code within the exception clause body is executed, and the value of the last statement in that body is then returned as the value of the block.</P>
<P>In this example, the <CODE>+</CODE> method (called by <CODE>correct-arrival-time</CODE>) may signal a <CODE>&lt;time-boundary-error&gt;</CODE> condition using the <CODE>error</CODE> function during the execution of <CODE>say-corrected-time</CODE>. If this error is signaled, then the handler established by the <CODE>block</CODE> for <CODE>&lt;time-error&gt;</CODE> will match the <CODE>&lt;time-boundary-error&gt;</CODE> condition. This <CODE>exception</CODE> clause will always accept the condition, so a nonlocal exit will occur, and will terminate execution of the <CODE>error</CODE> function, the <CODE>+</CODE> method, and the <CODE>correct-arrival-time</CODE> method. Within the context of the beginning of the <CODE>block</CODE>, the variable <CODE>condition</CODE> is bound to the condition instance being signaled (the instance supplied to <CODE>error</CODE>); then, execution resumes with the code inside the body of the <CODE>exception</CODE> clause. The body calls the <CODE>say</CODE> generic function on the condition instance, which causes an appropriate error message (instead of the time) to be displayed to the user. Execution then continues normally after the end of the block; in this case, that results in the normal exit from the <CODE>say-corrected-time</CODE> method. <A HREF="#MARKER-9-814">Figure 20.1</A> shows the state of execution when <CODE>error</CODE> is called, and after the execution of the <CODE>exception</CODE> clause body for <CODE>&lt;time-error&gt;</CODE> begins. <A HREF="#MARKER-9-814">Figure 20.1</A> is a simplified diagram of the internal calling stack of a hypothetical Dylan implementation. It is similar to what a debugger might produce when asked to print a backtrace at these two points in the execution of the example. The <CODE>error</CODE> function called within the <CODE>+</CODE> method signals the <CODE>&lt;time-boundary-error&gt;</CODE> error, and the <CODE>exception</CODE> clause of <CODE>block</CODE> in the <CODE>say-corrected-time</CODE> method establishes the handler for that error. Once the handling of the exception is in progress, the handler selected is no longer established. If there is relevant local state, it may be captured in slots of the condition being <BR>signaled.</P>
<P> </P>
<TABLE BORDER=1><CAPTION><P>Figure 20.1   <A NAME=MARKER-9-814></A>Context transition from signaler to handler.</P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB32IM32.GIF></P>
</TD></TR></TABLE><P>The advantages of this structured approach to signaling and handling conditions are significant: </P>
<UL>
<LI><P>The method focuses on the normal flow of control, and the exceptional flow of control appears only where necessary. For example, the <CODE>correct-arrival-time</CODE> method does not need to be aware of the potential exceptions at all. The Dylan condition system makes it easier to reuse code that might not know about, or care to participate in, your application-specific exception recovery code. </P>
<LI><P>Because <CODE>correct-arrival-time</CODE> does not need to participate in the <BR>exception-recovery protocol, it can also have a specific return value; thus, like the <CODE>+</CODE> method, it might allow better compiler optimizations and better compile-time error checking. </P>
<LI><P>We allow room for expansion in the code. For example, at some point, <BR><CODE>correct-arrival-time</CODE> might do more sophisticated computations with time, which might signal other kinds of time errors. As long as these new time errors inherit from <CODE>&lt;time-error&gt;</CODE>, they can be resolved by the same handler established by <CODE>say-corrected-time</CODE>. As the application evolves, we can build various families of error conditions, and can provide application-specific handlers that perform the correct recovery actions for those families.</P>
<LI><P>Because we are using the signaling and handling protocol defined by Dylan, casual readers of the code should be able to understand our intent. </P>
<LI><P>Because the handler has access to the condition object, the handler can perform intelligent recovery actions based on the information captured in the condition object when the exception occurred. For example, the handler may examine various slots of the condition object, and perform different actions based on information stored in those slots.</P>
</UL>
<P> Dylan supports two models of handler execution. The <CODE>exception</CODE> clause of <CODE>block</CODE> implements the exit model. When you establish handlers by the <CODE>exception</CODE> clause of <A NAME=MARKER-2-834></A><CODE>block</CODE>, you do not have the ability to restart a computation in the context of the signaler, or in a context closer to the signaler than the handler. In <A HREF="DB_323.HTM#MARKER-9-835">Section 20.2.3</A>, we explore the calling model of handler execution, which allows you to recover from an exception without a nonlocal exit back to the point where the handler was established. </P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_323.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_321.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

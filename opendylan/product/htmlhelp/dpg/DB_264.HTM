<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_262.HTM">
<LINK REL=PREV HREF="DB_263.HTM">
<LINK REL=NEXT HREF="DB_265.HTM">
<TITLE>17.2.2   Vehicle containers</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING264></A>

<DIV>
<P><A HREF="DB_265.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_263.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING264-0></A>
<H1>17.2.2   <A NAME=MARKER-9-710></A>Vehicle containers</H1>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The <CODE>airport-classes.dylan</CODE> file. <I>(continued)</I></P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
<I>// VEHICLE STORAGE</I>
<I>// The default size for a vehicle container
</I>define constant $default-capacity
  = make(&lt;size&gt;, length: 350, width: 200, height: 100); 
</TD></TR><TR VALIGN=TOP><TD><I>// This class represents a location where an aircraft could be stored
</I>define abstract class &lt;vehicle-storage&gt; (&lt;physical-object&gt;)
  slot storage-capacity :: &lt;size&gt; = $default-capacity,
    init-keyword: capacity:;
  each-subclass slot name-prefix :: &lt;string&gt; = &quot;Storage&quot;, setter: #f;
  slot identifier :: &lt;string&gt;, required-init-keyword: id:;
  slot connected-to :: &lt;simple-object-vector&gt;;
end class &lt;vehicle-storage&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I>// By using the name-prefix each-subclass slot, we share one say method
// for all vehicle containers
</I>define method say (storage :: &lt;vehicle-storage&gt;) =&gt; ()
  format-out(&quot;%s %s&quot;, storage.name-prefix, storage.identifier);
end method say; 
</TD></TR><TR VALIGN=TOP><TD>define method object-fits?
    (object :: &lt;physical-object&gt;, container :: &lt;vehicle-storage&gt;)
 =&gt; (fits? :: &lt;boolean&gt;)
  let object-size = object.physical-size;
  let container-capacity = container.storage-capacity;
  object-size.length &lt; container-capacity.length
    &amp; object-size.height &lt; container-capacity.height
    &amp; object-size.width &lt; container-capacity.width;
end method object-fits?; 
</TD></TR><TR VALIGN=TOP><TD><I>// Vehicle storage that can hold only one aircraft regardless of direction
// Direction in this context is either #&quot;inbound&quot; or #&quot;outbound&quot;
</I>define abstract class &lt;single-storage&gt; (&lt;vehicle-storage&gt;)
  slot vehicle-currently-occupying :: false-or(&lt;aircraft&gt;) = #f;
end class &lt;single-storage&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I>// Vehicle storage that can hold multiple aircraft, with distinct queues
// for each direction
</I>define abstract class &lt;multiple-storage&gt; (&lt;vehicle-storage&gt;)
  slot vehicles-by-direction :: &lt;object-table&gt; = make(&lt;object-table&gt;);
  slot maxima-by-direction :: &lt;object-table&gt; = make(&lt;object-table&gt;);
  keyword directions:;
  keyword maxima:;
end class &lt;multiple-storage&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I>// In a real airport, there would be many paths an aircraft could take
// For our simple airport example, we define only the #&quot;inbound&quot; and 
// #&quot;outbound&quot; paths
// The directions parameter is a sequence of these aircraft path names
// Multiple storage containers can limit the number of aircraft that 
// they can hold for each path; this is the maxima parameter
// This initialize method creates a queue to hold aircraft for each
// direction, and stores the queue in a table indexed by direction
// This method also stores the maximum number of aircaft for that 
// direction in a different table
</I>define method initialize 
    (object :: &lt;multiple-storage&gt;, #key directions :: &lt;sequence&gt;, 
     maxima :: &lt;sequence&gt;)
  next-method ();
  for (direction in directions,
       maximum in maxima)
    object.vehicles-by-direction[direction] := make(&lt;deque&gt;);
    object.maxima-by-direction[direction] := maximum;
  end for;
end method initialize; 
</TD></TR><TR VALIGN=TOP><TD><I>// From the preceding basic vehicle containers, we can build specific
// containers for each aircraft-transition location
</I>define class &lt;gate&gt; (&lt;single-storage&gt;)
  inherited slot name-prefix, init-value: &quot;Gate&quot;;
end class &lt;gate&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I>// Given a zero-based terminal number, and a one-based gate number, create
// an return a string with a gate letter and a terminal number in it
</I>define method generate-gate-id 
    (term :: &lt;nonnegative-integer&gt;, gate :: &lt;positive-integer&gt;)
 =&gt; (gate-id :: &lt;string&gt;)
  format-to-string(&quot;%c%d&quot;, $letters[term], gate);
end method generate-gate-id; 
</TD></TR><TR VALIGN=TOP><TD><I><A NAME=MARKER-9-701></A>// Gates-per-terminal is a vector; each element of the vector is the
// number of gates to create for the terminal at that index
// Returns a vector of all the gate instances
</I>define method generate-gates
    (gates-per-terminal :: &lt;vector&gt;, default-gate-capacity :: &lt;size&gt;)
 =&gt; (gates :: &lt;vector&gt;)
  let result = make(&lt;vector&gt;, size: reduce1(\+, gates-per-terminal));
  let result-index = 0;
  for (term from 0 below gates-per-terminal.size)
    for (gate from 1 to gates-per-terminal[term])
      result[result-index]
        := make(&lt;gate&gt;, id: generate-gate-id(term, gate),
                capacity: default-gate-capacity);
      result-index := result-index + 1;
    end for;
  end for;
  result;
end method generate-gates; 
</TD></TR><TR VALIGN=TOP><TD><I>// This class represents the part of the airspace over a given airport
</I>define class &lt;sky&gt; (&lt;multiple-storage&gt;)
<I>  // The airport over which this piece of sky is located
</I>  slot airport-below :: &lt;airport&gt;, required-init-keyword: airport:;
  inherited slot name-prefix, init-value: &quot;Sky&quot;;
  required keyword inbound-aircraft:;
end class &lt;sky&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I><A NAME=MARKER-9-702></A>// When a sky instance is created, a sequence of inbound aircraft is
// provided 
// This method initializes the direction slot of the aircraft to 
// #&quot;inbound&quot;, and places the aircraft in the inbound queue of the sky
// instance
</I>define method initialize 
    (sky :: &lt;sky&gt;,<CODE> </CODE>#key inbound-aircraft<CODE> </CODE>::<CODE> </CODE>&lt;sequence&gt;)
  next-method(sky, directions: #[#&quot;inbound&quot;, #&quot;outbound&quot;],
              maxima: vector(inbound-aircraft.size,
                             inbound-aircraft.size));
  let inbound-queue = sky.vehicles-by-direction [#&quot;inbound&quot;];
  for (vehicle in inbound-aircraft)
    vehicle.direction := #&quot;inbound&quot;;
    push-last(inbound-queue, vehicle);
  end for;
<I>  // Connect the airport to the sky
</I>  sky.airport-below.sky-above := sky;
end method initialize; 
</TD></TR><TR VALIGN=TOP><TD><I>// This class represents a strip of land where aircraft land and take off
</I>define class &lt;runway&gt; (&lt;single-storage&gt;)
  inherited slot name-prefix, init-value: &quot;Runway&quot;;
end class &lt;runway&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I>// Taxiways connect runways and gates
</I>define class &lt;taxiway&gt; (&lt;multiple-storage&gt;)
  inherited slot name-prefix, init-value: &quot;Taxiway&quot;;
end class &lt;taxiway&gt;; 
</TD></TR></TABLE></PRE>
<P> </P>
<P> In the preceding portion of the <CODE>airport-classes.dylan</CODE> file, we define the tangible objects that represent the various normal locations for aircraft in and around an airport. These locations are known as containers or vehicle storage. We can connect vehicle-storage instances to one another to form an airport. Instances of <CODE>&lt;single-storage&gt;</CODE> can hold only one aircraft at a time, whereas instances of <CODE>&lt;multiple-storage&gt;</CODE> can hold more than one aircraft at a time. Also, instances of <CODE>&lt;multiple-storage&gt;</CODE> treat inbound aircraft separately from outbound aircraft. We define the <CODE>object-fits?</CODE> method, which determines whether a physical object can fit into a container. We also define methods for creating, initializing, and describing various containers. Note the use of the <CODE>each-subclass</CODE> slot <CODE>name-prefix</CODE>, which permits one <CODE>say</CODE> method on the <CODE>&lt;vehicle-storage&gt;</CODE> class to cover all the vehicle-container classes. Each subclass of vehicle storage can override the inherited value of this slot, to ensure that the proper name of the vehicle storage is used in the description of instances of that subclass.</P>
<P>The <CODE>&lt;vehicle-storage&gt;</CODE>, <CODE>&lt;multiple-storage&gt;</CODE>, and <CODE>&lt;single-storage&gt;</CODE> classes are all abstract, because it is not sensible to instantiate them. They contain partial implementations that they contribute to their subclasses.</P>
<P>In the <CODE>generate-gates</CODE> method, the <CODE>gates-per-terminal</CODE> parameter is a vector that contains the count of gates for each terminal. By adding up all the elements of that vector with <CODE>reduce1</CODE>, we can compute the total number of gates at the airport, and thus the size of the vector that can hold all the gates.</P>
<P>Next, we examine the classes, initialization methods, and <CODE>say</CODE> methods for the vehicles in the application.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_265.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_263.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

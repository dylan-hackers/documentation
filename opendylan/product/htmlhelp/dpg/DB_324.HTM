<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_320.HTM">
<LINK REL=PREV HREF="DB_323.HTM">
<LINK REL=NEXT HREF="DB_325.HTM">
<TITLE>20.2.4   Continuation from errors</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING324></A>

<DIV>
<P><A HREF="DB_325.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_323.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING324-0></A>
<H1>20.2.4   <A NAME=MARKER-9-841></A>Continuation from errors</H1>
<P> </P>
<P> The restart mechanism just described is exceedingly general, and may provide several different ways to recover from exceptional situations. Sometimes, however, there is just one main way to recover. Under certain circumstances, Dylan provides a way for handlers simply to return to their callers, allowing execution to continue after the signaler. Here, we present a simpler (but less flexible) implementation for recovering from the time-of-day overflow exception:</P>
<P> </P>
<PRE>
define method return-24-hour-modulus 
    (condition :: &lt;time-error&gt;, next-handler :: &lt;function&gt;) 
 =&gt; (corrected-time :: &lt;time&gt;)  
  make(type-for-copy(condition.invalid-time),
       total-seconds: modulo(condition.invalid-time.total-seconds, 
                             $seconds-per-day));
end method return-24-hour-modulus;
</PRE>
<P> </P>
<PRE>
define method return-allowed? (condition :: &lt;time-error&gt;)
  #t;
end method return-allowed?;
</PRE>
<P> </P>
<PRE>
define method return-description (condition :: &lt;time-error&gt;)
  &quot;Returns the invalid time modulo 24 hours.&quot;;
end;
</PRE>
<P> </P>
<PRE>
define method say-corrected-time
    (arrival-time :: &lt;time-of-day&gt;, 
     #key weather-delay :: &lt;time-offset&gt; = $no-time,
     traffic-delay :: &lt;time-offset&gt; = $no-time)
 =&gt; ()
  let handler (&lt;time-error&gt;) = return-24-hour-modulus;
  say(correct-arrival-time(arrival-time, weather-delay, traffic-delay));
end method say-corrected-time;
define method \+ (offset :: &lt;time-offset&gt;, time-of-day :: &lt;time-of-day&gt;)
 =&gt; (sum :: &lt;time-of-day&gt;)
  let sum 
    = make(&lt;time-of-day&gt;,
           total-seconds: offset.total-seconds + time-of-day.total-seconds);
  block ()
    if (sum &gt;= $midnight &amp; sum &lt; $tomorrow)
      sum;
    else
<I>      // If a handler returns, it must return a valid &lt;time-offset&gt;
</I>      signal(make(&lt;time-boundary-error&gt;, invalid-time: sum,
                 min-time: $midnight, time-limit: $tomorrow));
    end if;
  end block;
end method \+;
</PRE>
<P> The <CODE>return-allowed?</CODE> and <CODE>return-description</CODE> generic functions are provided by Dylan. When the generic function <CODE>return-allowed?</CODE> returns true for a given condition, introspective handlers know that they can return successfully back to the signaler. When returning is allowed, such introspective handlers may call the <CODE>return-description</CODE> generic function to find out what values to return, if there are any. This description can be especially useful for interactive handlers, such as debuggers.</P>
<P>The <CODE>return-24-hour-modulus</CODE> method has been generalized compared to the exception-specific restart defined in <A HREF="DB_323.HTM#MARKER-9-835">Section 20.2.3</A>. This method may return either an instance of <CODE>&lt;time-of-day&gt;</CODE> or <CODE>&lt;time-offset&gt;</CODE>, depending on the class of time that overflowed. Thus, it could be reused for exception handling in other parts of the application.</P>
<P>In this implementation approach, there is an implicit contract between the signaler in the <CODE>\+</CODE> method and any handler that matches and accepts <CODE>&lt;time-boundary-errors&gt;</CODE>. The contract is that the handler will always return a valid <CODE>&lt;time&gt;</CODE> value, or will never return at all. If any handler violates this implicit contract, then the reliability of the program will be placed at risk. It is important to document these error-handling contracts.</P>
<P>Note that, in the <CODE>\+</CODE> method, we must use the <CODE>signal</CODE> function to signal the exception, because it is illegal for a handler to return from exceptions signaled with the <CODE>error</CODE> function. </P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_325.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_323.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_145.HTM">
<LINK REL=PREV HREF="DB_147.HTM">
<LINK REL=NEXT HREF="DB_149.HTM">
<TITLE>11.3.3   Lists and efficiency</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING148></A>

<DIV>
<P><A HREF="DB_149.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_147.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING148-0></A>
<H1>11.3.3   <A NAME=MARKER-9-402></A>Lists and <A NAME=MARKER-9-403></A>efficiency</H1>
<P> </P>
<P> The <CODE>my-copy-sequence</CODE> method in <A HREF="DB_147.HTM#MARKER-9-400">Section 11.3.2</A> works efficiently for vectors. It does so because Dylan can store and retrieve arbitrary elements of vectors, and can determine the size of vectors in constant time. </P>
<P>Lists are quite a different data structure from vectors. Accessing elements and determining the size of a list takes linear time. Thus, you can access the thousandth element of a vector or string in the same amount of time as you can access the first element of a vector or string; when you uses lists, however, it takes about 1000 times longer to access the thousandth element than to access the first element. The difference in access times occurs because Dylan must walk over almost 1000 pairs to get to the thousandth pair, and thus get to the thousandth element of the list. Although the method defined in <A HREF="DB_147.HTM#MARKER-9-400">Section 11.3.2</A> can copy lists, it will be excessively slow, especially for long lists. </P>
<P>We would like to provide a special method for copying lists that uses a more efficient algorithm. In particular, we want to walk over the provided list element by element, without having to retrace over elements of the list that we have already copied.</P>
<PRE>
<I>// Assumes that old-list is a proper list (that is, it ends with #()) </I>	
<I>// and is not circular	
</I>define method my-copy-sequence (old-list :: &lt;list&gt;) =&gt; (new-list :: &lt;list&gt;)
  let new-list = make(&lt;list&gt;, size: old-list.size);
  for (old = old-list then old.tail,
       new = new-list then new.tail,
       until: empty?(old))
    new.head := old.head;
  end for;
  new-list;
end method my-copy-sequence;
</PRE>
<P> First, <CODE>my-copy-sequence</CODE> makes a new list that is the same length as the old one. Next, the <CODE>for</CODE> iterator is used to bind the variables <CODE>old</CODE> and <CODE>new</CODE> to <CODE>old-list</CODE> and <CODE>new-list</CODE>, respectively. Then, the <CODE>for</CODE> iterator executes the <CODE>until:</CODE> expression to determine whether it is time to terminate the loop. If the <CODE>until:</CODE> expression returns true, then the <CODE>for</CODE> loop terminates, and the newly created list is returned from <CODE>my-copy-sequence</CODE>. Otherwise, the body of the <CODE>for</CODE> loop is executed -- the body stores the head of the first pair in <CODE>old</CODE> into the head of the first pair in <CODE>new</CODE>. The result of that action is that the first element of <CODE>new</CODE> is indentical to the first element of <CODE>old</CODE>. For this iteration, that action causes the first element of <CODE>new-list</CODE> to be identical to the first element of <CODE>old-list</CODE>. In subsequent iterations, the body will access elements 1 closer to the end of the list. It will do so because, after the body is executed, the <CODE>for</CODE> iterator loops back to the iterator clauses, where the <CODE>then</CODE> clauses bind <CODE>old</CODE> to all but the first pair of <CODE>old</CODE>, and bind <CODE>new</CODE> to all but the first pair of <CODE>new</CODE>. The termination check occurs again, with the same consequences, depending on the value of the <CODE>until:</CODE> expression. Iteration then continues just like the second time through the loop until the end of <CODE>old</CODE> is reached.</P>
<P>In this method, we never have to search for the current spot of the old list that we are copying, or to search for the end of the new list that we are building. The variables <CODE>old</CODE> and <CODE>new</CODE> track exactly which pairs in the iteration to access, and that tracking saves a considerable amount of time for large lists. When the iteration is finished, <CODE>my-copy-sequence</CODE> returns the new list.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_149.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_147.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_268.HTM">
<LINK REL=PREV HREF="DB_269.HTM">
<LINK REL=NEXT HREF="DB_271.HTM">
<TITLE>17.4.2   The scheduling algorithm</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING270></A>

<DIV>
<P><A HREF="DB_271.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_269.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING270-0></A>
<H1>17.4.2   The scheduling algorithm</H1>
<P> The next methods form the core of the airport application.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The <CODE>schedule.dylan</CODE> file.<I> (continued)</I></P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
<I>// Searches all of the vehicle storage of class class-of-next, which is
// connected to container and has room for aircraft
</I>define method find-available-connection
    (storage :: &lt;vehicle-storage&gt;, class-of-next :: &lt;class&gt;,
     aircraft :: &lt;aircraft&gt;)
 =&gt; (next-container :: false-or(&lt;vehicle-storage&gt;))
  block (return)
    for (c in storage.connected-to)
      if (instance?(c, class-of-next)
          &amp; available?(aircraft, c, aircraft.direction))
        return(c);
      end if;
    end for;
  end block;
end method find-available-connection; 
</TD></TR><TR VALIGN=TOP><TD><I>// Generate new transitions to be considered for the next move
// The transitions will be placed in the sorted sequence, which will order
// them by earliest arrival time
</I>define method generate-new-transitions
    (container :: &lt;vehicle-storage&gt;, 
     active-transitions :: &lt;sorted-sequence&gt;,
     containers-visited :: &lt;object-table&gt;)
 =&gt; ()
  unless(element(containers-visited, container, default: #f))
<I>    // Keep track of which containers we have searched for new possible
    // transitions
    // We avoid looping forever by checking each container just once
</I>    containers-visited[container] := #t; 
</TD></TR><TR VALIGN=TOP><TD>    local method consider-transition (direction)
<I>      // See whether any vehicle is ready to transition out of a container
</I>      let (vehicle, next-container, time) 
        = next-out(container, direction);
      unless (vehicle == #f | vehicle.next-transition.pending?)
<I>        // If there is a vehicle ready, and it is not already in the 
        // sorted sequence of pending transitions, then prepare the 
        // transition instance associated with the vehicle 
</I>        let transition = vehicle.next-transition;
        transition.from-container := container;
        transition.to-container := next-container;
</TD></TR><TR VALIGN=TOP><TD><I>        // The vehicle may have been waiting
        // Take this situation into account when computing the earliest
        // arrival into the next container
</I>        transition.earliest-arrival := transition.earliest-arrival + time;
<I>        // Flag the vehicle as pending, to save searching through the
        // active-transitions sorted sequence later
</I>        transition.pending? := #t;
<I>        // Add the transition to the set to be considered 
</I>        add!(active-transitions, transition);
      end unless;
    end method consider-transition; 
</TD></TR><TR VALIGN=TOP><TD><I>    // Consider both inbound and outbound traffic 
</I>    consider-transition(#&quot;outbound&quot;);
    consider-transition(#&quot;inbound&quot;);
<I>    // Make sure that every container connected to this one is checked
</I>    for (c in container.connected-to)
      generate-new-transitions(c, active-transitions, containers-visited);
    end for;
  end unless;
end method generate-new-transitions; 
</TD></TR><TR VALIGN=TOP><TD><I>// Main loop of the program
// See what possible transitions exist, then execute the earliest
// transitions that can be completed
// Returns the time of the last transition
</I>define method process-aircraft 
    (airport :: &lt;airport&gt;, #key time = $midnight) 
 =&gt; (time :: &lt;time-of-day&gt;)
  format-out(&quot;Detailed aircraft schedule for &quot;);
  say(airport);
  format-out(&quot;\n\n&quot;);
  let sky = airport.sky-above;
  let containers-visited = make(&lt;object-table&gt;);
  let active-transitions = make(&lt;sorted-sequence&gt;, 
                               value-function: earliest-arrival); 
</TD></TR><TR VALIGN=TOP><TD><I>  // We do not have to use return as the name of the exit procedure
</I>  block (done)
    while (#t)
<I>      // Each time through, start by considering every container
</I>      fill!(containers-visited, #f);
<I>      // For every container, see if any vehicles are ready to transition
      // If any are, add transition instances to the active-transitions 
      // sorted sequence
</I>      generate-new-transitions(sky, active-transitions, 
                               containers-visited);
</TD></TR><TR VALIGN=TOP><TD><I>      // If there are no more transitions, we have completed our task
</I>      if (empty?(active-transitions)) done(); end;
<I>      // Find the earliest transition that can complete, because there is 
      // still room available in the destination container
</I>      let transition-index
        = find-key(active-transitions,
                   method (transition)
                     available?(transition.transition-aircraft,
                                transition.to-container,
                                transition.transition-aircraft.direction);
                   end); 
</TD></TR><TR VALIGN=TOP><TD><I>      // If none can complete, there is a problem with the simulation
      // This situation should never occur, but is useful for debugging
      // incorrect container configurations
</I>      if (transition-index == #f)
        error(&quot;Pending transitions but none can complete.&quot;);
      end if; 
</TD></TR><TR VALIGN=TOP><TD><I>      // Otherwise, the earliest transition that can complete has been
      // found: Execute the transition
</I>      let transition = active-transitions[transition-index];
      let vehicle = transition.transition-aircraft;
      let vehicle-direction = vehicle.direction;
      move-out-vehicle(vehicle, transition.from-container, 
                       vehicle-direction);
      move-in-vehicle(vehicle, transition.to-container, vehicle-direction); 
</TD></TR><TR VALIGN=TOP><TD><I>      // This transition is complete; remove it from consideration 
</I>      transition.pending? := #f;
      remove!(active-transitions, transition);
<I>      // Compute the actual time of arrival at the next container, and       // display the message 
</I>      time := (transition.earliest-arrival 
                := max(time, transition.earliest-arrival));
      say(transition);
      format-out(&quot;\n&quot;);
    end while;
  end block;
  time;
end method process-aircraft; 
</TD></TR></TABLE></PRE>
<P> The <CODE>process-aircraft</CODE> method uses components from the time, space and sorted sequence libraries, the container classes and protocols, and the vehicle classes and methods to schedule the aircraft arriving and departing from an airport. The <CODE>generate-new-transitions</CODE> method assists by examining the current state of all containers in the airport, and by noting any new steps that vehicles could take.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_271.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_269.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_30.HTM">
<LINK REL=PREV HREF="DB_31.HTM">
<LINK REL=NEXT HREF="DB_33.HTM">
<TITLE>2.5.2   Components of a Dylan program</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING32></A>

<DIV>
<P><A HREF="DB_33.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_31.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING32-0></A>
<H1>2.5.2   Components of a Dylan program</H1>
<P> We start with this simple Dylan expression:</P>
<PRE>
format-out(&quot;Hello, world\n&quot;); 
</PRE>
<P> All Dylan expressions must be in a module. Therefore, we use a text editor to create a file that contains the expression within a module:</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The program file: <CODE>hello.dylan</CODE>.</P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
module: hello
format-out(&quot;Hello, world\n&quot;); 
</TD></TR></TABLE></PRE>
<P> </P>
<P> The <CODE>hello.dylan</CODE> file is the top-level file; you can think of it as the program itself. When you run this program, Dylan executes all the expressions in the file in the order that they appear in the file. There is only one expression in this program -- the call to <CODE>format-out</CODE>.</P>
<P>The first line of this file declares that the expressions and definitions in this file are in the <CODE>hello</CODE> module. Before we can run (or even compile) this program, we need to define the <CODE>hello</CODE> module. All modules must be in a library, so we must also define a library for our <CODE>hello</CODE> module. We create a second file, called the library file, and define the <CODE>hello</CODE> module and <CODE>hello</CODE> library in the library file:</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The library file: <CODE>library.dylan</CODE>.</P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
module: dylan-user						
define library hello
  use dylan; 
  use format-out;
end library hello;
define module hello
  use dylan; 
  use format-out;
end module hello; 
</TD></TR></TABLE></PRE>
<P> </P>
<P> The first line of <CODE>library.dylan</CODE> states that the expressions in this file are in the <A NAME=MARKER-2-92></A><CODE>dylan-user</CODE> module. Every Dylan expression and definition must be in a module, including the definitions of libraries and modules. The <CODE>dylan-user</CODE> module is the starting point -- the predefined module that enables you to define the libraries and modules that your program uses. </P>
<P>In the file <CODE>library.dylan</CODE>, we define a library named <CODE>hello</CODE>, and a module named <CODE>hello</CODE>. We define the <CODE>hello</CODE> library to use the <A NAME=MARKER-2-93></A><CODE>dylan</CODE> library and the <CODE>format-out</CODE> library, and we define the <CODE>hello</CODE> module to use the <A NAME=MARKER-2-94></A><CODE>dylan</CODE> module and the <CODE>format-out</CODE> module. </P>
<P>One library <B>uses</B> another library to allow its modules to use the other library's exported modules. Most libraries need to use the <CODE>dylan</CODE> library, because it contains the <CODE>dylan</CODE> module. One module <B>uses</B> another module to allow its definitions to use the other module's exported definitions. Most modules need to use the <CODE>dylan</CODE> module in the <CODE>dylan</CODE> library, because that module contains the definitions of the core Dylan language. We also need to use the <CODE>format-out</CODE> module in the <CODE>format-out</CODE> library, because that module defines the <CODE>format-out</CODE> function, which we use in our program.</P>
<P>Finally, we create a LID file that enumerates the files that make up the library. This file does not contain Dylan expressions, but rather is simply a textual description of the library's files:</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The LID file: <CODE>hello.lid</CODE>.</P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
library: hello
files:   library 
         hello 
</TD></TR></TABLE></PRE>
<P> The LID file simply states that the library <CODE>hello</CODE> comprises two files, named <CODE>library</CODE> and <CODE>hello</CODE>. In other words, to build the <CODE>hello</CODE> library, the compiler must process the two files listed, in the order that they appear in the file. The order is significant, because a module must be defined before the code that is in the module can be analyzed and compiled. </P>
<P>You can consult the documentation of your Dylan implementation to find out how to build an executable program from these files, and how to run that program once it is built. Most Dylan environments produce executable programs that can be invoked in the same manner as any other program on the particular platform that you are using.</P>
<P>We incur a fair amount of overhead in setting up the files that make up a simple program. Most environments automate this process -- some of the complexity shown here occurs because we are working with the lowest common denominator: interchange files. The advantages of libraries and modules are significant for larger p<A NAME=MARKER-2-95></A>rograms. See <A HREF="DB_190.HTM#MARKER-9-610">Chapter 13,  <I>Libraries and Modules</I></A>.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_33.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_31.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

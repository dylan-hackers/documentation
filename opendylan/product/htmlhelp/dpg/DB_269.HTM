<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_268.HTM">
<LINK REL=PREV HREF="DB_268.HTM">
<LINK REL=NEXT HREF="DB_270.HTM">
<TITLE>17.4.1   The container protocol and implementation</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING269></A>

<DIV>
<P><A HREF="DB_270.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_268.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING269-0></A>
<H1>17.4.1   The container protocol and implementation</H1>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The <CODE>schedule.dylan</CODE> file.  </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
module: airport
<I>// The following generic functions constitute the essential protocol for
// interaction between containers and vehicles</I>
<I>// Returns true if container is available for aircraft in direction
</I>define generic available? (vehicle, container, direction); 
</TD></TR><TR VALIGN=TOP><TD><I>// Moves vehicle into container in the given direction
</I>define generic move-in-vehicle (vehicle, container, direction); 
</TD></TR><TR VALIGN=TOP><TD><I>// Moves vehicle out of container in the given direction
</I>define generic move-out-vehicle (vehicle, container, direction); 
</TD></TR><TR VALIGN=TOP><TD><I>// Returns the aircraft next in line to move out of container in direction
</I>define generic next-out (container, direction); 
</TD></TR><TR VALIGN=TOP><TD><I>// Returns the class of the next container to move vehicle into, 
// and how long it will take to get there
</I>define generic next-landing-step (container, vehicle); 
</TD></TR><TR VALIGN=TOP><TD><I>// A single storage container is available if the aircraft fits into the
// the container, and there is not already a vehicle in the container
</I>define method available?
    (vehicle :: &lt;aircraft&gt;, container :: &lt;single-storage&gt;,
     direction :: &lt;symbol&gt;)
 =&gt; (container-available? :: &lt;boolean&gt;)
  object-fits?(vehicle, container)
  &amp; ~ (container.vehicle-currently-occupying);
end method available?; 
</TD></TR><TR VALIGN=TOP><TD><I>// A multiple storage container is available if the aircraft fits into 
// the container, and there are not too many aircraft already queued in
// the container for the specified direction
</I>define method available? 
    (vehicle :: &lt;aircraft&gt;, container :: &lt;multiple-storage&gt;,
     direction :: &lt;symbol&gt;)
 =&gt; (container-available? :: &lt;boolean&gt;)
  object-fits?(vehicle, container)
  &amp; size(container.vehicles-by-direction[direction])
    &lt; container.maxima-by-direction[direction];
end method available?; 
</TD></TR><TR VALIGN=TOP><TD><I>// Avoids jamming the runway with inbound traffic, which would prevent
// outbound aircraft from taking off
// The runway is clear to inbound traffic only if there is space in the 
// next container inbound from the runway
</I>define method available?
    (vehicle :: &lt;aircraft&gt;, container :: &lt;runway&gt;,
     direction :: &lt;symbol&gt;) 
 =&gt; (container-available? :: &lt;boolean&gt;)
  next-method()
    &amp; select (direction)
        #&quot;outbound&quot; =&gt; #t;
        #&quot;inbound&quot;
          =&gt; let (class) = next-landing-step(container, vehicle);
             if (class)
               find-available-connection(container, class, vehicle) ~== #f;
             end if;
      end select;
end method available?; 
</TD></TR><TR VALIGN=TOP><TD><I>// A slot is used to keep track of which aircraft is in a single 
// storage container
</I>define method move-in-vehicle
    (vehicle :: &lt;aircraft&gt;, container :: &lt;single-storage&gt;,
     direction :: &lt;symbol&gt;)
 =&gt; ()
  container.vehicle-currently-occupying := vehicle;
  values();
end method move-in-vehicle; 
</TD></TR><TR VALIGN=TOP><TD><I>// A deque is used to keep track of which aircraft are traveling in a
// particular direction in a multiple storage container
</I>define method move-in-vehicle
    (vehicle :: &lt;aircraft&gt;, container :: &lt;multiple-storage&gt;,
     direction :: &lt;symbol&gt;)
 =&gt; ()
  let vehicles = container.vehicles-by-direction[direction];
  push-last(vehicles, vehicle);
  values();
end method move-in-vehicle; 
</TD></TR><TR VALIGN=TOP><TD><I>// When an aircraft reaches the gate, it begins its outbound journey
</I>define method move-in-vehicle
    (vehicle :: &lt;aircraft&gt;, container :: &lt;gate&gt;, 
     direction :: &lt;symbol&gt;)
 =&gt; ()
  next-method();
  vehicle.direction := #&quot;outbound&quot;;
  values();
end method move-in-vehicle; 
</TD></TR><TR VALIGN=TOP><TD>define method move-out-vehicle
    (vehicle :: &lt;aircraft&gt;, container :: &lt;single-storage&gt;,
     direction :: &lt;symbol&gt;)
 =&gt; ()
  container.vehicle-currently-occupying := #f;
  values();
end method move-out-vehicle; 
</TD></TR><TR VALIGN=TOP><TD>define method move-out-vehicle
    (vehicle   :: &lt;aircraft&gt;,
     container :: &lt;multiple-storage&gt;, direction :: &lt;symbol&gt;)
 =&gt; ()
  let vehicles = container.vehicles-by-direction[direction];
<I>  // Assumes that aircraft always exit container in order, and 
  // that this aircraft is next
</I>  pop(vehicles);
  values();
end method move-out-vehicle; 
</TD></TR><TR VALIGN=TOP><TD><I>// Determines what vehicle, if any, could move to the next container
// If there is such a vehicle, then this method returns the vehicle, 
// the next container in the direction of travel, 
// and the time that it would take to make that transition
</I>define method next-out
    (container :: &lt;vehicle-storage&gt;, direction :: &lt;symbol&gt;)
 =&gt; (next-vehicle :: false-or(&lt;vehicle&gt;),
     next-storage :: false-or(&lt;vehicle-storage&gt;),
     time-to-execute :: false-or(&lt;time-offset&gt;));
  let next-vehicle = next-out-internal(container, direction);
  if (next-vehicle)
    let (class, time) = next-landing-step(container, next-vehicle);
    if (class)
      let next-container
        = find-available-connection(container, class, next-vehicle);
      if (next-container)
        values(next-vehicle, next-container, time);
      end if;
    end if;
  end if;
end method next-out; 
</TD></TR><TR VALIGN=TOP><TD><I>// This method is just a helper method for the next-out method
// We need different methods based on the class of container
</I>define method next-out-internal
    (container :: &lt;single-storage&gt;, desired-direction :: &lt;symbol&gt;)
 =&gt; (vehicle :: false-or(&lt;aircraft&gt;))
  let vehicle = container.vehicle-currently-occupying;
  if (vehicle &amp; vehicle.direction == desired-direction) vehicle; end;
end method next-out-internal; 
</TD></TR><TR VALIGN=TOP><TD>define method next-out-internal
    (container :: &lt;multiple-storage&gt;, desired-direction :: &lt;symbol&gt;)
 =&gt; (vehicle :: false-or(&lt;aircraft&gt;))
  let vehicle-queue = container.vehicles-by-direction[desired-direction];
  if (vehicle-queue.size &gt; 0) vehicle-queue[0]; end;
end method next-out-internal; 
</TD></TR><TR VALIGN=TOP><TD><I>// The following methods return the class of the next container to which a
// vehicle can move from a particular container
// They also return an estimate of how long that transition will take
</I>define method next-landing-step
    (storage :: &lt;sky&gt;, aircraft :: &lt;aircraft&gt;)
 =&gt; (next-class :: false-or(&lt;class&gt;), duration :: false-or(&lt;time-offset&gt;))
  if (aircraft.direction == #&quot;inbound&quot;)
    values(&lt;runway&gt;, flying-time(aircraft, storage.airport-below));
  end if;
end method next-landing-step; 
</TD></TR><TR VALIGN=TOP><TD>define method next-landing-step
    (storage :: &lt;runway&gt;, aircraft :: &lt;aircraft&gt;)
 =&gt; (next-class :: &lt;class&gt;, duration :: &lt;time-offset&gt;)
  select (aircraft.direction)
    #&quot;inbound&quot;  =&gt; values(&lt;taxiway&gt;, brake-time(aircraft, storage));
    #&quot;outbound&quot; =&gt; values(&lt;sky&gt;, takeoff-time(aircraft, storage));
  end select;
end method next-landing-step; 
</TD></TR><TR VALIGN=TOP><TD>define method next-landing-step
    (storage :: &lt;taxiway&gt;, aircraft :: &lt;aircraft&gt;)
 =&gt; (next-class :: &lt;class&gt;, duration :: &lt;time-offset&gt;)
  select (aircraft.direction)
    #&quot;inbound&quot;  =&gt; values(&lt;gate&gt;, gate-time(aircraft, storage));
    #&quot;outbound&quot; =&gt; values(&lt;runway&gt;, runway-time(aircraft, storage));
  end select;
end method next-landing-step; 
</TD></TR><TR VALIGN=TOP><TD>define method next-landing-step
    (storage :: &lt;gate&gt;, aircraft :: &lt;aircraft&gt;)
 =&gt; (next-class :: &lt;class&gt;, duration :: &lt;time-offset&gt;)
  values(&lt;taxiway&gt;, gate-turnaround(aircraft, storage));
end method next-landing-step; 
</TD></TR></TABLE></PRE>
<P> </P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_270.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_268.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_329.HTM">
<LINK REL=PREV HREF="DB_333.HTM">
<LINK REL=NEXT HREF="DB_335.HTM">
<TITLE>21.5   More complex rules</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING334></A>

<DIV>
<P><A HREF="DB_335.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_333.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING334-0></A>
<H1>21.5   <A NAME=MARKER-9-876></A>More complex rules</H1>
<P> The macros shown so far have all been simple: a single pattern transformed into a single template. To get a flavor of the full power of the Dylan macro system, consider this <A NAME=MARKER-2-877></A><B>defining macro</B>:</P>
<PRE>
define macro aircraft-definer
  { define aircraft ?identifier:name (?type:name) ?flights end }
   =&gt; { register-aircraft(make(&quot;&lt;&quot; ## ?type ## &quot;&gt;&quot;, id: ?#&quot;identifier&quot;));
        register-flights(?#&quot;identifier&quot;, ?flights) }
flights:
  { }
   =&gt; { }
  { ?flight; ... }
   =&gt; { ?flight, ... }
flight:
  { flight ?id:name, #rest ?options:expression }
   =&gt; { make(&lt;flight&gt;, id: ?#&quot;id&quot;, ?options) }
end macro aircraft-definer;
</PRE>
<P> We might use the macro <CODE>define aircraft</CODE> as follows:</P>
<PRE>
define aircraft UA4906H (DC10)
  flight UA11, from: #&quot;BOS&quot;, to: #&quot;SFO&quot;;
  flight UA12, from: #&quot;SFO&quot;, to: #&quot;BOS&quot;;
end aircraft UA4906H;
</PRE>
<P> This macro shows a number of the more esoteric features of Dylan macros. First, notice the pattern variable <CODE>?flights</CODE>, which has no constraint, but rather is called out as an <B><A NAME=MARKER-2-878></A>auxiliary rule</B>. When the compiler matches this macro, it will try each of the auxiliary rule's patterns listed under <CODE>flights:</CODE> for a match. When it finds a match, it will assign the pattern variable <CODE>?flights</CODE> to the fragment resulting from the matching pattern's template substitution. In effect, auxiliary rules give a way of writing new constraints, combined with the effect of a subroutine for matching and substitution.</P>
<P>In this particular case, we use the auxiliary rule to map yet another auxiliary rule, <CODE>flight</CODE>, over a sequence of flight descriptions that look similar to the slot descriptions in a class. The mapping is signaled by the points of ellipsis (<CODE>...</CODE>) which means that the rule should be applied recursively (that is, the current rule is matched again to the fragment that matches <CODE>...</CODE>). Note that <CODE>flights</CODE> must have a rule to cover the case of there being no flight; that rule also handles the end of the recursion when the final flight has been matched.</P>
<P>The <CODE>flight</CODE> rule simply converts each flight name and its options into the appropriate call to <CODE>make</CODE>, to create the flight. We could extend this rule to allow a more natural specification for flight origin, destination, and time.</P>
<P>We do the work of defining an aircraft by calling the helper functions <BR><CODE>register-aircraft</CODE> and <CODE>register-flights</CODE> (which are not given here), but the macro takes care of getting the arguments in order. The substitution &quot;&lt;&quot; <CODE>## ?type ## &quot;&gt;&quot;</CODE> turns the name <CODE>DC10</CODE> into the name <CODE>&lt;DC10&gt;</CODE> by using <BR><B>concatenation</B>, allowing a more concise format for our definer while maintaining our convention for naming types. The substitution <CODE>?#&quot;identifier&quot;</CODE> turns the name <CODE>UA1306</CODE> into the symbol <CODE>#&quot;UA1306&quot;</CODE> by using <B>coercion</B>; the program can use the symbol <CODE>#&quot;UA1306&quot;</CODE> to look up an aircraft in the registry by name. The template for <CODE>flights</CODE> collects all the individual flights into a comma-separated list that is passed to <CODE>register-flights</CODE> as a <CODE>#rest</CODE> argument.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_335.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_333.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

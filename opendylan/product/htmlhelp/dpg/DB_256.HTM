<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_252.HTM">
<LINK REL=PREV HREF="DB_255.HTM">
<LINK REL=NEXT HREF="DB_257.HTM">
<TITLE>16.1.4   The forward-iteration protocol</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING256></A>

<DIV>
<P><A HREF="DB_257.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_255.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING256-0></A>
<H1>16.1.4   The f<A NAME=MARKER-2-695></A>orward-iteration protocol</H1>
<P> Dylan's forward-iteration protocol allows us to connect the usual collection iteration functions to our new collection class. Connecting to the forward-iteration protocol is as simple as defining an appropriate method for the <CODE>forward-<BR>iteration-protocol</CODE> generic function. This method must return two objects and six functions.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The <CODE>sorted-sequence.dylan</CODE> file. <I>(continued)</I></P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
<I>// This method enables many standard and user-defined collection operations
</I>define method forward-iteration-protocol 
    (sorted-sequence :: &lt;sorted-sequence&gt;)
 =&gt; (initial-state :: &lt;integer&gt;, limit :: &lt;integer&gt;,
     next-state :: &lt;function&gt;, finished-state? :: &lt;function&gt;,
     current-key :: &lt;function&gt;, current-element :: &lt;function&gt;,
     current-element-setter :: &lt;function&gt;, copy-state :: &lt;function&gt;)
  values(
         <I>// Initial state
</I>         0,
         <I>// Limit
</I>         sorted-sequence.size,
<I>          // Next state
</I>         method (collection :: &lt;sorted-sequence&gt;, state :: &lt;integer&gt;)
           state + 1
         end,
         <I>// Finished state?
</I>         method (collection :: &lt;sorted-sequence&gt;, state :: &lt;integer&gt;,
                 limit :: &lt;integer&gt;)
           state = limit;
         end,
         <I>// Current key
</I>         method (collection :: &lt;sorted-sequence&gt;, state :: &lt;integer&gt;)
           state
         end,
</TD></TR><TR VALIGN=TOP><TD>         <I>// Current element
</I>         element,
         <I>// Current element setter
</I>         method (value :: &lt;object&gt;, collection :: &lt;sorted-sequence&gt;, 
                 state :: &lt;integer&gt;)
           error(&quot;Setting an element of a sorted sequence 
                 is not allowed.&quot;);
         end,
         <I>// Copy state
</I>         identity);
end method forward-iteration-protocol; 
</TD></TR></TABLE></PRE>
<P> </P>
<P> </P>
<P> If we are to iterate over any collection, we must maintain some state to help the iterator remember the current point of iteration. For the forward-iteration protocol, we maintain this state using any object suitable for a given collection. In this case, an integer is sufficient to maintain where we are in the iteration process. The first object returned by <CODE>forward-iteration-protocol</CODE> is a state object that is suitable for the start of an iteration. The second object returned is a state object that represents the ending state of the iteration. Since, in this case, the state object is just the current key of the sorted sequence, the integer 0 is the correct initial state, and the integer that represents the size of the collection is the correct ending state. </P>
<P>The third value returned is a function that takes the collection and the current iteration state, and returns a state that is the next step in the iteration. In this case, we can determine the next state simply by adding 1 to the current state. </P>
<P>The fourth value returned is a function that receives the collection, the current state, and the ending state, and that determines whether the iteration is complete. In this case, we need only to check whether the current state is equal to the ending state. </P>
<P>The fifth value returned is a function that generates the current key into the collection, given a collection and a state. In this case, the key is the state object.</P>
<P>The sixth value returned is a function that receives a collection and a state, and returns the current element of the collection. In this case, the <CODE>element</CODE> function is the obvious choice, since our state is just the key. </P>
<P>The seventh value returned is a function that receives a new value, a collection, and a state, and changes the current element to be the new value. In this case, such an operation is illegal, since the only rational way to add elements to sorted sequences is with <CODE>add!</CODE>. Because this operation is illegal, an error is signaled. </P>
<P>The eighth and final value returned is a function that receives a collection and a state, and returns a copy of the state. In this case, we just return the state, because it is an integer and thus has no slots that are modified during the iteration process. If we represented the state with an object that had one or more slots that did change during iteration, we would have to make a new state instance and to copy the significant information from the old state instance to the new state instance.</P>
<P>Once we have defined a <CODE>forward-iteration-protocol</CODE> method for sorted sequences, we can iterate over them using <CODE>for</CODE> loops, mapping functions, and other collections iterators described in <A HREF="DB_139.HTM#MARKER-9-374">Chapter 11,  <I>Collections and Control Flow</I></A>. Also, if someone defines a new iterator that uses the forward-iteration protocol, then this new iterator will work with sorted sequences.</P>
<P>Dylan has se<A NAME=MARKER-2-696></A>veral other related protocols for backward iteration and for tables. See the <I>The Dylan Reference Manual</I> for details.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_257.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_255.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

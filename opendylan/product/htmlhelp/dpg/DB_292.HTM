<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_291.HTM">
<LINK REL=PREV HREF="DB_291.HTM">
<LINK REL=NEXT HREF="DB_293.HTM">
<TITLE>18.5.1   Use of a mix-in class</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING292></A>

<DIV>
<P><A HREF="DB_293.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_291.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING292-0></A>
<H1>18.5.1   Use of a mix-in class</H1>
<P> In our airport example, four classes now define slots that serve as names or strings that represent identifiers for objects:</P>
<PRE>
define abstract class &lt;vehicle-storage&gt; (&lt;physical-object&gt;)
  slot identifier :: &lt;string&gt;, required-init-keyword: id:;
  ...
end class &lt;vehicle-storage&gt;;
define abstract class &lt;vehicle&gt; (&lt;physical-object&gt;)
  slot vehicle-id :: &lt;string&gt;, required-init-keyword: id:;
  ...
end class &lt;vehicle&gt;;
define class &lt;airport&gt; (&lt;physical-object&gt;)
  slot name :: &lt;string&gt;, init-keyword: name:;
  ...
end class &lt;airport&gt;;
define class &lt;airline&gt; (&lt;object&gt;)
  slot name :: &lt;string&gt;, required-init-keyword: name:;
  ...
end class &lt;airline&gt;;
</PRE>
<P> Our example would be more unified and maintainable if we had a single representation for these identifiers.</P>
<P>There are several ways that we could improve the example using single inheritance. One way to do that in principle would be to define a <CODE>name</CODE> slot in a common superclass. In this case, we cannot use this solution, because the only common superclass is the built-in class <CODE>&lt;object&gt;</CODE>. This approach would work if all named classes inherited from <CODE>&lt;physical-object&gt;</CODE> -- we could add a <CODE>name</CODE> slot to <CODE>&lt;physical-object&gt;</CODE>. But then all subclasses of <CODE>&lt;physical-object&gt;</CODE> would inherit the <CODE>name</CODE> slot, whether or not those subclasses need names. Some objects might be inappropriately named, and those instances would be larger than they need to be.</P>
<P>Another approach would be to define two new subclasses to contain the <CODE>name</CODE> slot: a <CODE>&lt;named-object&gt;</CODE> subclass of <CODE>&lt;object&gt;</CODE>, and a <CODE>&lt;named-physical-object&gt;</CODE> subclass of <CODE>&lt;physical-object&gt;</CODE>. We would then use <CODE>&lt;named-physical-object&gt;</CODE> as the superclass for <CODE>&lt;vehicle-storage&gt;</CODE>, <CODE>&lt;vehicle&gt;</CODE>, and <CODE>&lt;airport&gt;</CODE>, and we would use <CODE>&lt;named-object&gt;</CODE> as the superclass for <CODE>&lt;airline&gt;</CODE>. That would work, too, although the <CODE>name</CODE> slot would be defined in two classes, rather than in one.</P>
<P>Suppose, however, that we later find that some, but not all, subclasses need another attribute, such as a unique identifier. Perhaps <CODE>&lt;airport&gt;,</CODE> <CODE>&lt;vehicle&gt;</CODE>, and <CODE>&lt;airline&gt;</CODE> need unique identifiers, but <CODE>&lt;vehicle-storage&gt;</CODE> does not. Extending this model, we might have to define new classes <CODE>&lt;unique-object&gt;</CODE>, <CODE>&lt;unique-named-object&gt;</CODE>, <CODE>&lt;unique-physical-object&gt;</CODE>, and <CODE>&lt;unique-named-physical-object&gt;</CODE>. We now have eight base classes to represent the possible combinations of name and unique identifier. If we add a third attribute, we end up with many more classes. We soon have an unmanageable proliferation of base classes.</P>
<P>Multiple inheritance provides a solution to these problems. We can define a mix-in class, <CODE>name-mix-in</CODE>, whose only purpose is to contain the <CODE>name</CODE> slot:</P>
<PRE>
define abstract class &lt;name-mix-in&gt; (&lt;object&gt;)
  slot name :: &lt;string&gt;, init-keyword: name:;
end class &lt;name-mix-in&gt;;
</PRE>
<P> Now, we redefine our <CODE>&lt;vehicle-storage&gt;</CODE>, <CODE>&lt;vehicle&gt;</CODE>, <CODE>&lt;airport&gt;</CODE>, and <CODE>&lt;airline&gt;</CODE> classes to have two direct superclasses: <CODE>&lt;name-mix-in&gt;</CODE>, and either <CODE>&lt;object&gt;</CODE> or <CODE>&lt;physical-object&gt;</CODE>:</P>
<PRE>
define abstract class &lt;vehicle-storage&gt; (&lt;name-mix-in&gt;, &lt;physical-object&gt;)
  <I>// identifier slot removed
</I>  required keyword name:;
  ...
end class &lt;vehicle-storage&gt;;
define abstract class &lt;vehicle&gt; (&lt;name-mix-in&gt;, &lt;physical-object&gt;)
  <I>// vehicle-id slot removed
</I>  required keyword name:;
  ...
end class &lt;vehicle&gt;;
define class &lt;airport&gt; (&lt;name-mix-in&gt;, &lt;physical-object&gt;)
  <I>// name slot removed
</I>  keyword name:, init-value: &quot;Anonymous Airport&quot;;
  ...
end class &lt;airport&gt;;
define class &lt;airline&gt; (&lt;name-mix-in&gt;, &lt;object&gt;)
  <I>// name slot removed
</I>  required keyword name:;
  ...
end class &lt;airline&gt;;
</PRE>
<P> We use the <CODE>required keyword</CODE> option to make the <CODE>name:</CODE> keyword required when we create an instance of <CODE>&lt;vehicle-storage&gt;</CODE>, <CODE>&lt;vehicle&gt;</CODE>, or <CODE>&lt;airline&gt;</CODE>. If we provided an <CODE>init-value:</CODE> or <CODE>init-function:</CODE> for the <CODE>name</CODE> slot in the definition of <CODE>&lt;name-mix-in&gt;</CODE>, Dylan would ignore that option when we created an instance of any of these subclasses.</P>
<P>We also use the <CODE>keyword</CODE> option with an <CODE>init-value:</CODE> to provide a default initial value for the <CODE>name:</CODE> initialization argument and for the <CODE>name</CODE> slot for instances of <CODE>&lt;airport&gt;</CODE>.</P>
<P>Of course, we also have to change other code in our example to use the name <CODE>name</CODE> and the init keyword <CODE>name:</CODE> when referring to the slot.</P>
<P>Multiple inheritance provides several advantages in solving the name <BR>problem:</P>
<P>1.  We localize in a single class the characteristic of having a name.</P>
<P>2.  Subclasses can still customize aspects of the name attribute, such as what that attribute's initial value is, and whether or not it is required.</P>
<P>3.  We can give a subclass a name attribute without redefining any of its <BR>superclasses.</P>
<P>4.  The only subclasses that have a name attribute are those for which that is appropriate.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_293.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_291.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

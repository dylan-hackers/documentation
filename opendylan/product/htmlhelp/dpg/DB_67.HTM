<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_64.HTM">
<LINK REL=PREV HREF="DB_66.HTM">
<LINK REL=NEXT HREF="DB_68.HTM">
<TITLE>5.1.3   Methods on &lt;time-offset&gt;</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING67></A>

<DIV>
<P><A HREF="DB_68.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_66.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING67-0></A>
<H1>5.1.3   <A NAME=MARKER-9-206></A>Methods on <EM>&lt;time-offset&gt;</EM></H1>
<P> Because a <CODE>&lt;time-offset&gt;</CODE> can represent future time or past time, it will be useful to provide a convenient way to determine whether a <CODE>&lt;time-offset&gt;</CODE> is in the past. We define a new predicate named <CODE>past?</CODE> as follows:</P>
<PRE>
define method past? (time :: &lt;time-offset&gt;) =&gt; (past? :: &lt;boolean&gt;)
  time.total-seconds &lt; 0;
end method past?;
</PRE>
<P> The <CODE>past?</CODE> method returns an instance of <CODE>&lt;boolean&gt;</CODE>, which is <CODE>#t</CODE> if the time offset is in the past, and otherwise is <CODE>#f</CODE>. Here is an example:</P>
<PRE>
<I>? </I>past?(*my-time-offset*)
<I>#f</I>
<I>? </I>past?(*your-time-offset*)
<I>#t</I>
</PRE>
<P> We need a method to describe instances of <CODE>&lt;time-offset&gt;</CODE>. The output should look like this:</P>
<PRE>
<I>? </I>say-time-offset(*my-time-offset*);
<I>plus 15:20</I>
<I>? </I>say-time-offset(*your-time-offset*);
<I>minus 6:45</I>
</PRE>
<P> We might define the method in this way: </P>
<PRE>
define method say-time-offset (time :: &lt;time-offset&gt;) =&gt; ()
  let(hours, minutes) = decode-total-seconds(time);
  format-out(&quot;%s %d:%s%d&quot;,
             if (past?(time)) &quot;minus&quot; else &quot;plus&quot; end, 
             hours, 
             if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end,
             minutes);
end method say-time-offset;
</PRE>
<P> If we test this method in a listener, however, the result is different:</P>
<PRE>
<I>? </I>say-time-offset(*my-time-offset*);
<I>ERROR: No applicable method for decode-total-seconds with argument {instance &lt;time-offset&gt;}</I>
</PRE>
<P> "<A NAME=MARKER-2-207></A>No applicable method" means that there is no method for this generic function that is appropriate for the arguments. To understand this error, we can look at the methods for <CODE>decode-total-seconds</CODE> in <A HREF="DB_60.HTM#MARKER-9-138">Figure 4.1, page 49</A>. One method takes an argument of the type <CODE>&lt;integer&gt;</CODE>. Another method takes an argument of the type <CODE>&lt;time-of-day&gt;</CODE>. There is no method for instances of <CODE>&lt;time-offset&gt;</CODE>, so Dylan signals an error. There are three possible approaches to solving this problem.</P>
<P>As a first approach, we could define the <CODE>say-time-offset</CODE> method to call <CODE>decode-total-seconds</CODE> with an integer. </P>
<PRE>
<I>// First approach: Call decode-total-seconds with an integer
</I>define method say-time-offset (time :: &lt;time-offset&gt;) =&gt; ()	<I>// 1
</I>  let(hours, minutes) = decode-total-seconds(abs(time.total-seconds));	<I>// 2
</I>  format-out(&quot;%s %d:%s%d&quot;,	<I>// 3
</I>             if (past?(time)) &quot;minus&quot; else &quot;plus&quot; end, 	<I>// 4
</I>             hours, 	<I>// 5
</I>             if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end,<I>	// 6
</I>             minutes);	<I>// 7
</I>end method say-time-offset;	<I>// 8	</I>
</PRE>
<P> We changed only the call to <CODE>decode-total-seconds</CODE> on line 2. Here, we call it with the absolute value (returned by the <A NAME=MARKER-2-208></A><CODE>abs</CODE> function) of the <CODE>total-seconds</CODE> slot.</P>
<P>This approach works, but it is awkward because we need to remember what kinds of arguments <CODE>decode-total-seconds</CODE> can take. The convenient calling syntax that we introduced for calling <CODE>decode-total-seconds</CODE> with an instance of <CODE>&lt;time-of-day&gt;</CODE> is not available for other kinds of time.</P>
<P>As a second approach, we could to define a third method for <CODE>decode-total-seconds</CODE> that takes as its argument an instance of <CODE>&lt;time-offset&gt;</CODE>:</P>
<PRE>
<I>// Second approach: Define a method on &lt;time-offset&gt;
</I>define method decode-total-seconds (time :: &lt;time-offset&gt;) =&gt; ()
  decode-total-seconds(abs(time.total-seconds));
end method decode-total-seconds;
</PRE>
<P> The method for <CODE>say-time-offset</CODE> can then call <CODE>decode-total-seconds</CODE>, as we did in the first place: </P>
<PRE>
define method say-time-offset (time :: &lt;time-offset&gt;) =&gt; ()
  let(hours, minutes) = decode-total-seconds(time);
  format-out(&quot;%s %d:%s%d&quot;,
             if (past?(time)) &quot;minus&quot; else &quot;plus&quot; end, 
             hours, 
             if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end,
             minutes);
end method say-time-offset;
</PRE>
<P> This approach works, and it preserves the flexibility of calling <CODE>decode-total-seconds</CODE> on instances of <CODE>&lt;integer&gt;</CODE>, <CODE>&lt;time-of-day&gt;</CODE>, and <CODE>&lt;time-offset&gt;</CODE>. However, the body of the method on <CODE>&lt;time-offset&gt;</CODE> (defined in this section) is nearly identical to the body of the method on <CODE>&lt;time-of-day&gt;</CODE> (defined in <A HREF="DB_60.HTM#MARKER-9-187">Section 4.6.5, page 48</A>). The only difference is that we use <CODE>abs</CODE> in the method on <CODE>&lt;time-offset&gt;</CODE> but not in the method on <CODE>&lt;time-of-day&gt;</CODE>. If we used it in the method on <CODE>&lt;time-of-day&gt;</CODE>, it would be harmless. Duplication of code is ugly, adds maintenance overhead, and is particularly undesirable when programming in an object-oriented language, where it may indicate a flaw in the overall design.</P>
<P>The best solution to the problem lies in a third approach -- to rethink the classes and methods in a more object-oriented style, using inheritance. We show this solution in the next section.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_68.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_66.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_281.HTM">
<LINK REL=PREV HREF="DB_281.HTM">
<LINK REL=NEXT HREF="DB_283.HTM">
<TITLE>18.1.1   Modeling of ground vehicles</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING282></A>

<DIV>
<P><A HREF="DB_283.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_281.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING282-0></A>
<H1>18.1.1   Modeling of ground vehicles</H1>
<P> An obvious early step in modeling the behavior of fuel trucks would be to define a <CODE>&lt;fuel-truck&gt;</CODE> class. Presumably, we would want that class to inherit from </P>
<P></P>
<TABLE BORDER=1><CAPTION><P>Figure 18.1   <A NAME=MARKER-9-722></A>Hierarchy of vehicle classes.</P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB28IM29.GIF></P>
</TD></TR></TABLE><P> <CODE>&lt;vehicle&gt;</CODE>. Let's look at our current definitions of both the <CODE>&lt;vehicle&gt;</CODE> class and its only direct subclass, <CODE>&lt;aircraft&gt;</CODE>:</P>
<PRE>
<I>// The class that represents all self-propelled devices
</I>define abstract class &lt;vehicle&gt; (&lt;physical-object&gt;)
<I>  // Every vehicle has a unique identification code
</I>  slot vehicle-id :: &lt;string&gt;, required-init-keyword: id:;
<I>  // The normal operating speed of this class of vehicle in miles per hour
</I>  each-subclass slot cruising-speed :: &lt;positive-integer&gt;;
<I>  // Allow individual differences in the size of particular aircraft, while
  // providing a suitable default for each class of aircraft
</I>  each-subclass slot standard-size :: &lt;size&gt;;
end class &lt;vehicle&gt;; 
<I>// This class represents vehicles that normally fly for a portion of
// their trip
</I>define abstract class &lt;aircraft&gt; (&lt;vehicle&gt;)
  slot altitude :: &lt;integer&gt;, init-keyword: altitude:;
<I>  // Direction here is either #"inbound" or #"outbound".
</I>  slot direction :: &lt;symbol&gt;;
  <I>// The next transition that this aircraft might be able to make.
</I>  slot next-transition :: &lt;aircraft-transition&gt;,
    required-init-keyword: transition:, setter: #f;
end class &lt;aircraft&gt;; 
</PRE>
<P> As a start, we can define a <CODE>&lt;fuel-truck&gt;</CODE> class as a subclass of <CODE>&lt;vehicle&gt;</CODE>. To operate on instances of this class, we will no doubt need to know how much aircraft fuel they contain. We define one initial slot, <CODE>aircraft-fuel-remaining</CODE>. We also need to provide initial values for the inherited slots <CODE>cruising-speed</CODE> and <CODE>standard-size</CODE>.</P>
<PRE>
define class &lt;fuel-truck&gt; (&lt;vehicle&gt;)
<I>  // Amount of aircraft fuel remaining in the tank
</I>  slot aircraft-fuel-remaining :: &lt;integer&gt;,
    init-keyword: aircraft-fuel-remaining:, init-value: 0;
  inherited slot cruising-speed, init-value: 25;
  inherited slot standard-size,
    init-value: make(&lt;size&gt;, length: 30, width: 10, height: 10);
end class &lt;fuel-truck&gt;;
</PRE>
<P> This definition serves our immediate purpose, but the class hierarchy is not as modular as it might be. Suppose that we want to take account of other vehicles on the ground, such as baggage carriers or fire trucks? We can anticipate that all ground vehicles might have common features, and we do not want each new class to be a direct subclass of <CODE>&lt;vehicle&gt;</CODE>. As a refinement, we define two intermediary classes, <CODE>&lt;ground-vehicle&gt;</CODE> and <CODE>&lt;flying-vehicle&gt;</CODE>:</P>
<PRE>
define abstract class &lt;ground-vehicle&gt; (&lt;vehicle&gt;)
end class &lt;ground-vehicle&gt;;
define abstract class &lt;flying-vehicle&gt; (&lt;vehicle&gt;)
end class &lt;flying-vehicle&gt;;
define class &lt;fuel-truck&gt; (&lt;ground-vehicle&gt;)
<I>  // How much aircraft fuel is left in the tank
</I>  slot aircraft-fuel-remaining :: &lt;integer&gt;,
    init-keyword: aircraft-fuel-remaining:, init-value: 0;
  inherited slot cruising-speed, init-value: 25;
  inherited slot standard-size,
    init-value: make(&lt;size&gt;, length: 30, width: 10, height: 10);
end class &lt;fuel-truck&gt;;
define abstract class &lt;aircraft&gt; (&lt;flying-vehicle&gt;)
  slot altitude :: &lt;integer&gt;, init-keyword: altitude:;
  slot direction :: &lt;symbol&gt;;
  slot next-transition :: &lt;aircraft-transition&gt;,
    required-init-keyword: transition:, setter: #f;
end class &lt;aircraft&gt;;
</PRE>
<P> At this point, we are going to leave the fuel-truck simulation. We do not model the fuel-supply problem further in this book. We do want to explore opportunities that our new class hierarchy presents for restructuring the aircraft classes.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_283.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_281.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

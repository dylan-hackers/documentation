<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_182.HTM">
<LINK REL=PREV HREF="DB_187.HTM">
<LINK REL=NEXT HREF="DB_189.HTM">
<TITLE>12.3.6   Closures</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING188></A>

<DIV>
<P><A HREF="DB_189.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_187.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING188-0></A>
<H1>12.3.6   <A NAME=MARKER-9-568></A>Closures</H1>
<P> This section describes closures<A NAME=MARKER-2-569></A> -- an advanced concept. If you do not understand or wish to study this section, you can safely skip it. </P>
<P>Consider the following example:</P>
<PRE>
define method call-and-show (function :: &lt;function&gt;, #rest arguments)
  format-out(&quot;The result is %=.\n&quot;, apply(function, arguments));
end method call-and-show;
define method show-next (x :: &lt;integer&gt;)
  call-and-show(method () x + 1 end method);
end method show-next;
</PRE>
<P> When we execute this code, we get the expected result: </P>
<PRE>
<I>?</I> show-next(41);
<I>The result is 42.</I>
</PRE>
<P> But why did we get that result? We created an anonymous method in <CODE>show-next</CODE>, and passed that anonymous method into a completely separate method (<CODE>call-and-show</CODE>), where <CODE>x</CODE> is not bound to anything. And yet, when the <CODE>call-and-show</CODE> method executed the anonymous method that we made, somehow the anonymous method could still access the <CODE>x</CODE> binding. We got this reasonable result because the <CODE>method</CODE> statement can create a special kind of method called a closure.</P>
<P>Recall that Dylan has two kinds of variable: module variables and local variables. A local variable<A NAME=MARKER-2-570></A> is defined explicitly by a <CODE>let</CODE> or <CODE>local</CODE> declaration, and implicitly by a function call, when a method's parameters are initialized to that method's arguments. Local variables are defined within a limited <B>lexical scope<A NAME=MARKER-2-571></A></B> -- that is, they <B>bind<A NAME=MARKER-2-572></A></B> a name to a value only within a particular textual portion of the program. This portion of the program is that part of the innermost body that follows the definition of the local variable.</P>
<P>A <CODE>method<A NAME=MARKER-2-573></A></CODE> statement or a <CODE>loca<A NAME=MARKER-2-574></A>l</CODE> declaration can define a method in a portion of a program where local variables are in effect. In the preceding example, we use a <CODE>method</CODE> statement to define a method inside the body of the <CODE>show-next</CODE> method, where the local variable <CODE>x</CODE> (the parameter for the <CODE>show-next</CODE> method) is bound to the argument to <CODE>show-next</CODE>. The method that we define inside <CODE>show-next</CODE> refers to that local variable <CODE>x</CODE>.</P>
<P>In general, when a program exits a body, the local variables defined inside that body cease to be defined, and it is an error for the program to refer to those variables. But there is an exception. If we use <CODE>method</CODE> or <CODE>local</CODE> to define a method, and if we then execute that method outside the body in which we define it, the method can still refer to the local variables that were in effect when the method was defined. Such a method is called a closure.</P>
<P>A <B>closure<A NAME=MARKER-2-575></A></B> is a method that <B>closes over</B> or captures local variables that are in effect when the method is defined and that are referred to in the body of the method. The closure created by the <CODE>method</CODE> statement in our example captures the local variable <CODE>x</CODE>. So, even though the local variable <CODE>x</CODE> is not defined in the lexical scope of the <CODE>call-and-show</CODE> method, the closure called by <CODE>call-and-show</CODE> can access the captured binding of <CODE>x</CODE>.</P>
<P>For examples of closures as iteration or mapping functions for collections, see <A HREF="DB_150.HTM#MARKER-9-405">Section 11.3.5, page 146</A>, and <A HREF="DB_152.HTM#MARKER-9-410">Section 11.3.7, page 147</A>.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_189.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_187.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

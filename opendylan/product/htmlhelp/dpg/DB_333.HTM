<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_329.HTM">
<LINK REL=PREV HREF="DB_332.HTM">
<LINK REL=NEXT HREF="DB_334.HTM">
<TITLE>21.4   Constraints</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING333></A>

<DIV>
<P><A HREF="DB_334.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_332.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING333-0></A>
<H1>21.4   Constrai<A NAME=MARKER-2-874></A>nts</H1>
<P> So far, in our macros, we have seen the constraint <CODE>expression</CODE> used for the pattern variables. Except for a few unusual cases, pattern variables must always have a constraint associated with them. Constraints serve two purposes: they limit the fragment that the pattern variable will match, and they define the meaning of the pattern variable when it is substituted. As an example, consider the following <A NAME=MARKER-2-875></A><B>statement macro</B>, which we might find useful for manipulating the decoded parts of seconds:</P>
<PRE>
define macro with-decoded-seconds
  { 
    with-decoded-seconds 
        (?max:variable, ?min:variable, ?sec:variable = ?time:expression) 
      ?:body 
    end
  }
 =&gt; {
       let (?max, ?min, ?sec) = decode-total-seconds(?time);
       ?body
    }
end macro;
</PRE>
<P> The preceding macro might be used as follows:</P>
<PRE>
define method say (time :: &lt;time&gt;)
  with-decoded-seconds(hours, minutes, seconds = time)
    format-out(&quot;%d:%s%d&quot;, 
               hours, if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end, minutes);
  end;
end method say;
</PRE>
<P> A statement macro can appear anywhere that a <CODE>begin</CODE>/<CODE>end;</CODE> block can appear. A statement macro introduces a new <B>begin word</B> -- in this case, <CODE>with-decoded-seconds</CODE> -- and is matched against a fragment that extends up to the matching <CODE>end</CODE>. </P>
<P>The pattern and the constraints on the pattern variables limit what the macro will match; they define the syntax of this particular statement. In the case of <CODE>with-decoded-seconds</CODE>, the syntax of this statement begins with a parenthesized list of</P>
<UL>
<LI><P>Three <CODE>variable</CODE> expressions (that is, <CODE>name :: &lt;type&gt;</CODE>, where the type is optional) </P>
<LI><P>The literal token <CODE>=</CODE> </P>
<LI><P>An <CODE>expression</CODE> (any Dylan expression yielding a value) </P>
</UL>
<P> After the parenthesized list comes a <CODE>body</CODE> (any sequence of expressions separated by <CODE>;</CODE>, just as would be valid in a <CODE>begin</CODE>/<CODE>end;</CODE> block). Note the use of the abbreviation <CODE>?:body</CODE>, to mean <CODE>?body:body</CODE> (a pattern variable, <CODE>body</CODE>, with the constraint <CODE>body</CODE>).</P>
<P>The constraints are similar to type declarations on variables: They limit the acceptable values of the pattern variables, and they help to document the interface of the macro. The constraints also serve a second purpose: Once the compiler has recognized a fragment under a particular constraint, it will ensure the correct behavior of that fragment when that fragment is substituted in a template. For example, suppose that we define a function macro:</P>
<PRE>
define macro times
  { times (?arg1:expression, ?arg2:expression ) } =&gt;
    { ?arg1 * ?arg2 }
end macro times;
</PRE>
<P> We might use the macro as follows:</P>
<PRE>
times(1 + 3, 2 + 5);
</PRE>
<P> Here is the expanded macro:</P>
<PRE>
1 + 3<EM> * </EM>2 + 5
</PRE>
<P> We can see that, if the macro were a simple text-substitution macro, the result would be 12, rather than the 28 we were expecting. But because, in Dylan, the constraint is maintained when a pattern variable is substituted (that is, the expression that makes up each of the pattern variables remains a single expression), the result is as though the macro automatically inserted parentheses, and the expansion were</P>
<PRE>
<EM>(</EM>1 + 3<EM>) * (</EM>2 + 5<EM>)</EM>
</PRE>
<P> Some development environments may display the implicit parentheses of an expression constraint. Thus, the macro will yield the expected result of 28.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparis<A NAME=MARKER-2-855></A>on with C:</B> Because C macros are simple textual substitutions, the macro writer must be sure to insert parentheses around every macro variable when it is substituted, and around the macro expansion itself, to prevent the resulting expansion from taking on new meanings.</P>
</TD></TR></TABLE>
</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_334.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_332.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

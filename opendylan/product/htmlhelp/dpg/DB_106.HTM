<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_103.HTM">
<LINK REL=PREV HREF="DB_105.HTM">
<LINK REL=NEXT HREF="DB_107.HTM">
<TITLE>8.3   The implementation file</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING106></A>

<DIV>
<P><A HREF="DB_107.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_105.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING106-0></A>
<H1>8.3   The implementation file</H1>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The implementation file: <CODE>library-implementation.dylan</CODE>. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
module: timespace
<I>// The sixty-unit class</I>
define abstract class &lt;sixty-unit&gt; (&lt;object&gt;)
  slot total-seconds :: &lt;integer&gt;, init-keyword: total-seconds:;
end class &lt;sixty-unit&gt;;
</TD></TR><TR VALIGN=TOP><TD><I>// decode-total-seconds</I>
define method decode-total-seconds 
    (sixty-unit :: &lt;sixty-unit&gt;)
 =&gt; (max-unit :: &lt;integer&gt;, minutes :: &lt;integer&gt;, seconds :: &lt;integer&gt;)
  decode-total-seconds(abs(time.total-seconds));
end method decode-total-seconds;
</TD></TR><TR VALIGN=TOP><TD>define method decode-total-seconds
    (total-seconds :: &lt;integer&gt;)
 =&gt; (hours :: &lt;integer&gt;, minutes :: &lt;integer&gt;, seconds :: &lt;integer&gt;)<I>	</I>  let(total-minutes, seconds) = truncate/(total-seconds, 60);
  let(hours, minutes) = truncate/(total-minutes, 60);
  values(hours, minutes, seconds);
end method decode-total-seconds; 
</TD></TR><TR VALIGN=TOP><TD><I>// encode-total-seconds</I>
define method encode-total-seconds 
    (max-unit :: &lt;integer&gt;, minutes :: &lt;integer&gt;, seconds :: &lt;integer&gt;) 
 =&gt; (total-seconds :: &lt;integer&gt;)
  ((max-unit * 60) + minutes) * 60 + seconds;
end method encode-total-seconds; 
</TD></TR><TR VALIGN=TOP><TD><I>// The say generic function</I>
<I>// Given an object, print a description of the object
</I>define generic say (any-object :: &lt;object&gt;) =&gt; (); 
</TD></TR><TR VALIGN=TOP><TD><I>// The time classes and methods</I>
define abstract class &lt;time&gt; (&lt;sixty-unit&gt;)
end class &lt;time&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define method say (time :: &lt;time&gt;) =&gt; ()
  let (hours, minutes) = decode-total-seconds(time); 
  format-out
    (&quot;%d:%s%d&quot;, hours, if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end, minutes);
end method say; 
</TD></TR><TR VALIGN=TOP><TD><I>// A specific time of day from 00:00 (midnight) to before 24:00 (tomorrow)
</I>define class &lt;time-of-day&gt; (&lt;time&gt;)
end class &lt;time-of-day&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I>// A relative time between -24:00 and +24:00
</I>define class &lt;time-offset&gt; (&lt;time&gt;)
end class &lt;time-offset&gt;; 
</TD></TR><TR VALIGN=TOP><TD><I>// Method for determining whether a time offset is in the past
</I>define method past? (time :: &lt;time-offset&gt;) =&gt; (past? :: &lt;boolean&gt;)
  time.total-seconds &lt; 0;
end method past?; 
</TD></TR><TR VALIGN=TOP><TD>define method say (time :: &lt;time-offset&gt;)
  format-out(&quot;%s &quot;, if (past?(time)) &quot;minus&quot; else &quot;plus&quot; end);
  next-method();
end method say; 
</TD></TR><TR VALIGN=TOP><TD><I>// Methods for adding times</I>
define method \+ 
    (offset1 :: &lt;time-offset&gt;, offset2 :: &lt;time-offset&gt;) 
 =&gt; (sum :: &lt;time-offset&gt;)	<I> 
</I>  let sum = offset1.total-seconds + offset2.total-seconds; 
  make(&lt;time-offset&gt;, total-seconds: sum); 
end method \+;	<I> </I>
</TD></TR><TR VALIGN=TOP><TD>define method \+ 
    (offset :: &lt;time-offset&gt;, time-of-day :: &lt;time-of-day&gt;)
 =&gt; (sum :: &lt;time-of-day&gt;)
  make(&lt;time-of-day&gt;, 
       total-seconds: offset.total-seconds + time-of-day.total-seconds);
end method \+; 
</TD></TR><TR VALIGN=TOP><TD>define method \+ 
    (time-of-day :: &lt;time-of-day&gt;, offset :: &lt;time-offset&gt;)
 =&gt; (sum :: &lt;time-of-day&gt;)
  offset + time-of-day;
end method \+; 
</TD></TR><TR VALIGN=TOP><TD>define method \+ (time1 :: &lt;time&gt;, time2 :: &lt;time&gt;)
  error(&quot;Sorry, we can't add a %s to a %s.&quot;, 
        object-class(time1), object-class(time2));
end method \+; 
</TD></TR><TR VALIGN=TOP><TD><I>// Methods for comparing times</I>
define method \&lt; (time1 :: &lt;time-of-day&gt;, time2 :: &lt;time-of-day&gt;)
  time1.total-seconds &lt; time2.total-seconds;
end method \&lt;; 
</TD></TR><TR VALIGN=TOP><TD>define method \&lt; (time1 :: &lt;time-offset&gt;, time2 :: &lt;time-offset&gt;)
  time1.total-seconds &lt; time2.total-seconds;
end method \&lt;; 
</TD></TR><TR VALIGN=TOP><TD>define method \= (time1 :: &lt;time-of-day&gt;, time2 :: &lt;time-of-day&gt;)
  time1.total-seconds = time2.total-seconds;
end method \=; 
</TD></TR><TR VALIGN=TOP><TD>define method \= (time1 :: &lt;time-offset&gt;, time2 :: &lt;time-offset&gt;)
  time1.total-seconds = time2.total-seconds;
end method \=; 
</TD></TR><TR VALIGN=TOP><TD><I>// The angle classes and methods</I>
define abstract class &lt;angle&gt; (&lt;sixty-unit&gt;)
end class &lt;angle&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define method say (angle :: &lt;angle&gt;) =&gt; ()
  let(degrees, minutes, seconds) = decode-total-seconds(angle);
  format-out
    (&quot;%d degrees %d minutes %d seconds&quot;,
     degrees, minutes, seconds);
end method say; 
</TD></TR><TR VALIGN=TOP><TD>define class &lt;relative-angle&gt; (&lt;angle&gt;)
end class &lt;relative-angle&gt;;
</TD></TR><TR VALIGN=TOP><TD><I>// We need to show degrees for &lt;relative-angle&gt; but we do not need to 
// show minutes and seconds, so we override the method on &lt;angle&gt;
</I>define method say (angle :: &lt;relative-angle&gt;) =&gt; ()
  format-out(&quot; %d degrees&quot;, decode-total-seconds(angle));
end method say; 
</TD></TR><TR VALIGN=TOP><TD>define abstract class &lt;directed-angle&gt; (&lt;angle&gt;)
  slot direction :: &lt;string&gt;, init-keyword: direction:;
end class &lt;directed-angle&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define method say (angle :: &lt;directed-angle&gt;) =&gt; ()
  next-method();
  format-out(&quot; %s&quot;, angle.direction);
end method say; 
</TD></TR><TR VALIGN=TOP><TD><I>// The latitude and longitude classes and methods</I>
define class &lt;latitude&gt; (&lt;directed-angle&gt;)
end class &lt;latitude&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define method say (latitude :: &lt;latitude&gt;) =&gt; ()
  next-method();
  format-out(&quot; latitude\n&quot;);
end method say; 
</TD></TR><TR VALIGN=TOP><TD>define class &lt;longitude&gt; (&lt;directed-angle&gt;)
end class &lt;longitude&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define method say (longitude :: &lt;longitude&gt;) =&gt; ()
  next-method();
  format-out(&quot; longitude\n&quot;);
end method say; 
</TD></TR><TR VALIGN=TOP><TD><I>// The position classes and methods</I>
define abstract class &lt;position&gt; (&lt;object&gt;)
end class &lt;position&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define class &lt;absolute-position&gt; (&lt;position&gt;)
  slot latitude :: &lt;latitude&gt;, init-keyword: latitude:;
  slot longitude :: &lt;longitude&gt;, init-keyword: longitude:;
end class &lt;absolute-position&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define method say (position :: &lt;absolute-position&gt;) =&gt; ()
  say(position.latitude);
  say(position.longitude);
end method say; 
</TD></TR><TR VALIGN=TOP><TD>define class &lt;relative-position&gt; (&lt;position&gt;)
<I>  // Distance is in miles
</I>  slot distance :: &lt;single-float&gt;, init-keyword: distance:;
  slot angle :: &lt;angle&gt;, init-keyword: angle:;
end class &lt;relative-position&gt;; 
</TD></TR><TR VALIGN=TOP><TD>define method say (position :: &lt;relative-position&gt;) =&gt; ()
  format-out(&quot;%d miles away at heading &quot;, position.distance);
  say(position.angle);
end method say; 
</TD></TR></TABLE></PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_107.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_105.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

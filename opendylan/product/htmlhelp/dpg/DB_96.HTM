<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_92.HTM">
<LINK REL=PREV HREF="DB_95.HTM">
<LINK REL=NEXT HREF="DB_97.HTM">
<TITLE>7.4   Absolute position</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING96></A>

<DIV>
<P><A HREF="DB_97.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_95.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING96-0></A>
<H1>7.4   <A NAME=MARKER-9-266></A>Absolute position</H1>
<P> </P>
<P> The <CODE>&lt;absolute-position&gt;</CODE> class represents latitude and longitude. One way to represent latitude and longitude is with degrees, minutes, seconds, and a direction. We can use the approach of combining degrees, minutes, and seconds into a total-seconds slot as we did for <CODE>&lt;time&gt;</CODE>. We can also define a class that represents total seconds and a direction, and call it <CODE>&lt;directed-angle&gt;</CODE>: </P>
<P> </P>
<PRE>
<A NAME=MARKER-9-267></A>define abstract class &lt;directed-angle&gt; (&lt;object&gt;)
  slot total-seconds :: &lt;integer&gt;, init-keyword: total-seconds:;
  slot direction :: &lt;string&gt;, init-keyword: direction:;
end class &lt;directed-angle&gt;;
</PRE>
<P> </P>
<P> We use the <CODE>&lt;directed-angle&gt;</CODE> class in the definition of <CODE>&lt;absolute-position&gt;</CODE>:</P>
<P> </P>
<PRE>
define class &lt;absolute-position&gt; (&lt;position&gt;)
  slot latitude :: &lt;directed-angle&gt;, init-keyword: latitude:;
  slot longitude :: &lt;directed-angle&gt;, init-keyword: longitude:;
end class &lt;absolute-position&gt;;
</PRE>
<P>  </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Modularity note:</B> The <CODE>&lt;directed-angle&gt;</CODE> class represents the characteristics that latitude and longitude have in common.</P>
</TD></TR></TABLE><P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison to <A NAME=MARKER-2-257></A>C:</B> If you are familiar with a language that uses explicit pointers, such as C, you may be confused by Dylan's object model. Although there is no pointer-to operation in Dylan, there are pointers in the implementation. If you are trying to imagine how Dylan objects are implemented, think in terms of always manipulating a pointer to the object -- a Dylan variable (or slot) stores a pointer to an object, rather than a copy of the object's slots. Similarly, assignment, argument passing, and identity comparison are in terms of pointers to objects. See <A HREF="DB_345.HTM#MARKER-9-926">Appendix B,  <I>Dylan Object Model for C and C++ Programmers</I></A>. </P>
</TD></TR></TABLE><TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison to <A NAME=MARKER-2-258></A>Java:</B> Java recognizes that pointers make it extremely difficult to enforce safety and for a compiler to reason about a program for optimization. Java supports an object model similar to that of Dylan, where pointers are used in the implementation of objects, but are not visible to Java programs.</P>
</TD></TR></TABLE><P> </P>
<P> </P>
<P> We could define the <CODE>say</CODE> method as follows: </P>
<P> </P>
<PRE>
define method say (position :: &lt;absolute-position&gt;) =&gt; ()
  format-out(&quot;%d degrees %d minutes %d seconds %s latitude\n&quot;,
             decode-total-seconds(position.latitude));
  format-out(&quot;%d degrees %d minutes %d seconds %s longitude\n&quot;,
             decode-total-seconds(position.longitude));
end method say;
</PRE>
<P> </P>
<P> The preceding method depends on <CODE>decode-total-seconds</CODE> having a method that is applicable to <CODE>&lt;directed-angle&gt;</CODE> (the type of the objects returned by <BR><CODE>position.latitude</CODE> and <CODE>position.longtude</CODE>). We define such a method in <BR><A HREF="DB_98.HTM#MARKER-9-269">Section 7.6</A>.</P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Modularity note:</B> The preceding <CODE>say</CODE> method does not take advantage of the similarity between latitude and longitude. One clue that there is a modularity problem is that the two calls to <CODE>format-out</CODE> are nearly identical. </P>
</TD></TR></TABLE><P> </P>
<P> </P>
<P> The <CODE>say</CODE> method on <CODE>&lt;absolute-position&gt;</CODE> should not call <CODE>format-out</CODE> directly on the two instances of <CODE>&lt;directed-angle&gt;</CODE> stored in the latitude and longitude slots. Instead, we can define a <CODE>say</CODE> method on <CODE>&lt;directed-angle&gt;</CODE>, and can call it in the method on <CODE>&lt;absolute-position&gt;</CODE>:</P>
<P> </P>
<PRE>
<A NAME=MARKER-9-268></A>define method say (angle :: &lt;directed-angle&gt;) =&gt; ()
  let(degrees, minutes, seconds) = decode-total-seconds(angle);
  format-out(&quot;%d degrees %d minutes %d seconds %s&quot;,
             degrees, minutes, seconds, angle.direction);
end method say; 
define method say (position :: &lt;absolute-position&gt;) =&gt; ()
  say(position.latitude);
  format-out(&quot; latitude\n&quot;);
  say(position.longitude);
  format-out(&quot; longitude\n&quot;);
end method say;
</PRE>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Modularity note:</B> Our modularity is improved, now that the <CODE>&lt;directed-angle&gt;</CODE> class is responsible for describing its instances. This division of labor reduces duplication of code. </P>
<P>There is still a problem with this approach, because the <CODE>say</CODE> method on <CODE>&lt;absolute-position&gt;</CODE> must print "latitude" and "longitude" after calling <CODE>say</CODE> on the directed angles stored in its two slots. The modularity is still flawed, because the method on <CODE>&lt;absolute-position&gt;</CODE> acts on the knowledge that the method on <CODE>&lt;directed-angle&gt;</CODE> does not print "latitude" or "longitude." </P>
</TD></TR></TABLE><P> </P>
<P> </P>
<P> </P>
<P> We defined the <CODE>&lt;directed-angle&gt;</CODE> class to represent what latitude and longitude have in common. It is useful to recognize that latitude and longitude have differences as well as similarities. We represented latitude and longitude by the names of slots in <CODE>&lt;absolute-position&gt;</CODE>, and their implementations as instances of <CODE>&lt;directed-angle&gt;</CODE>. We can elevate the visibility of latitude and longitude by providing classes that represent each of them:</P>
<PRE>
define class &lt;latitude&gt; (&lt;directed-angle&gt;)
end class &lt;latitude&gt;;
define class &lt;longitude&gt; (&lt;directed-angle&gt;)
end class &lt;longitude&gt;;
</PRE>
<P> We redefine <CODE>&lt;absolute-position&gt;</CODE> to use <CODE>&lt;latitude&gt;</CODE> and <CODE>&lt;longitude&gt;</CODE>:</P>
<PRE>
define class &lt;absolute-position&gt; (&lt;position&gt;)
  slot latitude :: &lt;latitude&gt;, init-keyword: latitude:;
  slot longitude :: &lt;longitude&gt;, init-keyword: longitude:;
end class &lt;absolute-position&gt;;
</PRE>
<P> </P>
<TABLE BORDER=1><CAPTION><P>Figure 7.1   Inheritance <A NAME=MARKER-9-261></A>relationships among the position and angle classes. Abstract classes are shown in <EM>oblique</EM> <EM>typewriter</EM> <EM>font.</EM></P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB96IM13.GIF></P>
</TD></TR></TABLE><P> </P>
<P> </P>
<P> <A HREF="#MARKER-9-261">Figure 7.1</A> shows the inheritance relationships among the position and angle classes.</P>
<P>We define these new <CODE>say</CODE> methods:</P>
<PRE>
define method say (latitude :: &lt;latitude&gt;) =&gt; ()
  next-method();
  format-out(&quot; latitude\n&quot;);
end method say;
define method say (longitude :: &lt;longitude&gt;) =&gt; ()
  next-method();
  format-out(&quot; longitude\n&quot;);
end method say;
</PRE>
<P> </P>
<P> The calls to <CODE>next-method</CODE> in the methods on <CODE>&lt;latitude&gt;</CODE> and <CODE>&lt;longitude&gt;</CODE> will call the method on <CODE>&lt;directed-angle&gt;</CODE>, shown on page <A HREF="#MARKER-9-267"></A><A HREF="#MARKER-9-268">87</A><A HREF="#MARKER-9-268"></A>.</P>
<P>We redefine the <CODE>say</CODE> method on <CODE>&lt;absolute-position&gt;</CODE>:</P>
<P> </P>
<PRE>
define method say (position :: &lt;absolute-position&gt;) =&gt; ()
  say(position.latitude);
  say(position.longitude);
end method say;
</PRE>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Modularity note:</B> The approach of defining the classes <BR><CODE>&lt;latitude&gt;</CODE> and <CODE>&lt;longitude&gt;</CODE> provides the following benefits:</P>
<UL>
<LI><P>Each class is responsible for describing its instances. Each method depends on <CODE>say</CODE> working for all the classes. No method on one class must understand the details of a method on another class. </P>
<LI><P>We guard against any attempt to store a latitude in a slot designated for a longitude, and vice versa. This type checking will be useful when we introduce more differences between the classes. For example, the direction of a latitude is north or south, and the direction of a longitude is west or east. We can provide methods that ensure that the directions stored in a <CODE>&lt;latitude&gt;</CODE> instance are appropriate for latitude -- and we can do the same for longitude. We show two techniques for implementing that type checking: See <A HREF="DB_134.HTM#MARKER-9-352">Section 10.6, page 128</A>, and <A HREF="DB_300.HTM#MARKER-9-773">Section 19.5, page 318</A>.</P>
<LI><P>You can ask an object what its class is by using the <CODE>object-class</CODE> function. In this case, you can find out that an object is a latitude or longitude, rather than just a directed angle. The data does not stand alone; it is an instance that carries with it its type, its identity, and the methods appropriate to it. </P>
</TD></TR></TABLE></UL>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_97.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_95.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

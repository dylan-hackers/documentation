<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_63.HTM">
<LINK REL=PREV HREF="DB_81.HTM">
<LINK REL=NEXT HREF="DB_83.HTM">
<TITLE>5.8   The time library (so far)</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING82></A>

<DIV>
<P><A HREF="DB_83.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_81.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING82-0></A>
<H1>5.8   The time library (so far)</H1>
<P> In the course of introducing methods, classes, and generic functions, we have created elements of a library dealing with two kinds of time. Now, we construct a simple library containing those elements (we will continue to develop the time library throughout this book). We represent the time library in four files: a LID file, a library file, a library implementation file, and a test file. We could have expressed this library in three files, by combining into a single file the library implementation file and the test file, but we decided that it would be clearer to separate the underlying implementation (the definitions of classes, methods, and generic functions) from the test (where we create instances and call <CODE>say</CODE> on them).</P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The LID file: <CODE>time.lid</CODE>.</P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
library: time
files:   library
         library-implementation
         test
</TD></TR></TABLE></PRE>
<P> </P>
<P> The library file defines the <CODE>time</CODE> library and the <CODE>time</CODE> module.</P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The library file: <CODE>library.dylan</CODE>. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
module: dylan-user
define library time
  use dylan; 
  use format-out;
end library time;
define module time
  use dylan;
  use format-out;
end module time;
</TD></TR></TABLE></PRE>
<P> </P>
<P> The library implementation file defines the classes, methods, and generic <BR>functions.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The implementation file: <CODE>library-implementation.dylan</CODE>. </P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
module: time
<I>// Class definitions</I>
define class &lt;time&gt; (&lt;object&gt;)
  slot total-seconds :: &lt;integer&gt;, init-keyword: total-seconds:;
end class &lt;time&gt;; 
<I>// A specific time of day from 00:00 (midnight) to before 24:00 (tomorrow)
</I>define class &lt;time-of-day&gt; (&lt;time&gt;)
end class &lt;time-of-day&gt;;
</TD></TR><TR VALIGN=TOP><TD><I>// A relative time between -24:00 and +24:00
</I>define class &lt;time-offset&gt; (&lt;time&gt;)
end class &lt;time-offset&gt;;
</TD></TR><TR VALIGN=TOP><TD><I>// Method for determining whether a time offset is in the past
</I>define method past? (time :: &lt;time-offset&gt;) =&gt; (past? :: &lt;boolean&gt;)
  time.total-seconds &lt; 0;
end method past?;
</TD></TR><TR VALIGN=TOP><TD><I>// Methods for encoding and decoding total seconds</I>
define method encode-total-seconds
    (hours :: &lt;integer&gt;, minutes :: &lt;integer&gt;, seconds :: &lt;integer&gt;)
 =&gt; (total-seconds :: &lt;integer&gt;)
  ((hours * 60) + minutes) * 60 + seconds;
end method encode-total-seconds;
</TD></TR><TR VALIGN=TOP><TD>define method decode-total-seconds 
    (time :: &lt;time&gt;)
 =&gt; (hours :: &lt;integer&gt;, minutes :: &lt;integer&gt;, seconds :: &lt;integer&gt;)
  decode-total-seconds(abs(time.total-seconds));
end method decode-total-seconds;
</TD></TR><TR VALIGN=TOP><TD>define method decode-total-seconds
    (total-seconds :: &lt;integer&gt;)
 =&gt; (hours :: &lt;integer&gt;, minutes :: &lt;integer&gt;, seconds :: &lt;integer&gt;)<I>	</I>  let(total-minutes, seconds) = truncate/(total-seconds, 60);
  let(hours, minutes) = truncate/(total-minutes, 60);
  values(hours, minutes, seconds);
end method decode-total-seconds;
</TD></TR><TR VALIGN=TOP><TD><I>// The say generic function and its methods</I>
<I>// Given an object, print a description of the object
</I>define generic say (any-object :: &lt;object&gt;) =&gt; ();
define method say (time :: &lt;time&gt;) =&gt; ()
  let (hours, minutes) = decode-total-seconds(time); 
  format-out
    (&quot;%d:%s%d&quot;, hours, if (minutes &lt; 10) &quot;0&quot; else &quot;&quot; end, minutes);
end method say;
define method say (time :: &lt;time-offset&gt;)
  format-out(&quot;%s &quot;, if (past?(time)) &quot;minus&quot; else &quot;plus&quot; end);
  next-method();
end method say; 
</TD></TR></TABLE></PRE>
<P> </P>
<P> The test file creates instances and calls <CODE>say</CODE> on the instances. The test file can access variables defined in the implementation file, because both files are in the <CODE>time</CODE> module. </P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TH><P> The test file: <CODE>test.dylan</CODE>.</P>
</TH></TR><TR VALIGN=TOP><TD><PRE>
module: time
define variable *my-time-offset* :: &lt;time-offset&gt; 
  = make(&lt;time-offset&gt;, total-seconds: encode-total-seconds(15, 20, 10));
define variable *your-time-offset* :: &lt;time-offset&gt; 
  = make(&lt;time-offset&gt;, total-seconds: - encode-total-seconds(6, 45, 30));
define variable *my-time-of-day* 
  = make(&lt;time-of-day&gt;, total-seconds: encode-total-seconds(0, 2, 0)); 
define variable *your-time-of-day* 
  = make(&lt;time-of-day&gt;, total-seconds: encode-total-seconds(8, 30, 59));
say(*my-time-offset*);
say(*your-time-offset*);
say(*my-time-of-day*);
say(*your-time-of-day*);
</TD></TR></TABLE></PRE>
<P> When we run the <CODE>test.dylan</CODE> file, Dylan creates two instances of <CODE>&lt;time-offset&gt;</CODE> and two instances of <CODE>&lt;time-of-day&gt;</CODE>. It calls <CODE>say</CODE> on all four instances. The output of the test is</P>
<PRE>
<I>plus 15:20
minus 6:45
0:02
8:30</I>
</PRE>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_83.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_81.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_295.HTM">
<LINK REL=PREV HREF="DB_302.HTM">
<LINK REL=NEXT HREF="DB_304.HTM">
<TITLE>19.8   Typed generic functions</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING303></A>

<DIV>
<P><A HREF="DB_304.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_302.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING303-0></A>
<H1>19.8   Typ<A NAME=MARKER-2-780></A>ed generic functions</H1>
<P> In addition to specifying the types of the parameters and return values of methods, you can specify the types of the parameters and return values of a generic function. You usually restrict the parameter types of a generic function to establish the <B>contract</B> of the generic function -- that is, to define the domain of arguments that the generic function is intended to handle, and the domain of the values that it will return.</P>
<P>If we define a method without also defining a generic function, Dylan creates an <A NAME=MARKER-2-781></A>implicit generic function with the most general types for each parameter and return value that are compatible with the method. For example, assume that we defined a method for <CODE>next-landing-step</CODE>, and did not explicitly create a generic function for it. The method is as follows:</P>
<PRE>
define method next-landing-step
    (storage :: &lt;sky&gt;, aircraft :: &lt;aircraft&gt;)
 =&gt; (next-class :: false-or(&lt;class&gt;), duration :: false-or(&lt;time-offset&gt;))
  ...
  end if;
end method next-landing-step; 
</PRE>
<P> When we define a method without also defining a generic function, the compiler will generate an implicit generic function for us, which, in this case, will be as though we had defined the generic function like this:</P>
<PRE>
<I>define generic next-landing-step (o1 :: &lt;object&gt;, o2 :: &lt;object&gt;)
 =&gt; (#rest r :: &lt;object&gt;);</I>
</PRE>
<P> In <A HREF="DB_268.HTM#MARKER-9-711">Section 17.4, page 267</A>, where we did define a generic function, we used a simple definition, just documenting the number of arguments, and giving them mnemonic names:</P>
<PRE>
define generic next-landing-step (container, vehicle);
</PRE>
<P> Because we did not specify types of the arguments or return values, they default to <CODE>&lt;object&gt;</CODE>, just as they did in the preceding implicit generic function. </P>
<P>Although the generic function that we wrote does prevent us from defining methods with the wrong number of arguments, it does not constrain the types of those arguments or the format or type of return values in any way. A sophisticated compiler may be able to make inferences based on the methods that we define, but we could both aid the compiler and more clearly document the protocol of <CODE>next-landing-step</CODE> by specifying the types of the parameters and return values in the definition of the generic function:</P>
<PRE>
define generic next-landing-step
    (storage :: &lt;vehicle-storage&gt;, aircraft :: &lt;aircraft&gt;)
 =&gt; (next-storage :: &lt;vehicle-storage&gt;, elapsed-time :: &lt;time-offset&gt;);
</PRE>
<P> Now, the compiler can help us. If we define a method whose arguments are not a subclass of <CODE>&lt;vehicle-storage&gt;</CODE> and a subclass of <CODE>&lt;aircraft&gt;</CODE> (for example, if we provided the arguments in the wrong order), the compiler will report the error. Furthermore, the compiler can use the value declaration to detect errors in the return values (for example, if we returned only a single value or returned a value of the wrong type). Finally, the compiler can be asked to issue a warning if there is a subclass of the argument types for which no method is applicable.</P>
<P>In addition to establishing a contract, specifying the types of the parameters and return values of generic functions can allow the compiler to make additional inferences, as described in <A HREF="DB_298.HTM#MARKER-9-767">Section 19.3</A> with regard to <CODE>truncate/</CODE>. In the absence of other information, the compiler is limited in the optimizations that it can make based solely on the parameter types in the generic function, so it is generally best not to restrict artificially the types of a generic function, but rather to use the restricted types to document the generic function's protocol.</P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_304.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_302.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

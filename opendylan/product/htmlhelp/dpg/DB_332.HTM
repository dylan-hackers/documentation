<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_329.HTM">
<LINK REL=PREV HREF="DB_331.HTM">
<LINK REL=NEXT HREF="DB_333.HTM">
<TITLE>21.3   Evaluation in macros</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING332></A>

<DIV>
<P><A HREF="DB_333.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_331.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING332-0></A>
<H1>21.3   Evaluation in <A NAME=MARKER-2-873></A>macros</H1>
<P> Dylan's template macros do no evaluation. In particular, the pattern variables of a macro are unlike function parameters. They name fragments of code, rather than naming the result of the evaluation of a fragment of code. </P>
<P>If we were trying to write an operation like C's <CODE>||</CODE> (one that would evaluate expressions and would return the value of the first nonzero expression without evaluating any subsequent expressions), we could not write it as a function:</P>
<PRE>
define method or-int (arg1, arg2) if (arg1 ~= 0) arg1 else arg2 end end;
</PRE>
<P> When a function is invoked, all its arguments are evaluated first, which defeats our purpose. If we model our macro on our function idea, however, we will not get the ideal result either:</P>
<PRE>
define macro or-int
  { or-int (?arg1:expression, ?arg2:expression) } =&gt; 
    { if (?arg1 ~= 0) ?arg1 else ?arg2 end }
end macro or-int;
</PRE>
<P> The expansion of <CODE>or-int (x := x + 1, y := y - 1)</CODE> is probably not what we want:</P>
<PRE>
<EM>if (<CODE>x := x + 1 ~= 0) x := x + 1 else y := y - 1 end</CODE></EM>
</PRE>
<P> We see a common macro error -- the expression <CODE>x := x + 1</CODE> will be evaluated twice when the resulting substitution is evaluated, leaving <CODE>x</CODE> with an incorrect (or at least unexpected) value. There is no magic technique for avoiding this error -- you just have to be careful about repeating a pattern variable in a template. Most often, if you are repeating a pattern variable, you should be using a local variable instead, so that the fragment that the pattern represents is evaluated only once:</P>
<PRE>
define macro or-int
  { or-int (?arg1:expression, ?arg2:expression) }
 =&gt; {
      let arg1 = ?arg1;
      if(arg1 ~= 0) arg1 else ?arg2 end
    }
end macro or-int;
</PRE>
<P> Another potential pitfall arises if the pattern variables appear in an order in the template different from the one in which they appear in the pattern. In this case, unexpected results can occur if a side effect in one fragment affects the meaning of other fragments. In this case, you would again want to use local variables to ensure that the fragments were evaluated in their natural order. </P>
<P>These rules are not hard and fast: The power of macros is due in a large part to the ability of macros to manipulate code fragments without evaluating those fragments, but that power must be used judiciously. If you are designing macros for use by other people, those people may expect functionlike behavior, and may be surprised if there are multiple or out-of-order evaluations of macro parameters.</P>
<P> </P>
<TABLE BORDER=1><TR VALIGN=TOP><TD><P> <B>Comparison with <A NAME=MARKER-2-853></A>C:</B> Because it is more difficult to introduce local variables in C macros than it is in Dylan macros, most C programmers simply adopt the discipline of never using an expression with side effects as an argument to a macro. The problem of multiple or out-of-order evaluations of macro parameters is inherent in all macro systems, although some macro systems make it easier to handle.</P>
</TD></TR></TABLE>
</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_333.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_331.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

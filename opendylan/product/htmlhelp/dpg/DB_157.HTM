<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<!-- Generated by Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental) -->
<HEAD>
<LINK REL=TOP HREF="DB_1.HTM">
<LINK REL=UP HREF="DB_155.HTM">
<LINK REL=PREV HREF="DB_156.HTM">
<LINK REL=NEXT HREF="DB_158.HTM">
<TITLE>11.4.2   Destructive operations and shared structure</TITLE>
<META NAME=GENERATOR CONTENT="Harlequin WebMaker 3.0.2 ( 8-May-1997 experimental)">
</HEAD>
<BODY BGCOLOR="#FFFFFF">

<DIV>
<A NAME=HEADING157></A>

<DIV>
<P><A HREF="DB_158.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_156.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>

</DIV>
<A NAME=HEADING157-0></A>
<H1>11.4.2   <A NAME=MARKER-9-422></A>Destructive operations and shared structure</H1>
<P> Consider the following example, and Figures <A HREF="#MARKER-9-370">11.4</A> and <A HREF="#MARKER-9-371">11.5</A>.</P>
<PRE>
<I>// Firste we construct a vector of two vectors
?</I> define variable *switch-states* 
    = vector(vector(&quot;switch&quot;, &quot;on&quot;), vector(&quot;switch&quot;, &quot;off&quot;));
<I>?</I> *switch-states*;
<I>#[#[&quot;switch&quot;, &quot;on&quot;], #[&quot;switch&quot;, &quot;off&quot;]]</I>
<I>// Now, we reverse the vector, holding on to the result
?</I> define variable *rev-switch-states* = my-reverse(*switch-states*);
</PRE>
<P> At this point, the states of the variables and vectors correspond to <A HREF="#MARKER-9-370">Figure 11.4</A>.</P>
<P>We examine the two sequences:</P>
<PRE>
<I>?</I> *rev-switch-states*;
<I>#[#[&quot;switch&quot;, &quot;off&quot;], #[&quot;switch&quot;, &quot;on&quot;]]</I>
<I>// Although *switch-states* and *rev-switch-states* are different vectors,
// they share elements
?</I> *switch-states* == *rev-switch-states*;
<I>#f</I>
</PRE>
<P> </P>
<TABLE BORDER=1><CAPTION><P>Figure 11.4   State <A NAME=MARKER-9-370></A>before the element is changed.</P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB15IM19.GIF></P>
</TD></TR></TABLE><P> Now, we change an element:</P>
<PRE>
<I>?</I> *switch-states*[0] == *rev-switch-states*[1];
<I>#t</I>
<I>// So, when we change an element in one, the same change occurs in the other
?</I> (*switch-states*[0])[0] := &quot;master switch&quot;;
<I>&quot;master switch&quot;</I>
</PRE>
<P> At this point, the states of the variables and vectors correspond to <A HREF="#MARKER-9-371">Figure 11.5</A>. </P>
<TABLE BORDER=1><CAPTION><P>Figure 11.5   <A NAME=MARKER-9-371></A>State after the element is changed.</P>
</CAPTION><TR VALIGN=TOP><TD><P> <IMG ALIGN=TOP SRC=DB15IM20.GIF></P>
</TD></TR></TABLE><P> We can look at the values of the variables:</P>
<PRE>
<I>?</I> *switch-states*;
<I>#[#[&quot;master switch&quot;, &quot;on&quot;], #[&quot;switch&quot;, &quot;off&quot;]]</I>
<I>?</I> *rev-switch-states*;
<I>#[#[&quot;switch&quot;, &quot;off&quot;], #[&quot;master switch&quot;, &quot;on&quot;]]</I>
</PRE>
<P> Each object pictured in Figures <A HREF="#MARKER-9-370">11.4</A> and <A HREF="#MARKER-9-371">11.5</A> is a vector. The strings in the figures are vectors, although we did not draw them as such, to keep the diagrams relatively simple. Variables are not objects in Dylan, but they are shown referring to objects. In <A HREF="#MARKER-9-371">Figure 11.5</A>, the string <CODE>&quot;switch&quot;</CODE> is not referenced by any other object and is therefore garbage; eventually, it will be reclaimed by a garbage collector.</P>
<P>Changing an element of one collection can affect another collection if the two collections share elements. Two collections share an element if there is a value in one collection that is <CODE>==</CODE> (that is, identical) to a value in the other collection. Functions such as <CODE>copy-sequence</CODE> and <CODE>reverse</CODE> do only a <B>shallow copy</B> of their arguments: only the top level of the copy is new. Every other part is shared with the old sequence. Thus, it is important to take care when you modify objects that might be shared with other parts of your application. Using well-defined module boundaries that specify whether data structures can be modified by clients of the module can help you to keep application data consistent. </P>

</DIV>

<DIV>

<DIV>

<!-- TOC -->

</DIV>

<HR>
<ADDRESS>Dylan Programming - 9 Apr 1999</ADDRESS>
<P><A HREF="DB_158.HTM"><IMG ALIGN=BOTTOM SRC=next.gif ALT=Next BORDER=0></A> <A HREF="DB_156.HTM"><IMG ALIGN=BOTTOM SRC=prev.gif ALT=Previous BORDER=0></A> <A HREF="DB_1.HTM"><IMG ALIGN=BOTTOM SRC=top.gif ALT=Top BORDER=0></A> <A HREF="DB_2.HTM"><IMG ALIGN=BOTTOM SRC=content.gif ALT=Contents BORDER=0></A> <A HREF="DB_349.HTM"><IMG ALIGN=BOTTOM SRC=index.gif ALT=Index BORDER=0></A></P>
<P>N Feinberg/S E Keene/R Mathews/P Tucker Withington, DYLAN PROGRAMMING, (c) 1997 Harlequin Inc. Reproduced by permission of Addison-Wesley Longman Publishing Company, Inc.  All rights reserved. No further copying, downloading or transmitting of this material is allowed without the prior written permission of the publisher.</P>

</DIV>
</BODY>
</HTML>

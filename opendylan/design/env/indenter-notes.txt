-*- Outline -*-

* 1996/07/19: Basic pseudocode for CMU's Dylan indenter (Emacs mode)

-- Context: ----------------------------------------------------------
iic === indent-if-continuation
point == point() (emacs' cursor position)
dylan-ind := 2
----------------------------------------------------------------------

defun dylan-indent-line (&opt ignore-case, extra-ind) {

Move to start of line
block-ind := /* indentation of preceding keyword */
	/* Move to beginning of innermost enclosing (compound|()s) */
	dylan-find-keyword() ; if fail, := nil
	If it's "(method|function)" and
	   line to here contains "define ( \w)* " Then
		Move back to the "define"
	was-paren := t, if looking at any paren /* ("([{") */
	in-case := t, if looking at "(select|case)"
	/* Find beginning of first statement in the compound starting here */
	body-start := find-body-start(...)
	(current-column + extra-ind)
Return to former position, if point moved back to find a keyword
indent := /* numerous cases :-( */
	Case
	/* No containing keyword =>? must be top-level statement */
	block-ind == nil:
		iic(";",point,0)
	/* Separators: */
	/* ("finally" "exception" "cleanup" "else" "elseif") */
	looking-at separator-word: /* separator-word-pattern */
		block-ind
	/* "end..." keywords: */
	/* end[ \t]*("interface" "module" "library" "macro" "method"
	** "class" "function" "if" "block" "begin" "method" "case" "for"
	** "select" "when" "unless" "until" "while")? */
	looking-at end-keyword: /* dyl-end-keyword-pattern */
		block-ind
	/* "select" or "case" statements */
	in-case:	
		Case
		/* On a blank line, indent more if apparently a "consequent" */
		looking-at <blank line>:
			If previous "statement" ends in ";|=>" Then
				+(block-ind, 2*dylan-ind,
				  iic(",",point,body-start,t))
			Else
				+(block-ind, dylan-ind,
				  iic(",",point,body-start,t))
		/* On non-blank, indent less if apparently in "matches" ... */
		next "statement" ends in ",|=>":
			+(block-ind, dylan-ind,   iic(",",point,body-start,t))
		/* ... or indent more if not in "matches", i.e. in "conseqs" */
		Else:
			+(block-ind, 2*dylan-ind, iic(",",point,body-start,t))
	/* Parenthesized, comma-separated expressions: */
	was-paren:
		+(block-ind, 1,         iic(",",point,body-start))
	/* Just statements (separated by ';'): [similar to top-level stmts] */
	/* [But, what other enclosing keywords are left?
	**  ("['\"]" "define" "define \w* [<the usual>]" )
	**  Maybe also ("constant" "variable" "generic") ?
	**  I think that's all, but I'm not sure.] */
	Else:
		+(block-ind, dylan-ind, iic(";",point,body-start))
Indent to column (indent)
/* Then follows misc. other tidying, in real life. */

}


defun iic (term-char, line-start, block-start, &opt in-case, in-paren)) {

Move to line-start
arrow := (dylan-outdent-arrows AND looking-at "=>")
dylan-skip-whitespace-backward() /* Move to just after prev non-ws */
If line to here contains "finally" Then	return 0

real-start := point
backward-dylan-statement(in-case)
dylan-skip-whitespace-forward()
return Case
/* special case for beginning of file [but what case(s) does it cover?] */
block-start == 0 AND NOT looking-at "define":
	0
/* ??? */
real-start == block-start:
	0
/* ??? */
point < block-start:
	dylan-indent + ((arrow AND NOT in-case) ? -3 : 0)
/* ??? */
{(forward-dylan-statement in-case (equal term-char ";")) point} < line-start:
	0
/* Give continuations of generic functions extra indentation to match
// what happens with method declarations.  This is an odd special case,
// but some folks like it.  If you don't, comment out the next [2] lines.
// */
looking-at "define \w* generic":
	2*dylan-indent + (arrow ? -3 : 0)
Else:
	dylan-indent

}

----------------------------------------------------------------------

* 1996/07/23: Attempt to summarize and simplify the above
(Ignoring line continuations for now).

dylan-indent-line {
  block-ind := indentation of innermost enclosing compound (or "nil" if none);
/*body-start := position of first "statement" within that compound;*for iic*/
  indent := case
    /* at file's top level */
    block-ind == nil: 0
    /* words like "else", "elseif", "finally" */
    looking-at intermediate-word: block-ind
    /* the pattern "end XXX", where "XXX" is defined to be allowed */
    looking-at end-pattern: block-ind
    /* case or select */
    enclosing compound is "case" or "select": case
      /* for a blank line, look at previous code and guess */
      looking-at blank-line:
        if previous "statement" ends in ";|=>" then
          /* it's likely this line will be a consequent */
          block-ind + 2*dylan-ind
        else
          /* it's likely this line will be a match (or just "=>") */
          block-ind + dylan-ind
        end if
      next statement ends in ",|=>":
        /* it seems this line is a match */
        block-ind + dylan-ind
      otherwise:
        /* it seems this line is a consequent (or just "=>") */
        block-ind + 2*dylan-ind
    end case;
    /* parenthesis, "[({" */
    enclosing compund is one of "[({":
      block-ind + 1
    /* other statements, including: other keywords, function calls, exprs */
      block-ind + dylan-ind
  end case;
}

----------------------------------------------------------------------

* 1996/07/23: Issues to think about

** 01: What different classes of keywords or compunds have to be covered?
(Maybe not the same as in the full grammar.)
** 02: How will different classes be declared and/or recognised?
** 03: How can we skip over strings and parenthesised compounds?
** 04: How can we allow the indenter to recognise user-defined macros?
They should be treated as the user desires, within the limits of the
facilities the indenter provides.  Maybe give "templates" in a
separate file, or in comments (and maybe use the same mechanism,
internally, to describe built-in classes).

----------------------------------------------------------------------

* 1996/07/23: Specification language for indentable items

** Grammar (REs)
~~~~~~~~~~~~~~~~

[Terminals are separated by whitespace, i.e. "[ \t\n]*".]

item:	{ /start/ [ /offset2/ ]
	  { [ /inter'/+ /inter/ ] }
	  /end/ [ /offset1/ ] }

start:	/string/

inter': /inter/ ;

inter:	/string/ /offset1/ [/offset2/]

end:	/string/

string:	A string, representing a "regular expression".
The REs allowed are: single characters, character ranges (and negated
ranges), "." (i.e., any character except "\n"), "*" (0 or more), "+"
(1 or more), grouping ("\(" and "\)", but no numbered "\1", "\2" etc.
to refer back to groups, as in Emacs), disjunction ("\|"), initial "^"
(i.e., start-of-line) and final "$" (i.e., end-of-line).

offset:	A string matching the RE "\(%dD\)?%d", where %d means "an integer".
(The -1 and -2 suffices are not really syntactic; they're related to
the meaning described below: -1 means "indentation of this line" and
-2 means "indentation of following lines".)

** Meaning
~~~~~~~~~~

An /offset/ of the form "nDm" has as its meaning the number ((n * D) +
m), where D is a user-definable constant (default 2).  For example,
"2D" == 4, "2D-3" == 1, "1" == 1 (assuming D == 2).

The /start/ and /end/ give REs which delimit the item.  The /start/ RE
will be indented according to the item's place within its containing
item.  (See below for the indentation of /end/.)  If it has no
containing item, it will be indented to the first column (or, indented
in line with the preceding item, if any?)

The optional /offset2/ for /start/ specifies the indentation of all
statements within the body (i.e., after /start/ and before /end/)
which do not match any of the /inter/s (except where overridden by an
/offset2/ value for some /inter/), relative to the indentation of
/start/.  If ommitted, it defaults to +D.

The /inter/s' /string/s give REs matching other patterns which are
part of the internal structure of the item (e.g. function arguments,
"else", "=>").  If any RE matches the start of a line (ignoring
leading whitesapce -- see Notes below) then its corresponding
/offset/s apply.  If more than one RE matches, the choice of which to
"use" is undefined (but one should be used).

The corresponding /offset1/s give the indentation of that RE relative
to the indentation of /start/.  The corresponding optional /offset2/s
give the indentation of all statements (within the body) after that RE
(similarly relative).  This overrides the /offset2/ given with
/start/, UNTIL after another /inter/ (whose /offset2/ will take over).
If no such offset is present, the /start/ /offset2/, or the overall
default, takes over.

The optional /offset1/ for /end/ specifies the indentation of the
/end/ RE itself, again relative to the /start/.  If ommitted, it
defaults to 0 (i.e. aligned with the start).

Notes:

No provision is yet made for line continuation and none will likely
ever be made (in this system) for clever extra indentation, as CMU's
dylan-mode allows.  (For example, double-indenting method parameters
if they occur on their own line, or lining up the paren in "=> (" with
the parameters list for return-values lists.)  However, it should be
possible to extend the item definitions (dynamically) to allow for
user-defined macro structures to be recognised (which CMU's doesn't
allow).

All REs are assumed to begin and end on word boundaries (as defined by
Dylan's lexical syntax) and, EXCEPT for /end/, must match at the start
of the line (ignoring any leading whitespace and comments) on the
first line of the match (as if they began with "^ *").  The /end/ REs
may occur at places other than the start of lines, but their
indentation offset will only be applied if they start a line [!!!
change algorithm to ensure this !!!].  (In this case, no extra
whitespace is added to the RE, but word boundaries are still assumed.)

The default offsets mentioned above should be filled in to the data
structures derived from the specifications when they are created, as
the algorithms below assume the offsets may simply be read from these
structures.

Nested /item/s are allowed.  If any other /item/'s /start/ is found
after/before one of this /item/'s /string/s, all searches etc. will
skip forward/back until the corresponding /end/ has been passed.

For simplicity, the /inter/ patterns are allowed to occur in any
order, any number of times, between /start/ and /end/.  (This may not
match the grammar of Dylan but I'm assuming it would be easier to
handle.)

Maybe: allow /end/ to default to ";"?

Maybe: have \i (or something) in REs mean "any item"? (Except this
means they're not REs any more.)

Maybe: have " " in REs mean "[ \t\n]" (also skipping comments
automatically)?

** Examples
~~~~~~~~~~~
Notes:
- "/*...*/" comments are here for explanation; they're not really allowed.
- "\w" means "a word character" (including '-' in Dylan).
- "\i" means "a whole item". [1996/09/26: avoid this - it breaks RE-ness]
- "." means "any character except newline".
- Revised 1996/07/25 to try to cover all basic constructs, to help me
see how to deal with 1-liners (and spot any other exceptional cases).
- We want REs matched to the longest possible match in all cases.

- Self-note: for Dylan grammar, see ~dylan/lib/infix-reader/grammar.dylgram

/*
// Useful note? : Overall, we can only use as start/end REs, patterns
// which do not match parts of any structures without start/ends,
// which might occur within or "beside" the item we're defining.
// For example, expressions at top level may be followed by ";", so
// this cannot be used as a start/end for any top-level items.
/*/

Strings:
/* Naive version: won't deal with '\"' in strings. */
{ "\"" "0" { } "\"" }
/* Next version deals with '\"', '\\"', '\\\"' etc. correctly. */
/* '\`' is an Emacs regexp character: "blank except start-of-buffer" */
{ "\(\`\|[^\\]\)\(\\\\\)*\"" "0" { } "\(\`\|[^\\]\)\(\\\\\)*\"" }

Parenthesised expressions:
{ "#?[[({]" "1" { } "[])}]" "1" }
/* Do I also need a "non-naive" version to deal with escaped ()s? */

Definitions:
  macro definition:
{ "define +macro" { } "end" }
  macro call:
    with "body-word"s:
{ "define +\(\w+ +\)*class" { } "end" }
{ "define +\(\w+ +\)*library" { } "end" }
{ "define +\(\w+ +\)*method" { } "end" }
{ "define +\(\w+ +\)*module" { } "end" }
/* Next line for "local"s; indent will break if "method" omitted. */
{ "method" { } "end" }
    with "list-word"s:
/* constant, variable, generic, domain */
/* All "1-liners", so have to rely on line continuation. */

Local declarations:
/* let, let handler, local */
/* All "1-liners", so have to rely on line continuation. */

Body fragments/statement:
  statement:
{ "begin" { } "end" }
{ "block" {
    "afterwards" "0" "D"
    "cleanup" "0" "D"
    "exception" "0" "D"
  } "end"
}
{ "case" {
    ".*, *$" "D" "D" ;		/* matches */
    ".*\n=>" "D" "2D" ;		/* (final) matches */
    "=>" "2D" "2D" ;		/* consequents */
    "otherwise" "D" "2D"	/* "otherwise" may occur without "=>" */
  } "end"
}
{ "for" {
    "finally" "0" "D"
  } "end"
}
{ "if" {
    "elseif" "0" "D" ;
    "else" "0" "D"
  } "end"
}
{ "select" {
    ".*, *$" "D" "D" ;		/* matches */
    ".*\n=>" "D" "2D" ;		/* (final) matches */
    "=>" "2D" "2D" ;		/* consequents */
    "otherwise" "D" "2D"	/* "otherwise" may occur without "=>" */
  } "end"
}
{ "unless" { } "end" }
{ "until" { } "end" }
{ "while" { } "end" }
    
/* "Overloaded uses of while and until"??? */

/* Everything else is covered by other items, e.g. "()". */

** Issues
~~~~~~~~~

*** 05: swm reckons REs may be too slow in anything other than Emacs.
However, of the other editors I've seen which are powerful enough to
allow programmable indenting (i.e., only Codewright), it might well be
fast enough.  In any case, it seems possible we might only need a
subset of general REs and make things simpler that way.

----------------------------------------------------------------------

* 1996/07/24: Algorithms for indentation

Two algorithms are needed: one for indentation overall; another to
search for matches for some one of the (special) REs, EFFICIENTLY.

** Notes

Functions beginning with E_ are imagined primitives provided by the
"editor".  See the "External" section below for details.

Line continuation is not dealt with, for now, but might be with the
following idea.  If the this line is not a /start/, /inter/ or /end/
and the previous line is not an /inter/ or /end/ for the enclosing
item, then do "continuation indentation" if the previous line does not
end with this item's "line-end RE" [not yet in the spec] (ignoring
trailing whitespace/comments).

** External functions/values (to be provided by an "editor")

It is assumed that the following functions and values are provided by
an underlying "editor API" which manipulates a "buffer" of text.
Subsections of this text can be represented as <string>s and
individual characters positions can be identified by <pos>s
(non-negative integers).

If the underlying editor does not provide these functions, some extra
implementation work may be needed, or an adaptation of the algorithm
may be enough.

If pos lies outwith the buffer in any of these function calls, an
error condition should be signalled.


E_column(pos :: <pos>) => column :: <nat-number>;
INPUTS:
  pos, a character position within a buffer.
OUTPUTS:
  column, the column of pos (i.e., its position relative to the start
of its line, the first column being 0).


E_delete-horizontal-space(pos :: <pos>);
INPUTS:
  pos, a character position within a buffer.
OUTPUTS:
  None.

The buffer is modified directly, removing all spaces and tabs before
and after pos, until the first non-space/tab.  In particular, line
breaks are not removed, nor is whitespace removed over multiple lines.


E_find-regexp-forward(re :: <string>) => (pos :: <pos>, match :: <string>);
E_find-regexp-backward(re :: <string>) => (pos :: <pos>, match :: <string>);
INPUTS:
  re, a string containing a regular expression (see "Grammar" above
for the RE language allowed).
OUTPUTS:
  pos, a character position within a buffer where a match was found.
  match, a string containing a section of the buffer matching re.

The buffer is searched forward/backward from E_point (see below) for a
sequence of characters matching re.  The first character must be at or
before E_point but the rest may lie after it.  If no match is found,
the exceptional values (nil, nil) are returned (i.e., nil is neither a
<pos> nor a <string>).

After a successful match, E_point will lie at the end or start
(respectively) of the match in the buffer.  After a failure it will be
where it was on entry.


E_get-line-containing-pos(pos :: <pos>) => str :: <string>;
INPUTS:
  pos, a character position within a buffer.
OUTPUTS:
  str, a string representing the text of the whole line within which
pos lies in the buffer.


E_goto-line-start(pos :: <pos>);
E_goto-line-end(pos :: <pos>);
INPUTS:
  pos, a character position within a buffer.
OUTPUTS:
  None.

E_point is changed to lie at the start/end of the line containing pos.


E_goto-pos(pos :: <pos>);
INPUTS:
  pos, a character position within a buffer.
OUTPUTS:
  None.

E_point is changed to lie at pos.


E_indent-to-column(column :: <nat-number>);
INPUTS:
  column, the column to which to indent.
OUTPUTS:
  None.

Indent from E_point, by inserting tabs and/or spaces, until column is
reached.  It is undefined whether tabs, spaces or a mixture is used.


E_match-to-regexp(str :: <string>, re :: <string>) => match :: <bool>;
INPUTS:
  str, a string.
  re, a string containing a regular expression to be matched to str.
(see "Grammar" above for the RE language allowed).
OUTPUTS:
  match, a true/false value indicating whether str and re matched.

The <string> str is to be matched to re using the "editor"'s RE
matching algorithm as used in find-regexp-{for,back}ward.  In this
context, the special RE characters "^" and "$" mean "start-of-string"
and "end-of-string" respectively.


E_point;

This value gives the location of the user's "cursor" ("point" in Emacs
terminology) in the buffer.  It may be written to, as well as read
from, which will move the cursor.


** Data structures and global variables

There is only one global variable used in the algorithm, gi-items,
which has the following hierarchical structure.

    gi-items.
      all.
        start-re  :: <string>
        end-re    :: <string>
      num-items   :: <nat-number>
      item[].
        start.
          re      :: <string>
          offset2 :: <nat-number>
        num-inters :: <nat-number>
        all-inter-re :: <string>
        inter[].
          re      :: <string>
          offset1 :: <nat-number>
          offset2 :: <nat-number>
        end.
          re      :: <string>
          offset1 :: <nat-number>
      compiled    :: <bool>

gi-items.num-items gives the size of the array gi-items.item;
similarly gi-items.item[n].num-inters and gi-items.item[n].inter. 

gi-items.all contains two REs, one which matches a disjunction of all
the gi-items.item[n].start REs, the other the end REs.  Similarly,
gi-items.item[n].all-inter-re matches a disjunction of all m
gi-items.item[n].inter[m].re patterns, for each n.  If these
disjunctions would be empty in any case, the empty string is used
instead; this is unimportant, since num-items and num-inters values of
0 should prevent the strings being used at all.

gi-items.compiled is set to "true" (or at least, not "false") by
gi-compile-items and should be set to "false" by the default means of
construction for the gi-items structure in any implementation.

The remaining parts of the structure should reflect the specification
language in an obvious way.


** Main indentation algorithm

/*
// gi-calculate-indent
//
// The basic method is this:
//   Look backward in the text to find one of the /start/ or /inter/
//   patterns stored in gi-items.  This will tell you which structure
//   the start point is inside and how far the start of that structure
//   is indented.  Using also the indentation values in gi-items, the
//   indentation for the line containing the start point can be found.
//
// INTPUTS:
// base-pos is the character position whose line to indent, i.e. from
//   which to search.
//
// OUTPUTS:
// indent is the absolute amount (i.e., relative only to the start of
//   the line) of indentation for the line containing base-pos.
/*/
defun gi-calculate-indent(base-pos) {
  local item-pos, item-idx, indent, indent-pos, start-indent,
    inter-pos, inter-idx;

  (item-pos, item-idx) := gi-find-indent-determiner(base-pos, start);
  if (item-idx == NONE) then
    /* Top level ... use start of line? or preceding item's start? */
    indent := 0;
/* OR
    (indent-pos, _) :=
      gi-seek-item-back(base-pos,0,ANY,end));
    if (indent-pos == nil) then
      indent := 0;
    else
      indent := E_column(indent-pos);
    end if;
/*/
  else
    start-indent := E_column(item-pos);
    /* See if we can match item[item-idx].end.re to the start of this line. */
    if (E_match-to-regexp(E_get-line-containing-pos(base-pos),
                      gi-items.item[item-idx].end.re)) then
      /* This is an end on its own line, so use its /offset1/. */
      indent := gi-items.item[item-idx].end.offset1
    else
      (inter-pos, inter-idx) :=
          gi-find-indent-determiner(base-pos, inter, item-pos, item-idx);
      if (inter-idx == NONE) then
        /* No /inter/ between here and /start/: "start" case. */
        indent := gi-items.item[item-idx].start.offset2
      elseif (E_match-to-regexp(E_get-line-containing-pos(base-pos),
                            gi-items.item[item-idx].inter[inter-idx].re)) then
        /* We're sitting on an /inter/: "inter" case. */
        indent := gi-items.item[item-idx].inter[inter-idx].offset1
      else
        /* We're after some /inter/ for our /start/: "following" case. */
        indent := gi-items.item[item-idx].inter[inter-idx].offset2
        if (indent == NONE) then
          indent := gi-items.item[item-idx].start.offset2
        end if;
        /* ... Code to deal with continuation would go here. ... */
    end if;
    indent := start-indent + indent;
  end if;

  return indent;
}

/*
// gi-perform-indent
//
// Change the indentation of the current line to the value of indent,
// leaving the "cursor" (the value E_point) in a sensible position on
// the indented line
//
// By "sensible" is meant that the cursor should be moved in
// accordance with the line's change in indentation, so as to remain
// on the same character (though not at the same character position in
// the text, if a change was made).  It should not end up on a
// different line.  Furthermore, the cursor should be moved past any
// initial whitespace, if it would lie within it, so as to be "helpful".
// This repositioning may be overridden at a higher level by
// gi-indent-line, if the cursor did not initially lie on the indented
// line.
//
// It is permitted for a line to consist solely of whitespace after
// indentation.
//
// INPUTS:
// base-pos is the character position whose line to indent.
// indent is the absolute amount by which that line should be
//   indented.
//
// OUTPUTS:
// None: the text is modified directly via the editor functions (E_*).
/*/
defun gi-perform-indent(base-pos, indent) {
  local line-start, old-indent, new-base-pos, new-line-end;

  /* Find the current indentation and do the first part of working out
  // where to leave the cursor. /*/ 
  E_goto-line-start(base-pos);
  line-start := E_point;
  E_find-regexp-forward("[ \t]*");
  old-indent := E_column(E_point);
  new-base-pos := base-pos - old-indent + indent;
  if (new-base-pos < line-start) then new-base-pos := line-start;

  /* Now indent, using indent. */
  E_goto-line-start(base-pos);
  E_delete-horizontal-space(E_point); /* NOT trimming comments. */
  E_indent-to-column(indent);

  /* A second bit of "working out where to leave the cursor". */
  E_goto-line-end(line-start);
  new-line-end := E_point;
  if (new-base-pos > new-line-end) then new-base-pos := new-line-end;

  /* Position cursor as appropriate. */
  if ((new-base-pos - line-start) <= indent) then
    /* Move to first non-blank character on line, if we would be
    // inside what is now the line's initial whitespace. /*/
    E_goto-pos(line-start);
    E_find-regexp-forward("[ \t]*");
  else
    /* Simplest case: the new-base-pos calculated is "sensible". */
    E_goto-pos(new-base-pos);
  end if;
}

/*
// gi-indent-line
//
// Main indent function.  First calculate the indentation and then
// alter the text.  Leave the cursor in a "sensible" position (see
// gi-perform-indent) if it lay on the indented line.
//
// INPUTS:
// base-pos is the character position whose line to indent.
//
// OUTPUTS:
// None: the text is modified directly via the editor functions (E_*).
/*/
defun gi-indent-line(base-pos) {
  local saved-pos, indent;

  /* If we're somewhere other than base-pos, return there after
  // indenting (e.g., in case we're indenting a block of lines). /*/
  saved-pos := (if (E_point == base-pos) then nil else base-pos);

  /* Calculate the indent required, then change the text. */
  indent := gi-calculate-indent(base-pos);
  gi-perform-indent(base-pos, indent);

  /* Restore position, if we saved it earlier. */
  if (saved-pos != nil) then E_goto-pos(saved-pos);
}

/*
// gi-find-indent-determiner
//
// Look up-/back-wards in the text to find a "key-phrase" of some
// structural element in the language, which should determine the
// indentation of the lines "within" that structure (or "after" the
// key-phrase, if it's an intermediate word, like "else").
//
// Specifically, look for a preceding /start/ or /inter/ RE at a
// higher structure level (i.e. intervening items are skipped over).
// (To find the /start/ that matches an /end/, you must be INSIDE,
// or at the start of, that /end/.  Therefore, if the start point of
// the search lies on a line containing a /start/ or /inter/, the line
// is included in the search for preceding structures; but if it lies
// on a line with an /end/, this is not included in the search, or
// else we would skip over its structure.)
//
// On return, the "cursor" position is undefined.
//
// INPUTS:
// base-pos is the character position from which to search backward
//   (inclusive).
// target-kind tells what to search for ("start" or "inter").
// item-pos (only used if target-kind is "inter") gives the position of
//   the containing /start/, so the search should stop there (again,
//   inclusive).
// item-idx (only used if target-kind is "inter") gives the index of
//   the item whose /start/ is at item-pos, so we know which /inter/s
//   to search for.
//
// OUTPUTS:
// pos, the character position of the start of the text matching some
//   /start/ RE (nil if none matched), NOT including any whitespace
//   added by gi-compile-items.
// idx: if target-kind is "start" or "end", the index in gi-items
//   (starting from 0) of the item spec whose RE was matched (should
//   equal item-idx, unless it was ANY on entry); else target-kind is
//   "inter" (and item-idx is not ANY) so idx is the index of the
//   /inter/ spec (for item item-idx) whose RE was matched.  In either
//   case, may be NONE if no match was found.
/*/

defun gi-find-indent-determiner (base-pos, target-kind,
    &optional item-pos, item-idx) {
  local stop-pos, depth, curr-pos, target-pos, target-idx, end-pos,
    end-idx;

  /* Parameter validity checking. */
  case (target-kind)
    start =>
      item-pos := nil;
      item-idx := any;
    inter =>
      if (item-pos == nil OR item-idx == nil) then
        error("item-pos and item-idx must be supplied when "
              "target-kind is 'inter'");
      end if;
      if (item-idx < 0 OR item-idx > gi-items.num-items) then
        error("item-idx out of range for gi-items");
      end if;
    else =>
      error("target-kind must be one of 'start', 'inter'");
  end case;

  /* Decide on search stop-point. */
  stop-pos := ((item-pos == nil) ? 0 : (item-pos + 1));

  /* Search back iteratively, using depth to handle intervening items. /*/
  E_goto-pos(base-pos);
  depth := 1;
  do {
    /* Choose where to start the search, so that we're counted as being
    // inside an item if we're on its /end/ line and not if we're on its
    // /start/ line. /*/
    curr-pos :=
      (if (E_match-to-regexp(E_get-line-containing-pos(E_point),
                      "\(" + gi-items.all.start-re
                    + "\|" + gi-items.all.end-re
                    + "\)")) then
         E_line-start(E_point)
       else
         E_line-end(E_point)
       end-if);
    (target-pos, target-idx) :=
      if (depth == 1) then
        gi-seek-item-back(curr-pos, stop-pos, item-idx, target-kind);
      else
        gi-seek-item-back(curr-pos, stop-pos, ANY, start);
      end if;
    (end-pos, end-idx) :=
      gi-seek-item-back(curr-pos, stop-pos, ANY, end);
    if (target-pos == nil) then
      if (depth == 1) then
        /* Failed to find top-level target, so we're done. /*/
        depth := 0;
      else
        /* Failed to find matching start for the end which lay between
        // our most recent start point and top-level target.  This
        // implies bad syntax (end without a matching start) but we'll
        // ignore that and go back to looking for the top-level
        // target.  (This may not be a sensible choice -- untested.) /*/ 
        depth := 1;
      end if;
      /* Go back to where we were, in case gi-seek-item-back left us
      // somewhere else. /*/
      E_goto-pos(curr-pos);
    else
      if (end-pos != nil AND end-pos > target-pos) then
        /* There's an end between us and our target: go down a level. /*/
        depth++;
        E_goto-pos(end-pos);
      else
        /* We found either a start matching a previous end, or the
        // top-level target (depending on depth); either way, come up. /*/
        depth--;
        E_goto-pos(target-pos);
      end if;
    end if;
  } until (depth == 0);

  return (target-pos, target-idx);
}


** Specialised RE algorithms

/*
// gi-compile-items
//
// Given all the item definitions (parsed from some as-yet-unspecified
// file format), compile overall REs for searching when "ALL" is used.
//
// INPUTS:
// None: gi-items is a global data structure containing the item data.
//
// OUTPUTS:
// None: the fields of gi-items are modified directly.
/*/
defun gi-compile-items {
  local temp-re;

  /* Stop now if gi-items unchanged since last compilation. /*/
  if (gi-items.compiled) then return;

  /* Sanity check. /*/
  if (gi-items.num-items == 0) then
    gi-items.all.start-re := "";
    gi-items.all.end-re := "";
    return;
  end if;

  /* Some useful constants. /*/
  /* At the beginning of most REs we match, we have to add
  // "start-of-line plus whitespace" /*/
  defconst RE_START_BOL = "^[ \t]*";
  defconst RE_INTER_BOL = "^[ \t]*";
  /* /end/s are special: we need to be able to find them even if they're
  // not at a start-of-line, so we can backward-traverse structure
  // properly.  We still want word-boundary at the start, though. /*/ 
  defconst RE_END_BOL = "^[ \t]*\(.*[ \t]+\)?";
  /* After the (first matched) occurrence of some RE on a given line,
  // we allow extra characters only if the first is whitespace. /*/
  defconst RE_EOL = "\([ \t].*\|$\)";

  /* Compile REs for "ALL" /start/s and /end/s. /*/
  temp-re := RE_START_BOL + "\("
    + gi-items.item[1].start.re; /* '+' is string-concat /*/
  for (item-idx := 2; item-idx < gi-items.num-items; item-idx++) {
    temp-re += "\|" + gi-items.item[item-idx].start.re;
  }
  temp-re += "\)" + RE_EOL
  gi-items.all.start-re := temp-re;

  temp-re := RE_END_BOL + "\(" + gi-items.item[1].end.re;
  for (item-idx := 2; item-idx < gi-items.num-items; item-idx++) {
    temp-re += "\|" + gi-items.item[item-idx].end.re;
  }
  temp-re += "\)" + RE_EOL
  gi-items.all.end-re := temp-re;

  /* Compile "ALL" REs for each item's /inter/s. /*/
  /* Implementation Note: this will be more efficient in execution if
  // duplicate /inter/ REs within each item can be "removed" in the
  // "all" RE (e.g., "\(end\|end\)" becomes "\(end\)" or "end"). /*/
  for (item-idx := 1; item-idx < gi-items.num-items; item-idx++) {
    if (gi-items.item[item-idx].num-inters != 0) then
      temp-re := RE_INTER_BOL + "\("
        + gi-items.item[item-idx].inter[1].re;
      for (inter-idx := 2; inter-idx < gi-items.item[item-idx].num-inters;
          inter-idx++) {
        temp-re += "\|" + gi-items.item[item-idx].inter[inter-idx].re;
      }
      temp-re += "\)" + RE_EOL
      gi-items.item[item-idx].all-inter-re := temp-re;
    else
      gi-items.item[item-idx].all-inter-re := "";
    end if;
  }

  /* Compile REs for individual /start/s, /end/s and /inter/s.  This must
  // be done after the all-at-once REs, since those require the unmodified
  // versions of the individual REs. /*/
  for (item-idx := 1; item-idx < gi-items.num-items; item-idx++) {
    gi-items.item[item-idx].start.re := RE_START_BOL
      + gi-items.item[item-idx].start.re + RE_EOL;
    gi-items.item[item-idx].end.re := RE_END_BOL
      + gi-items.item[item-idx].end.re + RE_EOL;
    if (gi-items.item[item-idx].num-inters != 0) then
      for (inter-idx := 1; inter-idx < gi-items.item[item-idx].num-inters;
          inter-idx++) {
        gi-items.item[item-idx].inter[inter-idx].re := RE_INTER_BOL
          + gi-items.item[item-idx].inter[inter-idx].re + RE_EOL;
      }
    end if;
  }
  
  gi-items.compiled := true;
}

/*
// gi-extract-match-re
//
// Retrieves the compiled RE corresponding to item-idx and kind (i.e.,
// the original RE with extras added to the start/end of it).
//
// INPUTS:
// item-idx is either an index into gi-items, or ANY.
// target-kind is "start" or "end", or also "inter" if item-idx is not
//   ANY.
//
// OUTPUTS:
// match-re is a string containing a regular expression.  If item-idx
//   is ANY then the RE will match all /start/s or all /end/s,
//   depending on target-kind; if it is an item index, the RE will
//   match a specific /start/ or /end/, or all /inter/s for that item,
//   again depending on target-kind.
/*/
defun gi-extract-match-re (item-idx, kind) {
  /* Rely on (lone) caller to get parameters right. /*/

  return
    (if (item-idx == ANY) then
       case (target-kind)
         start => gi-items.all.start-re;
         end => gi-items.all.end-re;
       end case;
     else
       case (target-kind)
         start => gi-items.item[item-idx].start.re;
         end => gi-items.item[item-idx].end.re;
         inter => gi-items.item[item-idx].all-inter-re;
       end case;
     end if);
}

/*
// gi-seek-item-back
//
// Search backwards from base-pos until a match is found for one of
// the REs in the list corresponding to item-idx and target-kind.  On
// return, the "cursor" position is undefined.
//
// INPUTS:
// base-pos is a character position in the text, from which to begin
//   the search (inclusive).
// stop-pos is the last character position to be included in the
//   search (looking backwards; i.e. stop-pos <= base-pos)
// [In both of the above, "the search" means "the search for the first
// matching character".  Later matching characters may overrun the end
// boundary, base-pos.]
// item-idx is an index into the list of item specs; ANY indicates
//   "match any index".  (ANY is only valid if target-kind is "start"
//   or "end").
// target-kind is one of {start,inter,end}.
//
// OUTPUTS:
// pos, the character position of the start of the text matching some
//   /start/ RE (nil if none matched), NOT including any whitespace
//   added by gi-compile-items.
// idx: if target-kind is "start" or "end", the index in gi-items
//   (starting from 0) of the item spec whose RE was matched (should
//   equal item-idx, unless it was ANY on entry); else target-kind is
//   "inter" (and item-idx is not ANY) so idx is the index of the
//   /inter/ spec (for item item-idx) whose RE was matched.  In either
//   case, may be NONE if no match was found.
/*/
defun gi-seek-item-back(base-pos, stop-pos, item-idx, target-kind) {
  local match-re, match-pos, match-string, match-idx, idx;

  /* Parameter validity checks. */
  if (stop-pos > base-pos) then stop-pos := 0;
  if (NOT member(target-kind, {start, inter, end))) then
    error("target-kind must be one of 'start', 'inter' or 'end'");
  end if;
  if (natnum? item-idx) then
    if (item-idx < 0 OR item-idx >= gi-items.num-items) then
      error("item-idx out of range for gi-items");
  elseif (item-idx == ANY) then
    if (NOT member(target-kind, {start, end})) then
      error("item-idx may be 'any' only if target-kind is one of "
            "'start' or 'end'");
  else
    error("item-idx must be a non-negative integer or 'any'");
  end if;

  /* Special, simple case which will likely be quite common: we're
  // looking for any /inter/ for an item which has none specified. /*/
  if (target-kind == inter AND gi-items.item[item-idx].num-inters = 0) then
    return (nil, NONE);
  end if;

  /*
  // Retrieve the RE to search for and add extras to it.
  /*/
  match-re := gi-extract-match-re(item-idx, target-kind);

  /*
  // Move to the base-pos and search back.
  /*/
  E_goto-pos(base-pos);
  /* Assume E_find... returns (nil, nil) if no match; if not, simulate. */
  (match-pos, match-string) := E_find-regexp-backward(match-re);
  if (match-pos != nil) then
    /* Now fix the match-pos to skip leading whitespace. */
    match-pos := E_find-regexp-forward("[ \t]*");
  end if;

  /*
  // Process results.
  /*/

  /* If the match failed (or was outside stop-pos), return "NONE". */
  if (match-pos == nil OR match-pos < stop-pos) then
    E_goto-pos(base-pos);
    return (nil, NONE);
  end if;

  match-idx := NONE;
  if (nat-number?(item-idx)) then
    if (member(target-kind. {start, end})) then
      /* Simple case: item-idx was a number, target-kind was "start"
      // or "end". /*/
      E_goto-pos(match-pos);
      return (match-pos, item-idx);
    else /* (target-kind == inter) */
      /* More work: found an /inter/ for item "item-idx", now have to
      // find out which one. /*/
      for (idx := 1; idx < gi-items.num-items; idx++) {
        if (E_match-to-regexp(match-string,
              gi-items.item[item-idx].inters[idx].re)) then
          match-idx := idx;
          exit for;
        end if;
      }
    end if;
  else
    /* Otherwise, the item-idx was ANY, so work out which we really got. */
    /* Note: it might be possible to do this more efficiently, depending
    // on the underlying editor. /*/
    case target-kind
      start =>
        for (idx := 1; idx < gi-items.num-items; idx++) {
          if (E_match-to-regexp(match-string,
                            gi-items.item[idx].start.re)) then
            match-idx := idx;
            exit for;
          end if;
        }
      end =>
        for (idx := 1; idx < gi-items.num-items; idx++) {
          if (E_match-to-regexp(match-string,
                            gi-items.item[idx].end.re)) then
            match-idx := idx;
            exit for;
          end if;
        }
    end case;
  end if;
  if (match-idx == NONE) then error(...);
  E_goto-pos(match-pos);
  return (match-pos, match-idx);
}

** Issues

*** 06: How to collect and index the REs (and offsets) in the first place.
I hope this will be possible during an editor session (e.g. as new
source files are created or loaded), not just on editor start-up).

*** 07: Add the possibility of "indent-region" or "indent-item".
This could be more efficient and cleverer, once it knows how the first
line is to be indented.

*** 08: [DONE] Change algorithm to cope with /end/ patterns not at SOL.
That is, they may occur after the first non-whitespace character in a
line.  However, the relevant indentation preference will only be used
if the /end/ pattern IS at the line start.  (Change gi-indent-line,
gi-find-indent-determiner and gi-skip-item-back.)

*** 09: Changes suggested (many by Jason)
For algortihm:
**** [DONE] Rename find-enclosing-start-or-other to reflect its function,
e.g. find-indentation-determiner, then explain what this "determiner" is
in a comment.  Done: renamed to find-indent-determiner.
**** [DONE] Rename /start/, /other/ and /end/ to reflect the terminology
in the DRM (and/or Harlqeuin parser).  Done: changed /other/ to
/inter/, as in "intermediate-word"; left /start/, rather than changing
it to /begin/, as it covers both definitions (which don't have a
"begin-word") and statements (which do).
**** [DONE] Add description of data structures used.  Done.
**** [DONE] Add description of syntax/semantics of editor functions
relied upon.  Done.
**** [DONE] Fill in details of error messages.  Done.
**** [DONE] Fill in "local" variable declarations.  Done.
**** Write tests.

For emacs code:
**** [DONE] Add HOPE line at top of file (like RCS $$ comemnts).
Done: added \$HopeName\$.
**** [DONE] Add doc'n of entry points, global vars etc.  Done.
**** Write parser for items!
**** [DONE] Prefix all global/function names to create a "namespace".
Done: prefixed with "gi-" for "generic indenter".
**** If top-level indent takes too long, maybe add heuristic: stop seeking
back if you reach a non-comment in the 1st column.
**** [DONE] Cache results of gi-build-match-re (or, make this part of
gi-compile-items).  Done: results are always cached but a small
function remains, now called gi-extract-match-re.  This does less work
and is only called once, by gi-seek-item-back, but might be useful for
later extentions.
**** [DONE] Cache numbers of items and /inter/s per item, in gi-items.
**** [DONE] Check uses of save-excursion; maybe costly, so could
avoid at lower levels.  Done: removed in most places, but point is now
manually saved in gi-match-to-regexp (without saving mark and buffer).
**** [DONE] gi-indent-line: put into separate defuns the indent computation
and the indent action.  Done: split into gi-{calculate,perform}-indent.
**** [DONE] validation sections: put into separate defuns, per defun.  Done
**** [DONE] "equal" over symbols can be optimised to "eq".
**** [DONE] Use multiple-value-bind, not destructuring-bind, for better
performance when ported to a "real" Common Lisp implementation.
**** [DONE] "Match symbols" in case needn't be quoted (and quoting will
only slow things down)
**** [DONE] Add documentation strings for the defuns (and comments
before each defun, where necessary).  Done.
**** [DONE] Make sure code and algorithm are in sync!  Done.
**** [DONE] Make sure comments are in sync with code and algorithm!  Done.
**** ?Add copyright claim?
**** Write tests.
**** Make global "gi-*" variables buffer-local or mode-local?

General:
**** [Read "Writing Solid Code", by Steve McGuire, MSoft Press (& "Debugging
the Software Dev't Process").]


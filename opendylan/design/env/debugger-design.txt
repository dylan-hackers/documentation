
			-=-=-=-=-=-
			DEBUGGER UI
			-=-=-=-=-=-

This file contains notes on the debugger design, its UI and functionality,
for Kansas.

* OVERVIEW --------------------------------------------------

We unify the overall functionality of an interactor (to Lispers, the REP
loop or "Listener") and a debugger into what this document refers to as the
"debugger panel".  We unify these two components of the development
environment (dev env) because whether you are "interacting" or "debugging"
seem to be arbitrary labels applied to your activity, and there is a lot of
inherent crossover between the pieces of functionality.  We want the GUI for
these pieces to express their inherent unity, and we want all the
functionality to be conveniently available to users when they are
"interacting" or "debugging".

We do recognize that you can think of yourself as being primarily in one of
two modes.  There is a "play" mode where you are interactively investigating
code, developing code, or experimenting with little bits of Dylan, and in
this mode you are likely to ignore most errors or barely spend any time
debugging them.  There is a "debugging" mode where you are primarily
debugging a running application, and in this mode you are likely to
evaluating expressions in an interactor pane only incidentally to your
debugging.

There is one debugger panel per thread.  Users can readily request debugger
panels for threads they are interested in, but in general the dev env
creates debugger panels as necessary.  For example, an application may
consist of three threads, but when an unhandled condition is signalled on a
thread, the dev env creates a single debugger panel that is dedicated to
that thread.  The dev env does not create a debugger panel for every thread
in the application just because the user needs to "enter the debugger" on
one thread.

There are two "builtin" visual layouts to a debugger panel.  Please regard
the two figures, ~dylan/doc/design/env/debugger-figs.ps.  Figure 1 shows the
Debugger Panel in its "interactor layout", with the interactor pane
prominent (see ~dylan/doc/design/env/interactor-design.{doc,ps}).  Figure 2
shows the debugger panel in its "debugger layout", with all the debugging
panes visible.  There are bars between all the panes that users can grab to
reallocate the real-estate within the debugger panel.  Growing or shrinking
the debugger panel keeps the relative ratio of pane sizes.  You cannot move
panes around, only resize their relative proportions.  When a debugger panel
corresponds to a target application thread created by the dev env, the dev
env automatically changes between the panel layouts (see the description
below of the interactor layout).  When a debugger panel corresponds to a
target application thread created as part of the application's execution,
the dev env never automatically changes the panel's layout.

The interactor layout is the default layout for a thread that was created by
the dev env for the user to evaluate Dylan code.  The layout features a
large, scrolling pane that is used for entering expressions for evaluation
and for logging input expressions and their results.  Output from the
'debug-message' function appears here as well.  Other pieces of the debugger
panel in an interactor layout are standard DylanWorks environment tools
elements.  When users input erroneous expressions, a "debugging context"
begins, and the dev env installs the debugger layout in the panel.  When
debugging is completed, and the evaluated expression returns (or the user
aborts the evaluation), the dev env restores the interactor layout in the
panel.

The debugger layout is the default layout for a thread that was
created by the target application.  The layout displays all the panes
that comprise the debugger panel.  There is a pane at the top used to
display the context, where for example, a description of the
unhandled condition appears, or some other description of the thread's
state.  There is a tall pane along the left side of the debugger panel
that is a tree gadget for displaying the thread's backtrace.  To the
right of the backtrace pane is a tab controller gadget that displays
various kinds of information (for example, a code view, possibly
disassembly code, details about a selected stack frame, etc.); this
document refers to this pane as the Properties Pane.  Below the Backtrace
and Properties Panes is an interactor pane.  Other pieces of the
debugger panel in a debugger layout are standard DylanWorks
environment tools elements.


* CONTEXT PANE --------------------------------------------------

The Context Pane displays the reason that the thread has stopped, or
indicates that it is running.

There are several possible reasons for a thread to be stopped:

	MANUAL STOP by pressing the stop button

	FROZEN THREAD from stopping that thread from running
	in the thread browser

	UNHANDLED EXCEPTION occurred

	OTHER THREAD got a stop reason

If the cause for stopping the target application was an unhandled condition
on the debugger panel's thread, then the Context Pane displays a
message representing the unhandled condition object.

If the cause for stopping was a OS error (for example, illegal instruction
or segment violation), and the Dylan implementation did not mask the error
as a Dylan condition (that subsequently went unhandled), then the
Context Pane displays some indication of the reason the target application
stopped.

If the debugger pane's thread was not the cause of the target
application stopping, then the Context Pane indicates which thread
caused the target application to stop.

The Context Pane has an indicator for whether the debugger panel may
contain out of date information for its thread.  We currently plan to have
users explicitly update dev env tools with the View Menu's "Refresh" Item.
For the following reasons, it could be particularly costly to update all
debugger panels:

  - A single debugger panel could be costly to update each time the target
    application continues and stops because of scanning the whole stack,
    polling variable information to determine whether a call frame node is
    expandable, possibly autoselecting a call frame now (such as the top of
    the stack), possibly having to update the "Source" tab in the Properties
    Pane, etc.

  - There could be a few debugger panels in existence, each partially
    visible or fully visible.  There may be no support for getting "raise to
    top" or exposure notifications through DUIM, and some feel that raising
    a window and having it update gives the user an unsettled sense.

  - The target application could continue and stop frequently because that's
    how we implement expression evaluation in the interactor.

Of course, we refresh the debugger panel for the thread that caused the
target application to stop as soon as the Runtime Manager signals the dev
env.

The context pane (or something near by) might also contain an
indication of the debug level that we are currently at.

* BACKTRACE PANE --------------------------------------------------

The backtrace pane is a tree gadget.  At the highest level, the backtrace
pane lists the frames of the control stack.  Each function call frame is
represented with the name of the function whose call created the stack frame
(tail calls constitute a stack frame creation for this context).  

** NODE TYPES

We can potentially distinguish different function frame types in the
nodes of the tree. Perhaps using icons or colours to do so:

	FUNCTION TYPE		ICON?			COLOUR?

	restart			boomerang		light blue

	handler			pair of hands		light green

	signaller		traffic light		light red or light
							orange depending on
							exception class

	top user function	top hat			black

	other user function	person			dark grey

	system function		two cogs		light grey

Orthogonally to this we might want to iconically distinguish functions
that are:

	open					
	sealed					
	generic					
	method					
	traced					
	broken					

The most interesting are the bottom two (traced, and broken). Perhaps
simple a simple annotation on icons above, say a hook coming out of
the side?

** VIEW MENU

The View Menu offers users the following options:

	+ SHOW SPECIALIZERS -- frame names include the specializers
	  for the required arguments.

	+ SHOW ARGUMENTS -- frame names include a terse representation
	  of the arguments passed to the function.

	+ SHOW SYSTEM FRAMES -- don't filter out system frames. By
	  default backtrace pane only shows functions with bindings
	  that are accessible from the project library's modules.

	+ SHOW CONTROL FRAMES -- don't filter out non-function-call
	  frames like block cleanup. By default the backtrace pane
	  only shows function calls.

	+ EXPAND ALL -- Expands all frames to show locals.

	+ EXPAND -- Expands current frame to show locals.

	+ COLLAPSE -- Collapses current frame to hide locals.

	+ COLLAPSE ALL -- Collapses all frames to hide locals.

Foreign function frames are represented with the function's name, as long as
it was available in Codeview(tm) debug-info format in the application's
binary image.

Non-call frames are represented with short descriptive phrases (for
example, "Block Cleanup Frame", "Non-local Exit Frame", "Dynamic-bind
Frame", etc.).

For a description of right click pop-up menus, see section "SHORTCUT MENUS".

** EDIT MENU

When using cut, copy, paste on backtrace pane:

	CUT	always disabled
	COPY	copy selected item onto clipboard
	PASTE	disabled on frame
	PASTE	set local with clipboard value

** EXPANDING ITEMS

You can expand a top-level node to expose one level further, but no nodes on
the second level expand to a third level.  You can only expand nodes that
represent function call frames.  The second level displays the "live" (see
below) arguments and other locals of function call frames.  When compiling
"in development mode", the compiler artificially arranges to keep all
arguments to a function alive throughout a function's body of code, so you
should always be able to see a function's arguments.

Live locals are variables that are known to have valid values for the stack
frame's code location in the function.  Every function call frame is at a
code location.  Some code locations are "known" and some are "unknown".
When a frame is at an unknown code location it may appear as though there
are no known live locals.  If there are no live local variables, then the
top-level function call frame node in the tree gadget will not be
expandable.

** DISPLAYING ARGUMENTS AND OTHER LOCALS

The backtrace pane displays local variables in the following format:

	<name> = <value>

For Dylan function call frames, the printed representation of the variable's
value is in some Dylan literal syntax or some description of the object
delimited by curly braces (for example, {foo instance}).  For foreign
function call frames, in the Kansas time frame, we just print the local
variables' values in hex.

For now, when expanding a node that represents a function call frame, both
the arguments to a function and other locals are always shown.  Perhaps when
users have chosen to display call frame nodes by including a terse
representation of the function's arguments, the expansion of the call frame
node should exclude the arguments (since a representation of them is already
visible).  The two representations of the arguments' values could be
different, but probably they won't be.  The local variable nodes created
under a function call frame node do show the variables' names, while the
representation of the call frame node does not show the variables' names,
just the values.

For now, there is a "separator node" in the sequence of nodes for a
function's local variables.  This node currently displays as

   --Args Above, Other Locals Below--

In the future, we'll display arguments in a bold face and other locals
in a roman (or otherwise "standard" typeface), without any separator label.
If the DUIM stuff gets enhanced in time for Kansas so that it allows users
to present to the tree gadget more than a string for the node label, then it
should be little effort to incorporate that mechanism in the debugger.  We
might also be able to employ a little glyph beside the local's name to
indicate whether it is an argument.


** SELECTING ITEMS AND DOUBLE-CLICKING TO ACTIVATE PROPERTIES PANE

Users select items in the backtrace tree gadget with a single left
mouse click.  Selecting an item causes no change to occur in the
Properties Pane.  Enough people in the dev env group felt it was
interesting to be able to select without engaging the Properties Pane.
If we find that we mostly are mostly engaging the Properties Pane and
do not care much about being able to efficiently select a backtrace
tree node, then we can cause the code view pane to engage on a single
left mouse click.

When the user double-clicks the left mouse button on an item in the
backtrace tree gadget, the item is selected, and the Properties Pane
to the right includes tabs appropriate to the selection.  See the
section "PROPERTIES PANE" for a description of the tabs that appear
for each kind of node.  The user selects a node with a left or right
mouse click on the node label; clicking on the expansion or
compression box only changes the state of the expansion (analogous to
Windows Explorer(tm)).

For Kansas, if you select a tree gadget node that is not a function call
frame or a local variable, then all tabs in the Properties Pane are
gray, and there is no pop-up right click menu.  I'm perfectly happy to undo
this decision, but there is no plan within the Kansas time frame for making
interesting information available about non-function-call frames.



* PROPERTIES PANE --------------------------------------------------

This section contains a very brief description of the Properties Pane,
which is located to the right of the backtrace pane in the debugger panel.

Chris Page will write a description of the Code Viewer, which is the
most interesting element of the of this pane.  When he completes that
document, I'll refer to it here.  Note, the information in this section is
mostly right, but Chris and the UI Manager may change UI gestures before
this piece is completed.


** AVAILABLE TABS

The Properties Pane for a function call frame node has the following tabs:

	+ SOURCE
	This is a Code View that can display known code locations.
	There is at most one per line.  The code view also shows the
	location in the function for the selected stack frame.  Since
	the function may be at an unknown code location, the location
	may be shown at the beginning of the line for the actual code
	location.

	+ GENERAL
		- full name
		- physical location (directory, file, line number etc)
		- logical location (library, module, source record, etc)

	+ FUNCTION

	Shows the following (if available, may not be due to compilation
	policies or limited foreign code info):

		- Whether it is a Dylan function or foreign.
		- Defining module of function's name, if named.
		- Argument names and declared types.
		- Return values and declared types.
		- Documentation.
		- Tracepoints?
		- Breakpoints?
		- Adjectives?
		- Locals?
		- Optimzation Info?

The Properties Pane for a local variable node has the following tabs:

	+ SOURCE
	
      This is the same as for the containing function.

There are no other tabs since the value is visible in the backtrace pane,
and there's no reason to provide a rudimentary inspector as part of the
debugger pane.  It is already getting very complicated, and it could be easy
to confuse the user into thinking the full data browser is running in the
Properties Pane.

I'm not sure I agree with Bill's sentiments above.

** SOURCE TAB

For a description of right click pop-up menus, see section "SHORTCUT MENUS".

A left mouse click on a known code location toggles the existence of a
breakpoint.  The breakpoint is always created in the enabled state.

A control left mouse click on a known code location performs "run to here"
(see above).

A shift left mouse click on a known code location establishes tracing (see
above).

A right mouse click on the pointer for the selected call frame's code
location raises a short cut menu containing stepping commands.

If we end up supporting conditional breakpoints, there will be some gesture
for indicating that the dev env should prompt the user for an expression or
with a dialog box and several kinds of conditional breaking.  Then the dev
env will evaluate the expression or adhere to the contract of the
breakpoint, and only keep the target application stopped when the expression
or condition is true.




* INTERACTOR PANE --------------------------------------------------

See ~dylan/doc/design/env/interactor-design.{doc,ps}.

This document should describe how it uses the History Menu, how it handles:

	compiler messages for code entered into the interactor
	shortcut menus, the Edit Menu items
	mouse clicks in the interactor pane
	library/module/debug-level display
	abort restarts

* MENU BAR --------------------------------------------------

For many of these menus, I'm taking the information from the Project Browser
UI writeup.  My understanding is that these represent "standard menu items",
but I'm sure that isn't meant literally.  Some of the items do not make
sense for a debugger panel.  Currently, the policy from the UI Manager is
that "standard" menu items that do not apply within an environment component
are greyed out in that component.

There may be "standard menu items" that I don't mention below.  This would
occur for one of two reasons.  The first is that the items have exactly the
standard functionality associated with them as described by the UI Manager's
standard features document (to be written).  The second is that I wasn't
notified of a standard menu item's existence and wasn't able to think about
how it might have fit into the debugger panel.

For a visual overview of the menus, see
~dylan/doc/design/env/debugger-menus.ps.

For a description of right click pop-up menus, see section "SHORTCUT MENUS".

File
   New ...
   Open ...
   Exit
      These are greyed out.
   Print ...
      Print dialog offers users the ability to print the interactor pane,
      backtrace, properties pane, context pane, or a combination
      thereof.  The default is to print all of the above in some form that
      is recognizable as a bug report.  There is an option for printing to a
      file.
   Print setup ...
      Brings up a standard print setup dialog.
   Close
      Exits the debugger panel.  This has no affect on the corresponding
      thread or application.  If the exited debugger panel were the last
      one, the user could get another from the threads browser, which is
      accessible from the Project Controller.  If the issue is getting
      another debugger panel just to continue the application's execution,
      the Project Controller may have this action hanging directly off one
      of its menus.

Edit
   Undo
   Redo
   Cut
   Copy
   Paste
   Delete
   Select all
      These work in the interactor pane on the input text.
   Find ...
      This should do a search in the interactor pane.  I suppose it could do
      a search through the backtrace pane, or some of the tabs in the tab
      controller pane.  I'm not sure if the pane context is always apparent
      from what the user did last.
   Find in file
      If this is a general environment tool for grepping through sources,
      then that's what this item does.
   Replace
      This works in the interactor pane, if anywhere.

View
   Refresh
      Updates the window's image.  For now, we do not automatically update a
      debugger panel based on its being raised or mapped, or the application
      starting and stopping.  Users use this item to force a redisplay of
      current information for the debugger panel.
   Toolbars
      Toggles the display of the toolbar components of the standard
      environment window.
   Status bar
      Toggles the display of the status bar component at the bottom of the
      standard environment window.
   Backtrace Options ...
      This raises a property page for the backtrace pane, which is the same
      property page that the "Properties" item of the shortcut menu for the
      backtrace pane's background.  The current set of properties are the
      following:
	 Show Specializers
	 Show Arguments
	 Show Control Frames
	 Show System Frames
	 Collapse All
	 Collapse
	 Expand
	 Expand All

History
   Any standard items for all environment windows are greyed out.  This
   includes one or two commands for the interactor.  See
   ~dylan/doc/design/env/interactor-design.{doc,ps}.

Run
   Start
   Restart
   Debug ...
      These are greyed out.
   Terminate
   Stop
      Pauses the execution of the target application.  The thread that is
      executing when the application stops has nothing to do with the
      debugger panel used to invoke this menu item, nor does any information
      in the debugger panel affect where the application stops.  When the
      Runtime Manager signals the dev env that it has has stopped the
      application, the dev env pops up a modal dialog requesting that the
      user select a thread for which to create/raise a debugger panel.  The
      dialog should also have a "Continue Application" button for just
      aborting the "Pause" action.
   Continue
      Continues the execution of the target application if this thread was
      stopped at a breakpoint or stepping point.  To invoke a restart for
      this thread, use the "Choose Restart ..." item.
   Connect
   Disconnect
      These are greyed out.
   Breakpoints ...
      Raises a breakpoints editor that shows all breakpoints, enabled or
      disabled.  This is a table describing all breakpoints.  Users can
      enable, disable, or remove them.  Users can quickly set by name entry
      and exit breakpoints.  Possibly then can easily browse to a named
      function for setting internal breakpoints.  Please see Chris Page's
      document(s) on the Code Viewer and Breakpoint Editor (to be
      written).
   Clear all breakpoints
      Removes all breakpoint objects.
   Tracing ...
      Raises a tracing editor which shows all traced functions.  You can
      untrace functions or trace functions based on an input name.
   Untrace all functions
      Untraces all functions.
   Choose thread ...
      Raises a modal dialogue for creating or raising a debugger panel for
      another thread.
   Choose restart ...
      Raises a modal dialogue so that the user can select a restart to
      signal on the debugger panel's thread.  Restarts are displayed as a
      descriptive message.  Whenever the interactor sends an expression to
      the target application for evaluation, the evaluation occurs within
      the context of an abort restart.
			
RATIONALE: We grey out some target application controls between the Project
Controller and debugger panels because some actions require the debugger
panels to be deleted (or to exist before the application runs), so it makes
sense to have the user go to a window that is not a debugger panel for those
actions.  Similarly, a general tool for controlling which threads are
permitted to run when the application is executing should be obtained
through a dialog or menu that the user gets from the Project Controller,
since debugger panels are thread-dependent.  As a convenience, we do have
the "Choose thread ..." item for pulling up debugger panels on other
threads.

Help
   Topics
   About DylanWorks


* SHORTCUT MENUS --------------------------------------------------

(RIGHT MOUSE CLICK POP-UPs)

The UI Manager's thinking is that there are two sets of menu items in any
short cut menu.  There are items that are applicable to "any" object in the
development environment representing an element of the project's sources, an
object in the run-time execution of the project, or an object used as part
of the development process (for example, breakpoints).  There are also items
specific to the selected environment object.  I suspect in practice we'll
find that there are standard shortcut menu items that do not have a valuable
meaning for every environment object.

   [ED: There's a suggestion to document the standard shortcut menu items
    for all environment objects in a separate document so that there's one
    place to look for that information.  I think that's fine for our
    internal use, and when someone creates that document, then I'll refer to
    it here rather than document the menus here.  Our documentation group
    should determine what's best for our customers in terms of whether this
    info should be duplicated in the debugger chapter.]


Backtrace Pane

A right mouse click on a function call frame node in the backtrace pane pops
up a menu with the following items:
   Browse
      Brings up a Project Browser for the function object.
   Browse Class
      Brings up a Project Browser for the class of the function object.
   Edit Source
      Brings up the editor on the source unit containing the function
      definition with the editor's point of focus positioned at the start of
      the defining form.  If the function is not defined at top-level, and
      the compiler does not store the definition's header offset, then
      perhaps we can get the source location for the virtual function-start
      breakpoint and position the editor's point of focus there.
   View Source
      Selects the Code View tab in the Properties Pane to the right of
      the backtrace tree gadget.
   View Documentation
      Bring up a window (project browser?) with the documentation for the
      function.  This is only useful for Dylan and Functional Objects
      framework functions since the DylanWorks does not include a means
      for users to install documentation for their own code.
   Cut
   Copy
   Paste
      These are greyed out.
   Properties
      Selects the properties tab in the Properties Pane to the right of the
      backtrace tree gadget.
   Trace/Untrace
      Toggles tracing for the function.
   Break on Entry/Remove break
      Toggles whether there is a breakpoint at the beginning of the
      function's body.
   Break on exit/Remove break
      Toggles whether there is a breakpoint in the function's prologue
      before returning.

A right mouse click on a local variable node in the backtrace pane pops up a
menu with the following items:
   Browse
      Brings up a Project Browser (the inspector) for the variable's value.
   Browse Class
      Brings up a Project Browser for the class of the variable's value.
   Edit Source
      Brings up the editor on the source unit containing the function
      associated with the local variable node.  See the "Edit Source" item
      for the shortcut menu for function call frame nodes.
   View Source
      This is greyed out.  Because the short cut menu selects the item, and
      the Properties Pane has to correspond to the selection, we can't
      view the code.  We could add a page to the Properties Pane for local
      variables that shows the function's source.
   View Documentation
   Cut
   Copy
   Paste
      These are greyed out.
   Properties
      Selects the properties tab in the Properties Pane to the right of the
      backtrace tree gadget.

A right mouse click on the background of the backtrace pane pops up a menu
with the following items:
   Browse
   Browse Class
   Edit Source
   View Source
   View Documentation
   Cut
   Copy
   Paste
      These are greyed out.
   Properties
      This goes to the properties page for the backtrace pane.  It is the
      same page that the View Menu brings up for the "Backtrace Options ..."
      item.


Code View Pane (the "Source" Tab)

The description of these shortcut menus is brief.  Chris Page will write a
description of the Code Viewer.  When he completes that document,
I'll refer to it here.

A right mouse click on known code location glyph pops up a menu with the
following items:
   Browse
   Browse Class
   Edit Source
   View Source
   View Documentation
   Cut
   Copy
   Paste
   Properties
      These are greyed out.
   None
      Removes any special feature at the known code location.
   Break
      Creates or removes a breakpoint at the known code location.
   Enable
      Enables or disables the existing breakpoint at this code location.
   Run to here
      Causes the application to continue its execution and to stop when the
      debugger panel's thread encounters the known code location.
   Trace
      If performed on the first or last known code location in the display,
      then this item traces the function on entry and exit.  If we support
      trace messages at "internal" locations, then this item prompts the
      user for some text and outputs that text in the trace log for any
      thread executing through that code location.

A right mouse click on an identifier for a module binding will offer the
following shortcut menu:
   Browse
   Browse Class
   Edit Source
   View Source
   View Documentation
   Cut
   Copy
   Paste
   Properties
These all do whatever the UI Manager describes in his document of the
Project Browser for "definition objects".


Interactor Pane

See ~dylan/doc/design/env/interactor-design.{doc,ps}.



* TOOLBAR --------------------------------------------------

The toolbar has the following buttons. The intervening blank lines are
intended to represent the actual gaps between the button groups on the
toolbar.

	BUTTON		ICON		OPERATION

	CUT		scissors	Remove the selected object to
					the clipboard.
	COPY		2 papers	Copy the selected object to
					the clipboard.
	PASTE		glue brush	Paste the clipboard into the
					selection.

	TOP		|<		Move to top stack frame.
	UP		<		Move up one stack frame.
	DOWN		>		Move down one stack frame.
	BOTTOM		>|		Move to bottom stack frame.
	FIND		binoculars	Search for something.

	EXPAND ALL	++		Expand all stack frames to
					show locals. 
	COLLAPSE ALL	--		Collapse all stack frames to
					hide locals.

	EDIT		document	Launch and editor to edit the
					source code associated with
					this frame. 
	BROWSE		tree diagram	Launch a browser to inspect
					the data associated with the
					selection.

	STOP		solid square	Stops the application
					immediately. 
	CONTINUE	solid triangle	Continues the application
					after stopping at a breakpoint
					or stepping point.  The
					ability to continue by
					signalling a restart for the
					debugger panel's thread is
					associated with the Restarts Button.
	ABORT		skull & xbones	Aborts the current application
					operation. Makes it return to
					its event loop.
	BUG REPORT	beetle		Composes a bug report based on
					the current state of 
					the application.

	STEP (OVER)	arrow over	Steps to next code location in
			braces		the function that is the
					current top stack frame. Skips
					over function calls. No
					Runtime Manager machinery will
					be seen to be "on top of the
					stack", so the stack's top
					frame should be a function the
					user is interested in.
	STEP INTO	arrow into	Steps to next code
			braces		location. Enters function
					calls. If the know code
					location was not immediately
					before a function call, this
					command acts like the Step
					command.
	STEP OUT	arrow out of	Steps to next code location in
			braces		parent stack frame. Note, the
					true caller of the function
					"on top of the stack" might
					not exist due to tail call
					optimizations.
	STEP UPTO	arrow up to	Steps to cursor position.
			flag

	RESTARTS...	boomerang	Raises a modal dialogue
					signalling a restart on the
					debugger panel's thread.  This
					is the same as the "Choose
					restart ..." item in the Run
					Menu.
	BREAKPOINTS...	broken		Raises a breakpoints editor
			arrow		that shows all breakpoints,
					enabled or disabled.  This is
					the same as the "Breakpoints
					..." item in the Run Menu.
	TRACING...	eye at		Raises a tracing editor which
			arrow		shows all traced functions.
					You can untrace functions or
					trace functions based on an
					input name. 
	THREADS...	bundle of 	Raises a modal dialogue for
			threads		creating or raising a debugger
					panel for another thread. This
					is the same as the "Choose
					thread ..." item in the Run
					Menu. 

* STATUS BAR --------------------------------------------------

A debugger panel currently makes no use of the standard dev env window's
status bar.  The interactor may make use of it somehow (see its document).

Possible messages include:

	<thread status> = {running, stopped, frozen, ...}

or	<debug activity> =
			{initializing, re-initializing, stepping,
			evaluating, profiling, stopping, starting,
			signalling, ...}

It might also be useful to have separate thread state in a set of
panes: equivalent to a single line of the thread browser. This could
include: ID, Title, and Status. It would leave the status bar proper
to display activity messages.

* BREAKPOINTS --------------------------------------------------

One way to set breakpoints is to select a function call stack frame in the
backtrace pane, and then select the "Code" tab in the Properties Pane.
If you only want to set a breakpoint upon entry or normal exit from the
function, you can use the shortcut menu (right mouse click) in the backtrace
pane for a function call frame.  The Code View of the function's
source contains glyphs that indicate known code locations.  A left click on
a code location glyph creates a breakpoint there.

The above scenario only works when you are browsing a thread's stack and
want to set a breakpoint in one of the functions on the stack.  You can also
set breakpoints with the "Breakpoints ..." item of the Run Menu.  This
raises a breakpoints editor that lists all breakpoints, allows users to
modify existing breakpoints, and supports setting entry and exit breakpoints
for named functions (possibly browsing named functions too for setting
internal breakpoints).

You can set breakpoints while the target application is running.  That is,
when the user says to set a breakpoint, if the target application is
running, we do not put up an error box; instead, we stop the target
application behind the scenes, install the breakpoint, and continue the
target application.

You can set breakpoints before starting the target application, but setting
the breakpoints would have to occur after the user has built the project,
compiled the source unit containing the definition, etc., so that the
compiler products DB will have recorded where breakpoints can be set.  There
will be some means (probably in the breakpoint editor) for indicating that
breakpoints should persist throughout the development environment session,
and each time a new execution of the target application begins, the dev env
will set those breakpoints for you.  Breakpoints set while no target
application is attached to the dev env will automatically be marked as
session-persistent breakpoints.




* TRACING --------------------------------------------------

This sections describes how the dev env handles tracing output and how users
enable and disable tracing for functions.


Displaying Tracing Output

The dev env collects tracing output in thread-specific buffers.  The Project
Controller contains a Threads Menu for invoking Project Browsers for the
threads of the target application.  These browsers have a tab in their tab
controller for viewing the trace output for the thread.

The output from the 'debug-message' function also appears in the
thread-dependent trace output buffers.  Each call to 'debug-message' occurs
in some thread, and that thread's trace output includes the debug message.
The 'debug-message' output also appears in the interactor pane of the
thread's debugger-panel.


Tracing and Untracing Functions

To trace a function, you can click the mouse's right button over the
function's call frame node in the backtrace pane and select the
"Trace/Untrace" item in the pop-up menu.

You can also trace functions with the "Tracing ..." item of the Run Menu.
This raises a tracing editor that lists all functions with tracing enabled,
allows users to untrace functions, and supports tracing functions based on
an user-input name.

It should be the case that anywhere a function is displayed (for example,
a module binding in a Code Viewer where the definition is a function,
a method shown as part of browsing a GF, a list of module identifiers when
browsing a module, etc.) you can right mouse click to get a shortcut menu
with a "Trace/Untrace" item.



* STEPPING --------------------------------------------------

Stepping is essentially based on setting breakpoints at known code
locations.  You can step within a function to its next known code location.
If the target application is stopped at a known code location that is
immediately before a function call, you can step into the function call.
You can step out of a function call to the "caller" of the function; you
might not land in the direct caller of the function due to tail call
optimization.  Stepping is thread-dependent; that is, when using a stepping
command in a debugger panel, the target application next stops at a step
point only in the debugger panel's associated thread.  Any intervening stop
reason aborts the stepping command, but the user can continue stepping by
issuing another stepping command (providing the thread can be stepped).

The Code View pane will display a function's code location relative
to a selected stack frame in the backtrace pane.  There will be a shortcut
menu in the code view and toolbar buttons with commands for stepping
to the next known code location in the current function, stepping into a
function call (if possible), stepping out of the current function call
(always possible unless a non-local-exit occurred), and stepping to a
selected known code location (known as "run to here").

The code view displays the line of source code at which the
application is stopped in the associated thread.  The next piece of code to
execute is not necessary the code fragment at the beginning of the current
line.



* PROJECT CONTROLLER --------------------------------------------------

Some activities we may think in the context of debugging are actually
provided to the user via the Project Controller.  This section lists those
activities.

<To be filled in.  The rest of this document mentions all these activities,
but I thought it would be helpful to cull them from the rest of the document
and list them here.>



* THE 'DEBUG-MESSAGE' FUNCTION --------------------------------------------------

There is a function called 'debug-message' that takes a format control
string (as specified by the DRM for condition-format-strings) and arguments.
This is exported from the functional-extensions module of the
functional-extensions library.  This function delivers its output to two
places.  The output shows up in the interactor pane for the thread calling
'debug-message', and the output shows up in the display of trace output for
the thread.

The former destination supports intuitive notions based on Lisp tradition of
where debugging output would appear.  The latter enables programmers to
easily see where their output occurred relative to the trace of the
application's execution; traditionally the trace output would clutter the
interaction pane, but since it is separated, it will be hard for users to
synchronize their debugging messages with the trace output unless we deliver
the debugging messages to both destinations.



* THREADS BROWSER --------------------------------------------------

The Project Controller has a Threads Menu, or some means for getting to a
threads dialog, that allows the user to invoke a thread Project Browser.
This browser has a tab controller with a tab for seeing properties of the
thread and a tab for seeing trace (and 'debug-message') output for the
thread.  You can use the thread browser to indicate whether a thread is
permitted to execute when the target application is running.  We will
probably allow the user to change at any time whether a thread is permitted
to run; if the target application is already running, we will quietly stop
the application, change the thread's status, and then continue the
application's execution.

Some threads browsing, or information associated with threads, is
dissociated from debugger panels for a couple of reasons.  First,
information such as trace or 'debug-message' output cannot be shown in the
tab controller pane of the debugger panel because the tab controller's
context comes from a selection in the backtrace pane.  Second, users need
some thread controls when there is no debugger panel already existing for a
thread, so it would be more convenient to get access to those controls via
an ever-present Project Controller window.  Also, some threads controls
invalidate debugger panels, such as terminating a thread, so it seems
cleaner to have those commands occur outside the context of the debugger
panel.

The threads browser should provide a means for creating a debugger panel for
a thread.  Debugger panels also include a means for creating/raising
debugger panels for other threads.

Issues:

	debug-message
		thread output
	VC++
		Fields:	ID (current), suspend count, priority, location (function/address)
		Operations: set focus, suspend, resume, 
	LispWorks
		Fields: name, priority, status, slices
		Operations: break, kill, destroy, stop, unstop, debug, inspect, update
	WinDBG
		Fields: thread no. (current), thread id, status
		Operations: freeze/thaw, freeze all, thaw all, select
	entry points
		project browser tab
		debugger panel menu
	where should sources live
		cpage says: project-properties.dylan, and object-properties.dylan
		in the environment/tools/ 
	shared command tables
		yes (especially for right button)
	browser vrs dialog use
		start with browser

We could also put the debug-level as a column in the threads browser.

* SCENARIOS --------------------------------------------------

This section describes some scenarios of a user taking actions we think of
as debugging actions.  Some of the actions do not involve the debugger
panel, but those actions have been talked about mostly in the context of
debugging.

<Parts of this section were moved to become their own section.  If time
permits, we can populate this section with more scenarios, but I don't want
to spend that time now.>



* OPEN ISSUES --------------------------------------------------

There are some features that might change slightly from the description in
this document.  There are places in the text where we say "we should ...",
"probably ...", and so on.  There are also some things we may change just
in the natural course of implementation, feedback from real usage, and
changes in policies.  Officially, there are no open issues.  I'll keep this
document up to date as our ideas of the debugger's functionality and UI
change.



* STAGED DEVELOPMENT --------------------------------------------------

This section describes two kinds of features:
   Those we plan to include in Kansas, but they are not considered to be
      absolutely necessary for shipping a minimal product.  These items
      should be developed later down the pipe when all minimal functionality
      has been built.
   Those for which we need support for the real Kansas implementation, such
      as DUIM frobs, DM frobs, etc.
This section is more of an implementor's note than a description of the
debugger functionality suitable for outside the immediate group.  I've
included it in this document as a way of keeping track of these issues for
now.

I apologize for failing to cross-references these issues from the other
sections, organizing them more logically, or otherwise making the list
easier to work with.

1] We want to be able to filter the backtrace gadget to include only
   functions that are accessible by bindings in the project's library, but
   implementing this should occur after we have basic breakpoint and trace
   functionality working.

2] Stepping.
   [WE HAVE A PLAN FOR IT, AND THE RUNTIME GROUP HAS A DESIGN FOR IT.]

3] Better designation of arguments versus other locals when expanding a
   function call frame in the backtrace tree gadget.  Needs DUIM
   enhancements.

4] Displaying 'debug-message' output.  The Runtime group needs to build some
   stuff before before I can do this, or even fake it.
   [THE HAVE IT DESIGNED NOW.]

5] Do better method representations in backtrace tree gadget for function
   call frame nodes when DM provides support for this.  That is, showing
   method specializers as part of method name.

6] Disassembly.
   [NOT HAPPENING FOR KANSAS.]

7] Maintaining a list of breakpoints the user wants the dev env to set
   every time the target application starts up.  This list would be
   session-dependent and not persist across sessions for Kansas.
   [CHRIS IS BUILDING THIS NOW.]

8] Various pieces of tracing.

9] Selecting items in the backtrace pane and coordinating with a tab
   controller object.  Need to get the Properties Pane fleshed out and
   get ability to actually associate source code with a target application
   and display it.
   [PAUL ALMOST HAS STUFF IN PLACE TO PRESENT TO US SOME PSEUDO-SOURCE CODE
    AND SUPPORT BREAKPOINTS AND STEPPING ON IT.  THIS WOULD ALLOW US TO TEST
    OUR STUFF IN THE EMULATOR ONCE CHRIS AND I ARE READY TO DO SO.]

10] Code viewer functionality above and beyond showing known code
    locations that are at or near (first on a line?) the beginning of a
    line.
    [THIS IS ALL WE'RE DOING ANYWAY.]

11] Some aspects of menus are being staged.  For example, we need support
    from DUIM to dynamically change the menu command structures so that we
    can redo the Restarts Menu and Threads Menu each time the target
    application stops executing.  Some of the features in the View Menu can
    wait for basic product functionality to work before adding "enhanced"
    features.
    [UI MANAGER HAS REMOVED ALL NEED FOR DYNAMIC MENUS AT THIS POINT.]

12] Restarts are being staged for Runtime Manager printing support as well
    as DUIM support.  Depending on names of restarts, how the print as a
    message, and how users get at this info, we may need to change our
    concept of the Restart Menu.  This is a general issue for condition
    objects.
    [NO LONGER DEPENDENT ON DUIM SUPPORT.]


* GLOSSARY --------------------------------------------------

backtrace pane

properties pane (includes code view)

debugger layout

debugger panel

debugging context

interactor

interactor layout

known code location

live args and locals

context pane

target application

unknown code location

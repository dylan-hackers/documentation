                         The Debugger Manager (DM).
                         ==========================

                                 Version 6
                           Paul Howard, Tony Mann.
                                 March 1997

                 (c) 1996, 1997 Functional Objects, Inc.
                            All Rights Reserved.


This Document.
--------------

This describes the interface to the Debugger Manager (DM). Clients of
this API should import the library 'debugger-manager', and also the
module 'debugger-manager'.

Readership: mainly the designers and implementors of the debugger/interactor
tool, and those defining environment protocols.

Related documents:

- D-doc-design-runtime-manager!debugger-manager-issues.text

  Describes the current set of open issues regarding this design.

- D-doc-design-runtime-manager!debug-access.{doc, ps}

  Describes the access-path interface. This is the language-independent
  layer of the debugger architecture that the DM builds itself upon.

  Note: this document has fallen out of date again!

- D-doc-design-runtime-manager!debugger-nub.text

  Describes the debugger nub interface, the lowest (platform-specific)
  level of the tether architecture.

- D-doc-design-compiler!compiler-interface.{doc, ps}

  Describes the interface to the functionality of the compiler from the
  rest of the environment.


The Access Path Library
-----------------------

Any functionality provided by the access-path library that might also be
needed by DM clients will be provided by a wrapper function taking a
<debug-target> rather than <access-path> parameter. Eg, the access-path
function:

            suspend-thread access-path remote-thread => ()

will (if necessary) be "duplicated" in the DM layer as:

            suspend-thread debug-target remote-thread => ()



Summary of Revisions since version 3
------------------------------------

  - Updated the print/inspect API.

  - Added some convenience interfaces for dylan function objects
    (obtaining method IEPs and specializers).

  - Got rid of the stop-reason/stop-case confusion by unifying these
    hierarchies. The access-path now provides an open branch of
    the <stop-reason> hierarchy for the DM to add its own stop-reasons.

  - Added "wrap-up" functionality for some access-path APIs and
    definitions. Notably: removed call-frame-description (which
    mapped <call-frame>:debugger-manager to <function-frame>:access-path,
    and added some new accessors instead).

  - Tidied up errors and inconsistencies; removed hyphens from break-point,
    watch-point and trace-point.


Summary of Revisions since version 4
------------------------------------

  - Added APIs for generating maps of live lexicals in stack frames.

  - Added APIs for unpicking runtime dynamic state: conditions and
    handlers.

  - Added APIs for source-level stepping operations. The DM is going
    to actively control these operations, rather than merely providing
    lists of source locations.

  - Introduced language-level stop reasons from the access path. These
    help out with condition printing and the generation of debug
    messages.

  - Introduced the profile-interval keyword to manage-running-application.


Summary of Revisions since version 5
------------------------------------

  - Added mappings between source forms and remote values.

  - Added mappings between source locations and remote addresses.

  - Added some more specific object inspection APIs.


Remaining Holes
---------------

  - It might be desirable to further flesh out the convenience accessors
    on runtime objects such as functions and classes in order to
    support browsing along with the compiler DB.

  - The DM's position with the interactor is only partly described here.
    Some more thought is needed.

  - Full integration with the compiler. (When, when, wheennnnnn?)


1. Introduction.
----------------

The Debugger Manager (DM) is quite a high-level component of the debugger
architecture. It sits between the access path interface and the debugger
UI. The DM provides abstractions over the debug operations described by
the access path interface, as well as providing dylan-specific debugging
functionality.

Terminology:

  DM       - Debugger Manager. The component of the debugger described by
             this document.

  RTM      - Runtime Manager. The DM in conjunction with other internal
             support for the tether/interactivity: the access-path and
             interactive downloader.

  UI       - User Interface (of the debugging tool). Client of the
             DM.

  DevelDBG - A simple Dylan debugger with a command-line interface.
             Some implementation details of DevelDBG require specific
             functionality from the Debugger Manager. These have been
             kept to a minimum and are flagged in this document by
             "DevelDBG only".

For DevelDBG, the debugger UI will probably import most of the access
path functionality as well as debugger manager functionality. It is doubtful
that this model will be adopted for the final debugger. Certainly _some_
access path definitions will need to be exposed (stop-reasons being a
good example), but exposing application control functions like "stop" and
"continue" potentially allows the UI to interfere with the DM's management
of the running app. 



2. Model of the Debugger Manager.
---------------------------------

The general model of the debugging tool can be reduced to two concurrent
loops: a loop processing user input in the UI, and a loop receiving stop
reasons from the running application. The DM takes charge of the latter,
but synchronizes with the UI by operating a callback system, calling on UI
routines when important events are received from the running application.

Callbacks are invoked under the following circumstances:

1. The application stopped because a debug event or exception occured
   (an "internal" stop), or because some event in the debugger UI
   signalled that the application should stop (an "external" stop).

2. The application hit a breakpoint/watchpoint. At the low level, a 
   breakpoint/watchpoint hit is just another variety of internal stop.
   However, the DM provides a separate mechanism of callbacks for
   them, since they are the vehicle for many higher-level debugging
   facilities such as tracing.

3. The application is ready to continue. This means that the application
   had previously stopped for some reason (which may have involved the
   invocation of other callbacks), but the DM is now capable of
   allowing it to resume.

The following sections describe how and when these callbacks are
registered, and the precise form they must take.



3. Access Path Extensions.
--------------------------

Note:
This section described some necessary alterations to the access-path
design document. These changes (and several others) have now been made,
and the current access-path design now resides in:

      D-doc-design-runtime-manager!debug-access.{doc, ps}

Another document to look at is:
 
      D-doc-design-runtime-manager!debugger-manager-issues.text

which describes issues that remain to be thought about in this
document, or possible adjustments to the APIs.



4. Debug Targets.
-----------------

A "debug target" represents whatever is being debugged. In most cases,
this will be a newly created application. Basically, a debug target is
very similar to an access path, and has a one-to-one correspondance with
an <access-path> instance. The main difference is that the <access-path>
is a sealed description of the connection to the debugger nub, whereas the
<debug-target> can be subclassed to hold any information that clients of
the DM wish to store.


<debug-target>                             [Open Abstract Instantiable Class]

  Describes an application being debugged. Users of the DM are allowed
  to create appropriate concrete subclasses of <debug-target> with slots
  specific to their own purposes.

  It is always possible to map between a <debug-target> and its
  corresponding <access-path>.

  When a <debug-target> is made, an <access-path> of the approriate type
  is made automatically. The DM will also install the <debug-target> as
  the "debugger-abstract-handle" slot of the access path.

  This class is specified to take the same init-keywords as <access-path>.
  (They will just be passed on when the <access-path> instance is made).

  Example:-

      define class <knackered-application> (<debug-target>)
      end class;

      define variable my-app = 
                    make (<knackered-application>,
                          application: "spam",
                          arguments: "spam");


debug-target-access-path debug-target => access-path        [Generic Function]

  It's not clear that we need to export this function at all from the DM, but
  it will certainly be there in the implementation. (Exporting it is
  advantageous for DevelDBG since it allows us to use all the access-path 
  functionality as well, such as access-path-arguments). 
  See the note in the introduction.



5. Stop Reasons.
----------------

The access-path exports the open abstract class <external-stop-reason>
(as a subclass of <stop-reason>). The DM expands on this open branch of
the hierarchy.


stop-reason-debug-points debug-target debug-point-stop-reason => sequence
                                                         [Generic Function]

  Returns the sequence of <debug-point> objects that caused the stop reason.
  The sequence will only contain those debug-points whose callbacks
  returned #t (see the section 7)


<debugger-generated-stop-reason>                           [Abstract Class]

  A subclass of <external-stop-reason>. A stop reason indicating that the
  application was stopped by some action on the part of the UI.


<debugger-stop-application-stop-reason>                             [Class]

  A subclass of <debugger-generated-stop-reason>. The stop reason generated 
  when the UI calls stop-application (section 6) for some reason.


The access-path also supports an open subclass of <internal-stop-reason>
called <language-level-stop-reason>. This is so that the DM can, having
examined the dynamic state of the application, present more informative
stop-reasons. Here are the subclasses defined by the DM, along with
various specific accessors.

Note: <language-level-stop-reason> is so new that the access-path design
      doesn't mention them, yet.


<dylan-invoke-debugger-stop-reason>                                 [Class]

  A subclass of <language-level-stop-reason>. A stop-reason indicating
  that an unhandled dylan condition resulted in a dylan-level invocation
  of the debugger.


dylan-condition-object dylan-invoke-debugger-stop-reason => condition
                                                         [Generic Function]

  Given an instance of <dylan-invoke-debugger-stop-reason>, returns
  the condition object that resulted in it. The condition is returned as
  a <remote-value>. A printable representation of the condition can be
  obtained by calling print-dylan-object, passing the condition as the
  object to be printed.


<dylan-debug-message-stop-reason>                                   [Class]

  A subclass of <language-level-stop-reason>. A stop-reason indicating
  that the application called a dylan-level debug utility to generate a
  formatted debugging message.


dylan-debug-message-string debug-target dylan-debug-message-stop-reason 
                                 => string
                                                                 [Function]

  Builds up and returns the formatted string that was generated by
  the debug-message call.


Issue: the runtime needs to define and implement a protocol to support
       the <dylan-debug-message-stop-reason>. It must arrange for the
       format string and format args to be in well-defined locations
       before calling DebugBreak() or whatever to signal us.
       Status - Resolved.


<interactor-return-stop-reason>                                     [Class]

  A sublass of <language-level-stop-reason>. A stop-reason indicating that
  the execution of an interactive form has just returned, and that its
  results are available.


interactor-transaction-id interactor-return-stop-reason => transaction-id
                                                                 [Function]

  All interactive evaluations have a transaction-id associated with them.
  This accessor returns the id that was associated with the evaluation
  that just returned, generating the stop reason. This transaction-id will
  be \== to the transaction-id that was returned when the interactor
  called execute-source (see gz's CSI document).


interactor-return-values interactor-return-stop-reason => vector
                                                                [Function]

  Returns a vector of <remote-value>s corresponding to the sequence of 
  return values generated by the interactive evaluation. 


6. Managing Application Control.
--------------------------------

The DM takes responsibility for most aspects of application control. There are
no explicit functions to wait for stop-reasons or to continue execution - the
DM performs these tasks at need during an indefinite loop. Within this loop,
the DM invokes various callbacks that can be registered by the UI. 


stop-application debug-target => ()                      [Generic Function]

  Suspends the application with immediate effect. 


kill-application debug-target => ()                      [Generic Function]

  Terminates the application regardless of its state.


restart-application debug-target => ()                   [Generic Function]

  Restarts the application from the beginning.


manage-running-application debug-target 
                           #key stop-reason-callback,
                                poll-for-stop-callback,
                                ready-to-continue-callback) => ()
                                                         [Generic Function]

  Starts up the application via its access path and enters an indefinite
  loop. Within this loop, the DM receives stop-reasons through the
  access-path and invokes the appropriate registered callback. 

  This function does not return until the running application exits or
  is killed.

  A number of callbacks can be specified up-front as keyword
  parameters. The UI will almost certainly want to specify all of these,
  though defaults are provided.


  stop-reason-callback
      A function of two arguments, a <debug-target> and a <stop-reason>,
      which returns a boolean. The DM invokes this callback whenever a 
      stop-reason is received from the application. Note that breakpoint 
      exceptions are a special case (see "Registering breakpoints.")

      If the callback returns #f, the application is silently resumed. If
      it returns #t, the application remains suspended, and the
      ready-to-continue-callback is invoked with an instance of
      <internal-stop-reason>. The return value of #t, therefore, indicates
      an "interest" in this stop reason, whereas #f effectively filters it
      out.

      The application is known to be frozen during the entire execution
      of this callback.


  poll-for-stop-callback
      A function of one argument, a <debug-target>. In a single-threaded
      environment (which DevelDBG will be), this function is needed to
      give the UI a chance to stop the application. The DevelDBG UI, for
      instance, has a "stop button" whose status can be checked during this
      periodic callback. 
      
      During execution of this callback, the UI may call stop-application.
      This will result in the ready-to-continue-callback being invoked
      with an instance of <debugger-stop-application-stop-reason>. But note 
      that this will not happen until the poll-for-stop-callback returns.

      The DM undertakes to call this function at frequent intervals. The
      default callback does nothing (and hence does _not_ call
      stop-application).

      For a multi-threaded GUI debugging tool, this callback will not be
      required.

      The application may be running during the execution of this callback.


  ready-to-continue-callback
      A function of two arguments, a <debug-target> and a <stop-reason>.

      This callback is invoked whenever the debugger manager is ready to
      continue the application. If the application stopped of its own
      accord (an internal stop), then other callbacks will already have had 
      the chance to do their own processing (such as the handling of 
      debug-points).

      Reaching the ready-to-continue-callback means that _all_ of this
      processing has been done, but the internal stop was still interesting
      enough for control to be passed to the UI before continuing.

      This callback may call the function kill-application. In this
      case, the application will no longer be running, and
      manage-running-application will return. This callback may also
      call the function restart-application, in which case the app
      will be re-run from the beginning, but will continue to be
      managed in the same loop. (That is, manage-running-application
      will not return).

      If the callback returns without having called kill-application or
      restart-application, the application will be resumed from the
      point where it stopped.

      The default callback does nothing.

      The application is known to be frozen during the entire execution 
      of this callback.

      In a multi-threaded UI environment, this callback will probably block on
      some resource which can be freed by a "continue" gesture in the GUI.
      [NB: This idea has been expanded upon by Tony in his email
      "Some thoughts about how to use the debugger manager."]


      DevelDBG
      --------

      The ready-to-continue-callback will be a loop that processes user 
      commands indefinitely. The last command in such a session must either 
      be "continue" (in which case the callback just returns) or "kill"
      (in which case the callback calls kill-application and then
      returns).


7. Registering Debug Points.
---------------------------

The DM allows any number of debug points to be positioned on any one
address (obviously, the first such debug point results in actually setting a
breakpoint or watchpoint in the application, but the DM takes care of this
implicitly). In the DM, a debug point is described by an address paired with 
a callback. 

Debug Point callbacks take three arguments, a <debug-target>, a <debug-point> 
and a <remote-thread> (the thread that signalled the debug point exception), 
and return a boolean.

A return value of #t indicates that the application should stop as a result of
this debug point (ie, the UI is interested in it, given the current context). 
#f implies that the callback has done all of the necessary processing and the 
application may continue.

Debug point callbacks have slightly different semantics than those callbacks
described thus far. They are not functions that are immediately called when
a debug-point is encountered. Instead, they are functions which _can_ be
called if the context is relevant. This is further described below.


<debug-point>                                         [Sealed Abstract Class]

  A subclass of <object>. This is NOT the same as <debug-point-stop-reason>
  as defined in the access-path design.

  Requires the following init-keywords:

  address:
  A <remote-value> - the location at which this debug point is to be 
  registered.

  callback:
  A <function> - the callback to be invoked when the debug-point is hit. Should
  accept a <debug-target>, a <debug-point> and a <remote-thread> as arguments,
  and return a boolean (as described above). Note that the DM does not
  _directly_ invoke this callback. Instead, it calls the open generic
  function handle-debug-point-event (see below), which may or may not 
  subsequently invoke the callback.

    
<breakpoint>                              [Open Abstract Instantiable Class]

  A subclass of <debug-point>.


<watchpoint>                              [Open Abstract Instantiable Class]

  A subclass of <debug-point>.


handle-debug-point-event debug-target debug-point remote-thread => boolean
                                                    [Open Generic Function]

  When a debug-point is encountered at address X, the DM selects all 
  debug-points that were registered at X and calls this GF with each 
  debug-point in turn.

  If any one of these calls returns #t, the application will remain
  suspended, and the ready-to-continue-callback will be invoked with
  a <debug-point-stop-reason>. If _all_ calls return #f, the
  application will be silently allowed to continue. Note that a
  return value of #t does not short-circuit this process - all selected
  debug-points still get handled.

  Clients of the DM can add methods to this function to specialize the
  behaviour of their own debug-point subclasses.

  The _default_ method on this GF just invokes the registered callback
  for this debug-point, passing it the same arguments, and returning its
  return value. This default behaviour can be reached by calls to
  next-method(). 

  Example:

      define class <ph-breakpoint> (<breakpoint>)
      end class;
        
          ...

      define method handle-debug-point-event 
                      (app :: <debug-target>,
                       x :: <ph-breakpoint>,
                       t :: <remote-thread>) => (_ :: <boolean>)

           if (wind-blowing-in-the-right-direction())
               #f  // Don't invoke the registered callback, and
                   // don't signal any interest in this breakpoint.
           else
               next-method()
           end if
       end method;


register-debug-point debug-target debug-point => ()

  Registers the <debug-point> with the DM. It is added to any others that have
  already been registered at the same address. (If there are no others, then
  this call will actually set a low-level breakpoint). 


deregister-debug-point debug-target debug-point => ()

  De-registers the <debug-point>.


<debug-point-error>                                                 [Class]

  A subclass of <error>. A condition of this type will be signalled by
  register-debug-point or deregister-debug-point if either operation fails
  for some reason. This might occur, for example, if an address in the 
  application's code was not mapped and so a breakpoint instruction
  could not be poked in.


<thread-sensitive-breakpoint>             [Open Abstract Instantiable Class]

  A subclass of <breakpoint>. Takes an extra required init-keyword
  thread:, which must be a <remote-thread> instance. The registered
  callback will be invoked only when the breakpoint is encountered
  by the given thread.

  (Note: the DM needs to implement this class for its own purposes. I
  decided to export it as a potentially useful building block).


<tracepoint>                            [Sealed Abstract Instantiable Class]

  A subclass of <breakpoint>.

  All debug-points to do with function tracing are a subclass of
  <tracepoint>. Calling make on this class returns an instance of
  <entry-tracepoint>.


<entry-tracepoint>                        [Open Abstract Instantiable Class]

  A subclass of <tracepoint>.

  This requires a further init-keyword return-callback: (of the
  same specification as the callback: keyword argument). 

  The default handle-debug-point-event method for <entry-tracepoint>
  calls the registered callback as well as setting a <return-tracepoint>
  on the return address via a protocol described below. This
  <return-tracepoint> will have, as its registered callback, the
  function that was supplied as the return-callback.

  Entry tracepoints can only be set at the very start of functions.
  The DM will refuse to register an <entry-tracepoint> whose address:
  keyword does not correspond to the first address of a function
  definition. A <debug-point-error> will be signalled if this
  condition is not met. (Maybe another error class should be defined
  for this specific case...?)

  Valid addresses are therefore those which are known in advance to
  be the addresses of functions. Addresses obtained via
  dylan-method-iep, for example, will be valid. The address of a
  <remote-symbol> will only be valid if the symbol denotes a
  function.


<return-tracepoint>                       [Open Abstract Instantiable Class]

  A subclass of <tracepoint>.

  It is not intended that clients of the DM should create and register
  <return-tracepoint> objects except via the special mechanism that
  the DM provides (see the functions below).

  The default handle-debug-point-event method for <return-tracepoint>
  will invoke the registered callback if (and only if) the thread and
  stack contexts are the same as when the corresponding <entry-tracepoint>
  was encountered. In this case, the <return-tracepoint> will also
  _deregister itself_ 


make-return-tracepoint debug-target entry-tracepoint remote-thread
                        #rest keys #key #all-keys  => return-tracepoint
                                                     [Open Generic Function]

  When the DM encounters a debug-point of type <entry-tracepoint>,
  there is the need to set a <return-tracepoint> on the corresponding
  return address. The DM calls this open generic function in order to
  create it. This is required since <return-tracepoint> is an open
  class.

  The default method simply returns an instance of <return-tracepoint>.


initialize-return-tracepoint debug-target return-tracepoint remote-thread
                              #key => ()
                                                     [Open Generic Function]

  After calling make-return-tracepoint, the DM also calls this open
  generic function with the newly created return-tracepoint. This allows
  the client to perform any other specialized initialization behaviour.

  The default method actually registers the return-tracepoint, so
  clients defining methods on this function should make sure that they
  call next-method() at some point.


corresponding-entry-tracepoint return-tracepoint => entry-tracepoint
                                                         [Generic Function]

  Given a return-tracepoint, returns the registered entry-tracepoint
  that created it. 



  Example - simple function tracing.
  ----------------------------------

  define class <my-entry-trace> (<entry-tracepoint>)
         slot traced-function :: <remote-symbol>,
              required-init-keyword: symbol:;
  end class;
  
  define class <my-return-trace> (<return-tracepoint>)
         slot traced-function :: <remote-symbol>,
              required-init-keyword: symbol:;
  end class;

  define method print-entry-data
                 (app :: <debug-target>, bp :: <my-entry-trace>,
                  thr :: <remote-thread>) => (_ :: <boolean>)
         format-out ("Entered %s in thread %s\n",
                     bp.traced-function.remote-symbol-name,
                     thr.thread-name);
         #f;
  end method;

  define method print-return-data
                 (app :: <debug-target>, bp :: <my-return-trace>,
                  thr :: <remote-thread>) => (_ :: <boolean>)
         format-out ("Returned from %s in thread %s\n",
                     bp.traced-function.remote-symbol-name,
                     thr.thread-name);
         #f;
  end method;

  define method make-return-tracepoint
                 (app :: <debug-target>, bp :: <my-entry-trace>,
                  thr :: <remote-thread>, #rest keys, #key, #all-keys)
                  => (_ :: <my-return-trace>)
         apply (make, <my-return-trace>, symbol: bp.traced-function, keys)
  end method;

  // Just for completeness of the example...

  define method initialize-return-tracepoint
                 (app :: <debug-target>, bp :: <my-return-trace>,
                  thr :: <remote-thread>, #key) => ()
         next-method ()
  end method;
  .
  .
  .
      register-debug-point (my-application,
                            make (<my-entry-trace>,
                                  address: some-remote-value,
                                  symbol: some-remote-symbol,
                                  callback: print-entry-data,
                                  return-callback: print-return-data))
  .
  .


NB: THE FOLLOWING SECTION ON SOURCE-LEVEL STEPPING IS CLOSELY TIED TO
    THE MATERIAL IN CHAPTER 14 ENTITLED, STRANGELY ENOUGH, "SOURCE
    LEVEL STEPPING"


<source-step-breakpoint>                            [Sealed Abstract Class]

  The DM defines some special breakpoint classes to describe the results
  of source-stepping operations. This is the superclass of all such
  breakpoints.

  Clients of the DM should NEVER call register-debug-point or
  deregister-debug-point with general instances of this class. Instead,
  one of the functions in chapter 14 should be called to implicitly
  perform the registration.

  For any <source-step-breakpoint>, the DM guarantees that the supplied
  callback will only be invoked if the breakpoint is encountered by
  the same thread that set it. (Source-level stepping must surely
  be thread-specific). For this reason, <source-step-breakpoint> is
  actually a subclass of <thread-sensitive-breakpoint>.


source-location-stepped-from source-step-breakpoint => source-locator or #f
                                                                 [Function]

  Upon encountering a <source-step-breakpoint>, this returns the
  <source-locator> describing the location that we were stepping
  from. If we weren't at a known source location when beginning the
  step, this function will return #f. 


source-location-stepped-to source-step-breakpoint => source-locator or #f
                                                                 [Function]

  Upon encountering a <source-step-breakpoint>, this returns the 
  <source-locator> describing the location that we have stepped
  to. Note that this _should_ be the destination location that was
  calculated by the DM upon commencing the step, but it might not
  be if the step was aborted due to a nonlocal transfer of control.

  In any case, this tells us where we are NOW.

  If there is no known source location for the destination, this function
  returns #f. (This should be a rare case).


<step-completed-breakpoint>                                        [Class]

  Signalled when a thread was executing a step operation, and has
  reached the destination location. No non-local exits occurred during
  the step.


<source-aligned-breakpoint>                                        [Class]

  Signalled when a thread was instructed to align to a known source
  location (via align_thread_to_source_location). This means that the
  the application is now at a known source location, and the
  source-location-stepped-to accessor will return it.


<nlx-step-breakpoint>                                              [Class]

  A breakpoint that is signalled by a thread that was executing a step
  operation (or source-alignment operation), but the destination of the
  step was different from any expected destination due to a non-local
  exit in the program. The use of a separate class is simply the DM's
  way of warning clients that the non-local exit occurred. The DM
  will consider this to be the destination of the step, though. In
  other words, clients should not expect any subsequent
  <step-completed-breakpoint> to be signalled for this step operation.

 

8. Dylan Name Context.
----------------------

THIS CHAPTER IS A PLACE-HOLDER. NAMESPACE CONTEXT AND MANGLING WILL
EVENTUALLY BE IMPORTED FROM THE COMPILER. (THE NAMES IN THIS
CHAPTER WILL CHANGE ACCORDINGLY!)

UPDATE: We think that <dylan-name-context> is the only place-holding part.
It will probably become some compiler-related "module model" object.
I'm hoping that we won't have to change the APIs in this chapter.
	
In order to resolve dylan names, they need to be mangled by the debugger in
the same way that they were mangled by the compiler. In order to do this,
the debugger must know the "context" (the library name and module name) to
mangle into. For example, if the context specifies the dylan library and
the internal module, then *pants* mangles to TpantsTYdylanVdylan or
something.


<dylan-name-context>

  Specifies a context for name mangling. Calling make on this class
  returns a context specifying the dylan library and the internal module,
  but these can be overriden by supplying keyword arguments library: and
  module:, both with strings.


context-library dylan-name-context => string

  Returns the name of the library in this context as a string.


context-library-setter string dylan-name-context => string

  Sets the name of the library for this context.


context-module dylan-name-context => string

  Returns the name of the module in this context.


context-module-setter string dylan-name-context => string

  Sets the name of the module for this context.



9. Printing and Inspecting Dylan Objects.
-----------------------------------------


print-dylan-object debug-target remote-value
                   #key length level => string          [Generic Function]

  Attempts to interpret the remote-value as a dylan object and generates
  a string representation of it. Immediates and "standard" objects (such
  as strings and simple-object-vectors) will be given direct representations. 
  General instances might just be represented as [<SPAM>]. The DM will
  have special knowledge of (possibly a subset of) condition objects,
  and will print their formatted messages if possible.

  Printable representations of collection objects (and other instances whose
  representations are structured) can expand to an inappropriately large 
  size unless some limitations are specified. If 'length' is supplied, it 
  should be an integer specifying the maximum number of components that 
  should be printed for structured instances. (Eg, the maximum number of 
  elements of a collection. Collections with more than 'length' elements 
  would be printed with the excess elements replaced by an ellipsis).

  If 'level' is supplied, it should be an integer specifying the level
  of depth to which structured printing should proceed. Again, deeper 
  levels are abbreviated with an ellipsis. Eg #[1, 2, 3, #[1, 2], 4, 5]
  would be printed as such if 'level' were greater than 0. With 'level'
  equal to 0, the representation would be "#[1, 2, 3, #[...], 4, 5]".

  If the <remote-value> corresponds to a condition object in the runtime,
  the DM will attempt to generate the genuine formatted string by
  interpreting the condition's format-string and format-args. The
  DM only guarantees this for instances of <simple-warning>, <simple-error>
  and <simple-restart>.


decribe-dylan-object debug-target remote-value 
                    => class slots values repeats repeated-slot-name
                       repeated-slot-values
                                                        [Generic Function]

  [This is really only a convenience interface over get-inspector-values,
   and might not even be of use.]

  Attempts to interpret the remote-value as a dylan object and generates
  a full description of that object. The returned values are:

  class:  A <string> naming the class of the object.

  slots:  A sequence of <string>'s naming the slots in the object class.

  values: A sequence of <remote-value>'s representing the values of the
          slots. These last two results are parallel sequences.

  repeats:
          If the instance has a repeated slot, this will be an integer
          giving the number of repeats. Otherwise, this return value will
          be #f.

  repeated-slot-name:
          Unless 'repeats' is #f, this will be a string naming the 
          repeated slot.

  repeated-slot-values:
          Unless 'repeats' is #f, this will be a sequence of <remote-value>s
          giving the values in the repeated slot. The size of this
          sequence will be equal to 'repeats'. 


get-inspector-values debug-target remote-value => 
                               class slots getters setters 
                               repeats repeated-slot repeated-getter 
                               repeated-setter
                                                        [Generic Function]

  A lower-level function similar in behaviour to describe-dylan-object,
  but with return values as follows:

  class:   A <remote-value> representing the <class> that describes this
           dylan object.

  slots:   A sequence of <remote-value>s representing the slot descriptors
           for the class.

  getters: A sequence of functions (closures) capable of reading the
           value from the corresponding slot. Each function takes no
           arguments and returns a <remote-value>.

  setters: Another sequence of functions capable of setting the value
           of the corresponding slot. Each function takes a single
           <remote-value> (and also returns it), with the side-effect
           of inserting that <remote-value> into the slot.

  The three sequences are parallel, so getters[0] returns the value of
  slots[0], and setters[0] sets it etc...

  repeats: If the instance has no repeated slot, this value will be
           #f. Otherwise, it will be an integer specifying the
           number of repeated elements. (Note that this integer can
           still be zero, thus distinguishing between an instance
           that has no repeated slot, and an instance that does
           have one except there are currently no elements).

  repeated-slot:
           Unless 'repeats' is #f, this will be a <remote-value> giving
           the slot descriptor for the repeated slot. 

  repeated-getter: 
           Unless 'repeats' is #f, this will be a function of one
           integer argument (i) that returns a <remote-value>. When
           called with some value i (where 0 <= i < repeats), it
           returns the ith repeated element in the instance.
           If i is not in the specified range, this function will
           return #f.

  repeated-setter:
           Unless 'repeats' is #f, this will be a function of two
           arguments, an <integer> and a <remote-value>. When called
           with some integer i (where 0 <= i < repeats), and some
           remote-value v, sets the ith repeated element in the
           instance to v.
           If i is not in the specified range, this function will
           return #f.


dylan-object? debug-target remote-value => boolean

  Probes the object represented by remote-value and tries to deduce
  whether it is a valid Dylan object. Returns #t if the remote-value
  is (apparently) a Dylan object, otherwise returns #f.



9-and-a-bit. Mapping Between Symbolic Names and Objects.
--------------------------------------------------------


resolve-dylan-name debug-target string dylan-name-context 
                   #key indirect? => value, address

  Mangles "string" according to the supplied name context and performs
  a symbol search for the mangled name. 

  Two values are returned: the value associated with the name, and the
  address associated with the name. If the lookup fails, both return
  values will be #f. Otherwise, the _second_ return value is guaranteed
  to be a valid <remote-value>, though the first may still be #f.

  If 'indirect?:' is #t, the DM will attempt to resolve the dylan name
  to a symbol. If the symbol is found, the DM will read a value from the
  symbol's address. The value and the address that was indirected through
  are both returned. Note that the if the DM, for whatever reason, cannot
  read the value from the address, it will return #f as the value. (Although
  it will still return the address).

  If 'indirect?:' is #f, the DM will attempt to resolve the dylan name
  to an address. It also assumes this address to be the value, and does
  not perform an indirection. If the symbol is found, it just returns
  the address twice.

  If you are not interested in the address of a symbol, you can ignore the
  second return value.

  Console debugger note: The console debugger needs the second 'address'
                         return value in order to set variables with
                         values.


resolve-dylan-keyword debug-target string => remote-value

  Finds the address of a keyword (global symbol) in the runtime. The
  string is the name of the keyword, without any syntactic baggage
  (ie, 'spam' rather than 'spam:' or '#"spam"'). The DM will canonicalize
  any mixture of character case in the string, and search for the
  address of the keyword given the current state of the runtime's
  symbol dictionary.

  This function will return #f if the keyword is not found.


find-dylan-name debug-target remote-value => string dylan-name-context
                                             precise?

  Searches for a symbol whose definition is at (or close to) the
  given <remote-value>. 

  Return values:

  string - The demangled name of the symbol that was found.

  dylan-name-context - A <dylan-name-context> giving the name's library
                       and module. (This will have been generated from
                       the stripped-off qualifiers during demangling).

  precise? - Will be #t if the symbol's address _exactly_ matched
             remote-value, otherwise #f.


find-closest-symbolic-name debug-target remote-value
             => false-or(remote-symbol), precise?

  Given a <remote-value> instance, attempts to locate the <remote-symbol>
  object whose definition is at or close to that address. The first
  return value will be that symbol, or #f if no symbol could be found.

  The second return value will be #t if the symbol's definition
  precisely matches the supplied address, and #f otherwise.

  Note the use of the term 'symbolic' rather than 'mangled' in this
  function. There is no guarantee that the remote-value supplied is
  even a dylan object, or that the symbol that defines it is a 
  dylan-emitted symbol. If any symbolic definition can be found, it
  will be returned.

  The source of symbolic information will be the access-path, in
  combination with whatever mechanism we implement for describing
  interactively (re-)defined symbols.


resolve-symbolic-name debug-target string => false-or(remote-value)

  Attempts to match the supplied name against symbolic information in the
  runtime. If a match is made, the address of the name's definition
  is returned as the result.

  #f will be returned if no matching symbol can be found.

  Again, the source of information will be the access-path, in
  combination with whatever mechanism we implement for describing
  interactively (re-)defined symbols.


dylan-object-class-symbol debug-target remote-value
      => false-or(remote-symbol), immediate

  Examines the supplied <remote-value> and attempts to return a
  <remote-symbol> being the symbolic description of the object's class.
  This symbol's name can be passed into the compiler, hopefully in
  exchange for a model object. This saves the need to get the class as
  a <remote-value> first, and then call find-closest-symbolic-name to
  get the symbol.

  Given the availability of symbolic information, and that the object
  supplied is a dylan object whose class was built statically, this
  function is guaranteed to return a valid <remote-symbol>, regardless
  of any runtime tagging scheme.

  The source of symbolic information will be the access-path in concert
  with the interactive symbol table.

  The second return value will be a boolean flag indicating whether the
  object is some kind of immediate value, that could be uploaded by
  the DM API "dylan-object-immediate-value" (Chapter 10).


10. Convenience Interfaces for Dylan Objects.
---------------------------------------------

The general inspector interface can be used to look up all attributes of
any arbitrary dylan object. However, the DM has special knowledge of
the dylan runtime, and is able to deduce information about certain
'standard' objects, saving clients the trouble of calculating with the
inspector values. Function and class objects are good examples, though
we may introduce more and more of these convenience accessors as
time goes on.


dylan-generic-function-methods debug-target remote-value => sequence

  Given that remote-value is a remote instance of a generic function,
  returns a sequence of <remote-value>s that are remote instances of
  the methods of that generic function.


dylan-method-iep debug-target remote-value => remote-value

  Given that remote-value is a remote instance of a method object
  (perhaps obtained by a call to dylan-generic-function-methods),
  returns a <remote-value> that holds the IEP of that method.


dylan-method-specializers debug-target remote-value => sequence

  Given that remote-value is a remote instance of a method object,
  returns a sequence of <remote-value>s that are remote instances
  of <type>.


dylan-slot-descriptor-getter debug-target remote-value => remote-value

  Given that remote-value is any remote instance of a slot descriptor,
  this function returns the getter (a remote instance of <function>)
  as a <remote-value>. (Slot descriptors are returned from a call to
  get-inspector-values. The "name" of a slot is effectively the name of
  its getter, obtained via this function. The getter can be passed
  to 'find-dylan-name' for a name).


remote-instance? debug-target remote-value remote-value => boolean

  Returns #t if both <remote-value>s are dylan objects, and the
  first is an instance of the second. Any <remote-value>s corresponding
  to statically built objects can be used as valid arguments to this
  function. However, if a <remote-value> is _not_ known to be statically
  built, the DM client is required to have that object registered, and
  to lookup the tracked value before calling this function.

  The implementation of this function may involve the execution of
  code in the runtime. However, calling it does not end a debugger
  transaction.


dylan-value-unbound? debug-target remote-value => boolean

  Returns #t if the supplied <remote-value> corresponds to the runtime's
  canonical UNBOUND marker. Otherwise, returns #f.


dylan-object-immediate-value debug-target remote-value => object valid?

  If the supplied <remote-value> is an "uploadable immediate", such as
  a tagged integer or character, this function returns an
  environment-side replica of the runtime value.

  Note the second <boolean> return value. We cannot just use #f as a
  failure value in this case, since it's conceivable that #f could be
  an uploaded immediate, if booleans were tagged. Hence, the second
  return value flags whether the replica was successfully generated.

  Note that, even if the object can be uploaded to a replica, there is
  no guarantee that the precise type of the uploaded object will
  correspond to the type of the runtime object. For example, an
  <integer> in the runtime might get uploaded to an <extended-integer>
  in the environment.



11. Debugger Transactions and Remote Object Registration.
---------------------------------------------------------

After devel, some more will be said about debugger transactions and
remote object registration. For now, suffice it to say that a debugger
transaction is in effect from the instant the application stops
(for any reason) until the instant that it resumes. During this period,
any <remote-value>s collected from the application remain valid.
Between debugger transactions, objects can be relocated, so there is
no guarantee that a <remote-value> that pointed to object X before
still points to object X.

In terms of the DM interface described thus far, <remote-value>s
remain valid up until an activation of the ready-to-continue-callback
terminates. This callback is therefore a good place to register them
as remote objects via the mechanism described below.

In order for a handle on an object to persist between debugger transactions,
it must be "registered". This is a facility that will be provided by
the Spy, with an interface to it being provided by the DM.


<remote-object>

  Represents a persistent handle on an object within the running application.
  Unlike instances of <remote-value>, instances of <remote-object>
  remain valid between debugger transactions.
 

register-remote-object debug-target remote-value 
                       #key finalize = #t, weak => remote-object

  Informs the Spy that the debugger now requires the object specified by
  remote-value is to be tracked. The return value is an instance of
  <remote-object> which can be used to obtain the object's value even
  if it is relocated.

  This mechanism is implemented by creating a new reference to the
  object _within_ the application (so that it will be kept current by
  the garbage collector) using functionality provided by the Spy.

  If "finalize" is true (the default), then the reference will be
  implicitly freed by finalization when the development environment
  reclaims the remote object handle. If "finalize" is #f, the overhead
  for registration may be lower, but a memory leak will result unless
  the UI explicitly frees the handle (via free-remote-object).

  Normally, while a remote value is registered, the remote garbage
  collector will be prevented from condemning the remote value in any
  way that causes the object to be "lost". However, if "weak" is true,
  then the implementation is permitted to reference the remote value
  weakly, and to garbage collect it if there are no references within
  the running application itself. If the weakly registered object does
  get collected, subsequent calls to remote-object-value will return
  #f.


free-remote-object debug-target remote-object => ()

  Informs the Spy that the debugger no longer needs this <remote-object>
  to be tracked. Instances of <remote-object> become invalid once passed
  to this function.


remote-object-valid? debug-target remote-object => boolean

  This will return #t if the <remote-object> is still mappable onto a
  valid <remote-value>. A return value of #f will be obtained if:

  1. The remote-object was freed with free-remote-object.

  2. The remote-object was registered weakly, and the remote instance
     has since been garbage collected by the application.


remote-object-value debug-target remote-object => remote-value

  Maps a remote-object onto its remote-value.


<object-registration-error>                                       [Class]

  A subclass of <error>. An instance of this can be signalled by
  register-remote-object if, for instance, the Spy does not support remote
  object registration.


 
12. Stack Backtracing.
----------------------

Provides functionality for modelling the stack in a running Dylan application.


<application-stack-frame>                            [Abstract Sealed Class]

  A subclass of <object>. Represents a stack frame of any kind within the
  application. (In the future, we might want to consider making this an
  open class so that clients of the DM can describe their own weird and
  wonderful stack frames.) 


first-stack-frame debug-target remote-thread => application-stack-frame

  Returns the frame at the top of the stack in the running application,
  regardless of its type.


next-stack-frame debug-target application-stack-frame
                     => application-stack-frame          [Generic Function]
 
  Given a stack frame, returns the next most recent stack frame, regardless
  of its type. Returns #f if there is no next frame.


previous-stack-frame debug-target application-stack-frame
                         => application-stack-frame      [Generic Function]  

  Given a stack frame, returns the next oldest stack frame, regardless of
  its type. Returns #f if there is no previous frame.


<dylan-stack-frame-mixin>                                  [Abstract Class]

  A subclass of <object>. This is a superclass of any Dylan stack frame.


<call-frame>                                               [Abstract Class]

  A subclass of <application-stack-frame>. This is a stack frame that 
  corresponds to a function call.


call-frame-return-address debug-target call-frame => remote-value

  Returns the call-frame's return address as a <remote-value>


call-frame-frame-pointer debug-target call-frame => remote-value

  Returns the call-frame's frame pointer as a <remote-value>


call-frame-instruction-pointer debug-target call-frame => remote-value

  Returns the call-frame's instruction pointer (PC) as a
  <remote-value>


call-frame-nearest-source-locator debug-target call-frame 
                                      => #f or source-locator

  If possible, returns the nearest known source location to the instruction
  pointer for the given call frame. If the frame is not precisely
  aligned at a source locator, this function can be used by the UI to
  find the nearest relevant piece of source to indicate as being
  "current". 


call-frame-aligned-at-source-locator? debug-target call-frame
                                        => #f or source-locator
                                                       [Generic Function]

  If the program counter for this call frame corresponds exactly
  to a known source code location, then this function returns the
  locator.

  If this function returns #f, then the instruction pointer is not
  at a known source code location. The function align-thread-to-source-location
  can be used to attempt alignment. If alignment succeeds, it is not
  guaranteed that the destination source locator will be the same as that
  returned beforehand by call-frame-nearest-source-locator.


call-frame-function debug-target call-frame => remote-symbol function-model
                                                       [Generic Function]

  Returns a <remote-symbol> that describes the function being called in
  this frame. This function might return #f if, for example, there is
  not sufficient symbolic debugging information.

  The second return value will be #f for any non-dylan frame, and also
  for dylan frames where the called function has no current model
  in the compiler (eg. it's a closure, or a function from another
  project). Otherwise, the second return value will be a compiler
  model for the lambda being called in this frame. This model will have
  stored the correct (non-mangled) name for the function, as well as
  further information such as specializers.


number-of-lexical-variables debug-target call-frame => integer

  Returns the number of lexical variables active inside the call
  frame. Performance note: this function scans for the existance of
  live lexical variables without reading in names/addresses over
  the tether. If it turns out that performance is not effected too much
  by reading names and addresses straight away, we can ditch this
  function.

  Note: this has nothing to do with Dylan. The integer returned will
        be the same as the number of elements in the sequence(s)
        returned by live-frame-lexical-variables NOT
        active-dylan-lexical-variables.


active-dylan-lexical-variables debug-target call-frame => variables values

  Presents the compiler's view of the set of live lexicals for the
  given <call-frame>.

  The first return value is a sequence of lexical variable model objects.

  The second return value is a sequence parallel to the first. Each
  element either contains a <remote-value> - the value of the corresponding
  variable (in the first sequence), or #f - meaning that this variable
  is not live. By 'not live' we mean not live according to the debug
  information dump. It's entirely possible that dylan variables may be
  lexically in scope, while not having obtainable values in the runtime.
  (For example, their stack space may have been optimized away, or used
  for something else).


live-frame-lexical-variables debug-target call-frame => variables values

  Presents the runtime's view of the set of live lexicals for the
  given <call-frame>.

  The first return value is a sequence of <lexical-variable> objects
  representing the lexical variables that are 'live' in the given
  call frame. This information comes ultimately from the dumped debugging
  information.

  The second return value is a parallel sequence of <remote-value>
  objects giving the values of the variables.

  This is basically just a lower-level API than active-dylan-lexical-variables,
  assumed to be useful for frames running foreign code, and also frames
  running dylan code outside of the current project.


<dylan-call-frame>                                                 [Class]

  A subclass of <call-frame> and <dylan-stack-frame-mixin>. Represents
  a frame corresponding to the activation of a Dylan function.


<implementation-stack-frame>                              [Abstract Class]

  A subclass of <application-stack-frame> and <dylan-stack-frame-mixin>.
  Represents a "special" Dylan stack frame - not a call frame.


<bind-exit-frame>                                                  [Class] 

  A subclass of <implementation-stack-frame>. A frame corresponding to
  the Dylan block (exit) ... end construct.

  [In practice, it may not even be possible to detect bind-exit frames...]


<unwind-protect-frame>                                             [Class]

  A subclass of <implementation-stack-frame>. Corresponds to a block
  construct with a cleanup.


<dynamic-bind-frame>                                               [Class] 

  A subclass of <unwind-protect-frame>.

  [In practice, it may not be possible to differentiate between
   dynamic-bind frames and unwind-protect frames]


Note, more accessors may be needed to get at information specific to the
various types of frame.



13. Restarts
------------

This section documents the APIs via which the debugger can determine
which restarts are available, and also signal a restart on a thread.


<remote-restart>                                                  [Class]

  A debugger-level abstract handle onto a restart. This is the object
  used to model restarts in the runtime.


remote-restart-description remote-restart => string            [Function]

  Returns a string describing the expected behaviour of the restart.


(Issue: what else do we need to model about a restart?)


available-restarts-for-thread debug-target remote-thread => sequence

  Examines the dynamic environment of the thread in order to generate
  a sequence of available restarts. Each member of the returned
  sequence is an instance of <remote-restart>.

 
signal-restart-on-thread debug-target remote-thread restart => ()

  Instructs the DM that the specified thread should, upon completion
  of the current debugger transaction, continue by signalling the
  specified restart (a <remote-restart>).



14. Source Level Stepping
-------------------------

These functions may only be called during a debugger transaction, and
they do not cause the application to immediately run. In each case,
the step operation occurs on the specified thread as soon as that thread
resumes.

All of these functions register specialized breakpoints. They may also
do some substantial low-level examination of the runtime, even down
to machine code instructions. (The end of chapter 7 describes the various
kinds of specialized breakpoints that the DM implements for source
location stepping). The breakpoints will be signalled later, when the
thread reaches the destination source location.

Upon calling one of these functions, the DM attempts to calculate
the destination <source-locator> for the step. There may be several
possibilties (for example, the entry points of all methods when a
generic function is being called). If the DM fails to calculate
any possible destination, it will return #f as the success code
from these functions. Otherwise, #t is returned.  (The most likely
cause of failure would be a lack of linenumber information in the
debug info format). Clients of DM should not expect any specialized
breakpoints to be signalled following a #f result from one of these
functions.

However, these functions may work even in the absence of debug
information - just don't rely on obtaining a <source-locator> for
the destination when the thread arrives there! (Step-out, for
example, can break the frame's return address regardless of whether
that address is a known source location).

These functions should be considered analagous to register-debug-point
(since that is what they end up doing!), hence the need for the
callback argument. The callbacks should be of the same signature as
those passed to register-debug-point.


instruct-thread-to-step-over debug-target remote-thread callback 
                                         => succeeded?

  Arranges for the thread to step to the next source location
  within the execution of this function frame (ie, stepping
  over function invocations).

  If the thread does not reach another source location within
  the execution of this function, then this will behave like a
  step-out operation instead.

  The thread will later signal a <step-completed-breakpoint>
  or a <nlx-step-breakpoint> if this function returns #t.


instruct-thread-to-step-into debug-target remote-thread callback 
                                         => succeeded?

  Arranges for the thread to step into a function.

  If the thread is not positioned exactly at a function call,
  this will behave like a step-over operation instead.

  The thread will later signal a <step-completed-breakpoint> or
  a <nlx-step-breakpoint> if this function returns #t.


instruct-thread-to-step-out debug-target remote-thread callback 
                                         => succeeded?

  Arranges for the thread to step out of its current function frame.

  The thread will later signal a <step-completed-breakpoint> or
  a <nlx-step-breakpoint> if this function returns #t.


align-thread-to-source-location debug-target remote-thread callback
                                         => succeeded?

  Attempts to align the program counter of this thread to a
  known source location.

  The thread will later signal a <source-aligned-breakpoint> or
  a <nlx-step-breakpoint> if this function returns #t.


Note that all four of these functions cause breakpoints to be implicitly
registered. This means that <debug-point-error> may conceivably be
signalled during their operation (see chapter 7). They do not handle
this error, so clients should arrange to handle it themselves.

Note also that none of these functions accept <call-frame> arguments.
Stepping implicitly acts upon the active (topmost) call frame for the
specified thread. Stepping through the activations of other frames
is not supported by the DM at this point, though it may be in the future.

These functions should work in foreign code as well, given that
sufficient debugging information is available for the source locators.

Entering a debugger transaction causes ANY stepping breakpoints that
were set (by the thread signalling the breakpoint) to be swept up,
thus invalidating any step operation being undertaken by that thread. 
For example, a user-visible breakpoint may have been encountered before the 
destination source locator. Presumably we want to service this breakpoint 
and forget about any step operation that we were half-way through. This does 
not imply that ANY breakpoint event invalidates a step operation, of course.
If a breakpoint does not ask for a debugger transaction to begin
(as is the case if its callback runs and returns #f), then the step
operation remains in force. This would mean that stepping and tracing
need not interfere with each other.

Here are some scenarios which illustrate this, based on the following
fragment of code (which, I must stress, is not taken from the DM
implementation!):

01: define method do-all-dollops (x) => ()
02:   do-first-dollop(x);
03:   do-second-dollop(x);
04:   do-third-dollop(x);
05:   do-fourth-dollop(x);
06:   if (~consolidate-dollops(x))
07:     signal(make(<failed-to-consolidate-dollops-error>));
08:   end if;
09: end method;
...
...
50: block ()
51:   initialize-all-dollops();
52:   do-all-dollops(*dollop-descriptor*);
53:   format-out("Did dollops\n");
54: exception (e :: <failed-to-consolidate-dollops-error>)
55:   format-out("Dollops failed\n");
56: end block; 


1. The current location is 03, and the user has placed a breakpoint on 05.
   step-into would step into do-second-dollop,
   step-over would step to 04,
   step-out would stop at 05, and abandon the step

2. The current location is 03, and the user is tracing do-third-dollop.
   step-into would step into do-second-dollop,
   step-over would step to 04,
   step-out would step out to 53 (assuming that dollops are successfully
      consolidated). There would also be trace output for do-third-dollop.
      The trace has not caused the step to be abandoned.



15. Mappings Between Addresses and Runtime Source Forms.
--------------------------------------------------------

For dylan projects, objects can be mapped to the source code fragments
that defined them. These mappings expect a compilation context as their
initial argument. Hence, it does not make sense to call these functions
on foreign objects.


compiler-to-runtime-object execution-context runtime-source-form
     => false-or(runtime-object)

  Within the given execution context, attempts to locate a live object
  in the runtime that corresponds to the given form in the source code.
  If such a live object can be found, it is returned as a <remote-value>.
  If no such object can be found, this will return #f.


runtime-to-compiler-object execution-context remote-value
     => false-or(runtime-source-form)

  Within the given execution context, attempts to find a form in the
  source code that corresponds to the given object in the runtime.
  Returns #f if the mapping does not succeed.



16. Mappings Between Addresses and Source Locators.
---------------------------------------------------

This is a high-level abstraction for mapping locations in source code
to instruction addresses in the runtime, for the purpose of inspecting
local variables, or setting breakpoints etc. These functions are defined
to work from whatever information is available to the DM, either from
the Dylan compiler (if applicable), or from source location information
within the runtime (if available). These two APIs represent a unified
interface to these two sources of information.


remote-address-source-location debug-target remote-value
                               #key exact?, line-only?, interactive-only?
    => false-or(source-locator)

  Attempts to map an instruction address in the runtime to a location
  in source code.


source-location-remote-address debug-target source-locator,
                               #key exact?, line-only?, interactive-only?
    => false-or(source-locator)

  Attempts to map a location in source code to an instruction address
  in the runtime.


The keyword arguments are interpreted as follows for both mappings:

  line-only?:        Only use the max-one-per-line set of recorded source
                     location points for the mapping. 

  interactive-only?: Only use the set of recorded "interactive" source
                     location points for the mapping.

  exact?:            Only assume the mapping to be satisfactory if there
                     is a precise correspondance from the source location
                     to the address. (Otherwise, any "close" mapping will
                     be considered a success).

All source-locators are described using the canonical class in the
source-records library, however that is currently defined.

Note that <source-location> objects may be stored persistently. If the
environment wishes to remember the locations of breakpoints between runs of
the application, then it should keep a set of <source-location> objects.
These can be mapped as breakpoints via the DM when the application is
started.

The DM makes the following guarantees:

  1. It will map source locations via the compiler in preference to via
     the runtime.

  2. The mapping via the compiler uses the same set of source-locations
     as is available via the API between the compiler and the environment.

The implication of these two guarantees is that the DM will always find
an exact mapping for any source-location retrieved via
"definition-code-locations", given the same values of 'line-only?' and
'interactive-only?'


Further Points:

  1. Source locations obtained from runtime data will be standard
     <source-location>s in standard source records. This will require
     extending the source record protocol to handle random (foreign)
     files.

  2. Source locations obtained from runtime data are necessarily not
     considered to be interactive.



17. Foreign Code Debugging.
---------------------------

This chapter will be fleshed out when we have a solid story for debugging
foreign code. At the moment:


foreign-object-type debug-target remote-value => false-or(remote-type)

  Returns, if possible, a <remote-type> (defined in access-path) that
  describes the supplied object. This function cannot guarantee to
  return a <remote-type>, and will return #f if no type description can
  be obtained.

  Status note: This is not implemented yet, and will just return #f.



18. Managing Dynamic Libraries.
-------------------------------

The debug target is likely to contain various shared libraries (DLLs on
Windows). These may contain foreign code or dylan code. If they contain
dylan code, then the may house the code for one or more dylan-level
libraries. 


dylan-library-initialized? debug-target remote-library => boolean

  If the given <remote-library> houses dylan code, and all of the
  dylan-level initializations have taken place, this function will
  return #t. Otherwise, it will return #f.

  This is important when browsing via runtime data. The values of
  symbols, if they are defined in uninitialized libraries, cannot
  be relied upon, and should not be passed to any of the printing
  or accessor APIs.


Issue: We need something that maps <remote-library> to (possibly a
       sequence of) dylan-level libraries. We also need a representation
       for the latter, though maybe that could just be <symbol>.

       eg  {instance of <remote-library>} 
              --> #[#"dylan", #"functional-extensions", #"streams", ...]

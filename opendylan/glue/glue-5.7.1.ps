%!PS-Adobe-3.0
%%BoundingBox: (atend)
%%Pages: (atend)
%%PageOrder: (atend)
%%DocumentFonts: (atend)
%%Creator: Frame 4.0
%%DocumentData: Clean7Bit
%%EndComments
%%BeginProlog
%
% Frame ps_prolog 4.0, for use with Frame 4.0 products
% This ps_prolog file is Copyright (c) 1986-1993 Frame Technology
% Corporation.  All rights reserved.  This ps_prolog file may be
% freely copied and distributed in conjunction with documents created
% using FrameMaker, FrameBuilder and FrameViewer as long as this 
% copyright notice is preserved.
%
% Frame products normally print colors as their true color on a color printer
% or as shades of gray, based on luminance, on a black-and white printer. The
% following flag, if set to True, forces all non-white colors to print as pure
% black. This has no effect on bitmap images.
/FMPrintAllColorsAsBlack             false def
%
% Frame products can either set their own line screens or use a printer's 
% default settings. Three flags below control this separately for no 
% separations, spot separations and process separations. If a flag
% is true, then the default printer settings will not be changed. If it is
% false, Frame products will use their own settings from a table based on
% the printer's resolution.
/FMUseDefaultNoSeparationScreen      true  def
/FMUseDefaultSpotSeparationScreen    true  def
/FMUseDefaultProcessSeparationScreen false def
%
% For any given PostScript printer resolution, Frame products have two sets of 
% screen angles and frequencies for printing process separations, which are 
% recomended by Adobe. The following variable chooses the higher frequencies
% when set to true or the lower frequencies when set to false. This is only
% effective if the appropriate FMUseDefault...SeparationScreen flag is false.
/FMUseHighFrequencyScreens true def
%
% PostScript Level 2 printers contain an "Accurate Screens" feature which can
% improve process separation rendering at the expense of compute time. This 
% flag is ignored by PostScript Level 1 printers.
/FMUseAcccurateScreens true def
%
% The following PostScript procedure defines the spot function that Frame
% products will use for process separations. You may un-comment-out one of
% the alternative functions below, or use your own.
%
% Dot function
/FMSpotFunction {abs exch abs 2 copy add 1 gt 
		{1 sub dup mul exch 1 sub dup mul add 1 sub }
		{dup mul exch dup mul add 1 exch sub }ifelse } def
%
% Line function
% /FMSpotFunction { pop } def
%
% Elipse function
% /FMSpotFunction { dup 5 mul 8 div mul exch dup mul exch add 
%		sqrt 1 exch sub } def
%
%
/FMversion (4.0) def 
/FMLevel1 /languagelevel where {pop languagelevel} {1} ifelse 2 lt def
/FMPColor
	FMLevel1 {
		false
		/colorimage where {pop pop true} if
	} {
		true
	} ifelse
def
/FrameDict 400 dict def 
systemdict /errordict known not {/errordict 10 dict def
		errordict /rangecheck {stop} put} if
% The readline in PS 23.0 doesn't recognize cr's as nl's on AppleTalk
FrameDict /tmprangecheck errordict /rangecheck get put 
errordict /rangecheck {FrameDict /bug true put} put 
FrameDict /bug false put 
mark 
% Some PS machines read past the CR, so keep the following 3 lines together!
currentfile 5 string readline
00
0000000000
cleartomark 
errordict /rangecheck FrameDict /tmprangecheck get put 
FrameDict /bug get { 
	/readline {
		/gstring exch def
		/gfile exch def
		/gindex 0 def
		{
			gfile read pop 
			dup 10 eq {exit} if 
			dup 13 eq {exit} if 
			gstring exch gindex exch put 
			/gindex gindex 1 add def 
		} loop
		pop 
		gstring 0 gindex getinterval true 
		} bind def
	} if
/FMshowpage /showpage load def
/FMquit /quit load def
/FMFAILURE { 
	dup = flush 
	FMshowpage 
	/Helvetica findfont 12 scalefont setfont
	72 200 moveto
	show FMshowpage 
	FMquit 
	} def 
/FMVERSION {
	FMversion ne {
		(Frame product version does not match ps_prolog!) FMFAILURE
		} if
	} def 
/FMBADEPSF { 
	(PostScript Lang. Ref. Man., 2nd Ed., H.2.4 says EPS must not call X              )
	dup dup (X) search pop exch pop exch pop length 
	4 -1 roll 
	putinterval 
	FMFAILURE
	} def
/FMLOCAL {
	FrameDict begin
	0 def 
	end 
	} def 
/concatprocs
	{
	/proc2 exch cvlit def/proc1 exch cvlit def/newproc proc1 length proc2 length add array def
	newproc 0 proc1 putinterval newproc proc1 length proc2 putinterval newproc cvx
}def
FrameDict begin 
/FMnone 0 def
/FMcyan 1 def
/FMmagenta 2 def
/FMyellow 3 def
/FMblack 4 def
/FMcustom 5 def
/FrameNegative false def 
/FrameSepIs FMnone def 
/FrameSepBlack 0 def
/FrameSepYellow 0 def
/FrameSepMagenta 0 def
/FrameSepCyan 0 def
/FrameSepRed 1 def
/FrameSepGreen 1 def
/FrameSepBlue 1 def
/FrameCurGray 1 def
/FrameCurPat null def
/FrameCurColors [ 0 0 0 1 0 0 0 ] def 
/FrameColorEpsilon .001 def	
/eqepsilon {		
	sub dup 0 lt {neg} if
	FrameColorEpsilon le
} bind def
/FrameCmpColorsCMYK { 
	2 copy 0 get exch 0 get eqepsilon {
		2 copy 1 get exch 1 get eqepsilon {
			2 copy 2 get exch 2 get eqepsilon {
				3 get exch 3 get eqepsilon
			} {pop pop false} ifelse
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/FrameCmpColorsRGB { 
	2 copy 4 get exch 0 get eqepsilon {
		2 copy 5 get exch 1 get eqepsilon {
			6 get exch 2 get eqepsilon
		}{pop pop false} ifelse
	} {pop pop false} ifelse
} bind def
/RGBtoCMYK { 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	1 exch sub 
	3 1 roll 
	3 copy 
	2 copy 
	le { pop } { exch pop } ifelse 
	2 copy 
	le { pop } { exch pop } ifelse 
	dup dup dup 
	6 1 roll 
	4 1 roll 
	7 1 roll 
	sub 
	6 1 roll 
	sub 
	5 1 roll 
	sub 
	4 1 roll 
} bind def
/CMYKtoRGB { 
	dup dup 4 -1 roll add 						  
	5 1 roll 3 -1 roll add 						  
	4 1 roll add 								  
	1 exch sub dup 0 lt {pop 0} if 3 1 roll 	  
	1 exch sub dup 0 lt {pop 0} if exch 	      
	1 exch sub dup 0 lt {pop 0} if exch	  		  
} bind def
/FrameSepInit {
	1.0 RealSetgray
} bind def
/FrameSetSepColor { 
	/FrameSepBlue exch def
	/FrameSepGreen exch def
	/FrameSepRed exch def
	/FrameSepBlack exch def
	/FrameSepYellow exch def
	/FrameSepMagenta exch def
	/FrameSepCyan exch def
	/FrameSepIs FMcustom def
	setCurrentScreen	
} bind def
/FrameSetCyan {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 1.0 def
	/FrameSepIs FMcyan def
	setCurrentScreen	
} bind def
 
/FrameSetMagenta {
	/FrameSepBlue 1.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 1.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMmagenta def
	setCurrentScreen
} bind def
 
/FrameSetYellow {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 1.0 def
	/FrameSepRed 1.0 def
	/FrameSepBlack 0.0 def
	/FrameSepYellow 1.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMyellow def
	setCurrentScreen
} bind def
 
/FrameSetBlack {
	/FrameSepBlue 0.0 def
	/FrameSepGreen 0.0 def
	/FrameSepRed 0.0 def
	/FrameSepBlack 1.0 def
	/FrameSepYellow 0.0 def
	/FrameSepMagenta 0.0 def
	/FrameSepCyan 0.0 def
	/FrameSepIs FMblack def
	setCurrentScreen
} bind def
 
/FrameNoSep { 
	/FrameSepIs FMnone def
	setCurrentScreen
} bind def
/FrameSetSepColors { 
	FrameDict begin
	[ exch 1 add 1 roll ]
	/FrameSepColors  
	exch def end
	} bind def
/FrameColorInSepListCMYK { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsCMYK 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/FrameColorInSepListRGB { 
	FrameSepColors {  
       		exch dup 3 -1 roll 
       		FrameCmpColorsRGB 
       		{ pop true exit } if
    	} forall 
	dup true ne {pop false} if
	} bind def
/RealSetgray /setgray load def
/RealSetrgbcolor /setrgbcolor load def
/RealSethsbcolor /sethsbcolor load def
end 
/setgray { 
	FrameDict begin
	FrameSepIs FMnone eq
		{ RealSetgray } 
		{ 
		FrameSepIs FMblack eq 
			{ RealSetgray } 
			{ FrameSepIs FMcustom eq 
			  FrameSepRed 0 eq and
			  FrameSepGreen 0 eq and
			  FrameSepBlue 0 eq and {
			  	RealSetgray
			  } {
				1 RealSetgray pop 
			  } ifelse
			} ifelse
		} ifelse
	end
} bind def
/setrgbcolor { 
	FrameDict begin
	FrameSepIs FMnone eq
	{  RealSetrgbcolor }
	{
		3 copy [ 4 1 roll ] 
		FrameColorInSepListRGB
		{
				FrameSepBlue eq exch 
			 	FrameSepGreen eq and exch 
			 	FrameSepRed eq and
			 	{ 0 } { 1 } ifelse
		}
		{
			FMPColor {
				RealSetrgbcolor
				currentcmykcolor
			} {
				RGBtoCMYK
			} ifelse
			FrameSepIs FMblack eq
			{1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		RealSetgray
	} 
	ifelse
	end
} bind def
/sethsbcolor {
	FrameDict begin
	FrameSepIs FMnone eq 
	{ RealSethsbcolor } 
	{
		RealSethsbcolor 
		currentrgbcolor  
		setrgbcolor 
	} 
	ifelse
	end
} bind def
FrameDict begin
/setcmykcolor where {
	pop /RealSetcmykcolor /setcmykcolor load def
} {
	/RealSetcmykcolor {
		4 1 roll
		3 { 3 index add 0 max 1 min 1 exch sub 3 1 roll} repeat 
		setrgbcolor pop
	} bind def
} ifelse
userdict /setcmykcolor { 
		FrameDict begin
		FrameSepIs FMnone eq
		{ RealSetcmykcolor } 
		{
			4 copy [ 5 1 roll ]
			FrameColorInSepListCMYK
			{
				FrameSepBlack eq exch 
				FrameSepYellow eq and exch 
				FrameSepMagenta eq and exch 
				FrameSepCyan eq and 
				{ 0 } { 1 } ifelse
			}
			{
				FrameSepIs FMblack eq
				{1.0 exch sub 4 1 roll pop pop pop} {
				FrameSepIs FMyellow eq
				{pop 1.0 exch sub 3 1 roll pop pop} {
				FrameSepIs FMmagenta eq
				{pop pop 1.0 exch sub exch pop } {
				FrameSepIs FMcyan eq
				{pop pop pop 1.0 exch sub } 
				{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
			} ifelse
			RealSetgray
		}
		ifelse
		end
	} bind put
FMLevel1 not { 
	
	/patProcDict 5 dict dup begin
		<0f1e3c78f0e1c387> { 3 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<0f87c3e1f0783c1e> { 3 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
		<8142241818244281> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke
											-1 -1 moveto 9 9 lineto stroke } bind def
		<03060c183060c081> { 1 setlinewidth -1 -1 moveto 9 9 lineto stroke 
											4 -4 moveto 12 4 lineto stroke
											-4 4 moveto 4 12 lineto stroke} bind def
		<8040201008040201> { 1 setlinewidth -1 9 moveto 9 -1 lineto stroke 
											-4 4 moveto 4 -4 lineto stroke
											4 12 moveto 12 4 lineto stroke} bind def
	end def
	/patDict 15 dict dup begin
		/PatternType 1 def		
		/PaintType 2 def		
		/TilingType 3 def		
		/BBox [ 0 0 8 8 ] def 	
		/XStep 8 def			
		/YStep 8 def			
		/PaintProc {
			begin
			patProcDict bstring known {
				patProcDict bstring get exec
			} {
				8 8 true [1 0 0 -1 0 8] bstring imagemask
			} ifelse
			end
		} bind def
	end def
} if
/combineColor {
    FrameSepIs FMnone eq
	{
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceCMYK]] setcolorspace
			FrameCurColors 0 4 getinterval aload pop FrameCurPat setcolor
		} {
			FrameCurColors 3 get 1.0 ge {
				FrameCurGray RealSetgray
			} {
				FMPColor graymode and {
					0 1 3 { 
						FrameCurColors exch get
						1 FrameCurGray sub mul
					} for
					RealSetcmykcolor
				} {
					4 1 6 {
						FrameCurColors exch get
						graymode {
							1 exch sub 1 FrameCurGray sub mul 1 exch sub
						} {
							1.0 lt {FrameCurGray} {1} ifelse
						} ifelse
					} for
					RealSetrgbcolor
				} ifelse
			} ifelse
		} ifelse
	} { 
		FrameCurColors 0 4 getinterval aload
		FrameColorInSepListCMYK {
			FrameSepBlack eq exch 
			FrameSepYellow eq and exch 
			FrameSepMagenta eq and exch 
			FrameSepCyan eq and
			FrameSepIs FMcustom eq and
			{ FrameCurGray } { 1 } ifelse
		} {
			FrameSepIs FMblack eq
			{FrameCurGray 1.0 exch sub mul 1.0 exch sub 4 1 roll pop pop pop} {
			FrameSepIs FMyellow eq
			{pop FrameCurGray 1.0 exch sub mul 1.0 exch sub 3 1 roll pop pop} {
			FrameSepIs FMmagenta eq
			{pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub exch pop } {
			FrameSepIs FMcyan eq
			{pop pop pop FrameCurGray 1.0 exch sub mul 1.0 exch sub } 
			{pop pop pop pop 1} ifelse } ifelse } ifelse } ifelse 
		} ifelse
		graymode FMLevel1 or not {
			
			[/Pattern [/DeviceGray]] setcolorspace
			FrameCurPat setcolor
		} { 
			graymode not FMLevel1 and {
				
				dup 1 lt {pop FrameCurGray} if
			} if
			RealSetgray
		} ifelse
	} ifelse
} bind def
/savematrix {
	orgmatrix currentmatrix pop
	} bind def
/restorematrix {
	orgmatrix setmatrix
	} bind def
/dmatrix matrix def
/dpi    72 0 dmatrix defaultmatrix dtransform
    dup mul exch   dup mul add   sqrt def
	
/freq dpi dup 72 div round dup 0 eq {pop 1} if 8 mul div def
/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
/dpiranges   [  2540    2400    1693     1270    1200     635      600      0      ] def
/CMLowFreqs  [ 100.402  94.8683 89.2289 100.402  94.8683  66.9349  63.2456 47.4342 ] def
/YLowFreqs   [  95.25   90.0    84.65    95.25   90.0     70.5556  66.6667 50.0    ] def
/KLowFreqs   [  89.8026 84.8528 79.8088  89.8026 84.8528  74.8355  70.7107 53.033  ] def
/CLowAngles  [  71.5651 71.5651 71.5651 71.5651  71.5651  71.5651  71.5651 71.5651 ] def
/MLowAngles  [  18.4349 18.4349 18.4349 18.4349  18.4349  18.4349  18.4349 18.4349 ] def
/YLowTDot    [  true    true    false    true    true     false    false   false   ] def
/CMHighFreqs [ 133.87  126.491 133.843  108.503 102.523  100.402   94.8683 63.2456 ] def
/YHighFreqs  [ 127.0   120.0   126.975  115.455 109.091   95.25    90.0    60.0    ] def
/KHighFreqs  [ 119.737 113.137 119.713  128.289 121.218   89.8026  84.8528 63.6395 ] def
/CHighAngles [  71.5651 71.5651 71.5651  70.0169 70.0169  71.5651  71.5651 71.5651 ] def
/MHighAngles [  18.4349 18.4349 18.4349  19.9831 19.9831  18.4349  18.4349 18.4349 ] def
/YHighTDot   [  false   false   true     false   false    true     true    false   ] def
/PatFreq     [	10.5833 10.0     9.4055  10.5833 10.0	  10.5833  10.0	   9.375   ] def
/screenIndex {
	0 1 dpiranges length 1 sub { dup dpiranges exch get 1 sub dpi le {exit} {pop} ifelse } for
} bind def
/getCyanScreen {
	FMUseHighFrequencyScreens { CHighAngles CMHighFreqs} {CLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getMagentaScreen {
	FMUseHighFrequencyScreens { MHighAngles CMHighFreqs } {MLowAngles CMLowFreqs} ifelse
		screenIndex dup 3 1 roll get 3 1 roll get /FMSpotFunction load
} bind def
/getYellowScreen {
	FMUseHighFrequencyScreens { YHighTDot YHighFreqs} { YLowTDot YLowFreqs } ifelse
		screenIndex dup 3 1 roll get 3 1 roll get { 3 div
			{2 { 1 add 2 div 3 mul dup floor sub 2 mul 1 sub exch} repeat
			FMSpotFunction } } {/FMSpotFunction load } ifelse
			0.0 exch
} bind def
/getBlackScreen  {
	FMUseHighFrequencyScreens { KHighFreqs } { KLowFreqs } ifelse
		screenIndex get 45.0 /FMSpotFunction load 
} bind def
/getSpotScreen {
	getBlackScreen
} bind def
/getCompositeScreen {
	getBlackScreen
} bind def
/FMSetScreen 
	FMLevel1 { /setscreen load 
	}{ {
		8 dict begin
		/HalftoneType 1 def
		/SpotFunction exch def
		/Angle exch def
		/Frequency exch def
		/AccurateScreens FMUseAcccurateScreens def
		currentdict end sethalftone
	} bind } ifelse
def
/setDefaultScreen {
	FMPColor {
		orgrxfer cvx orggxfer cvx orgbxfer cvx orgxfer cvx setcolortransfer
	}
	{
		orgxfer cvx settransfer
	} ifelse
	orgfreq organgle orgproc cvx setscreen
} bind def
/setCurrentScreen {
	FrameSepIs FMnone eq {
		FMUseDefaultNoSeparationScreen {
			setDefaultScreen
		} {
			getCompositeScreen FMSetScreen
		} ifelse
	} {
		FrameSepIs FMcustom eq {
			FMUseDefaultSpotSeparationScreen {
				setDefaultScreen
			} {
				getSpotScreen FMSetScreen
			} ifelse
		} {
			FMUseDefaultProcessSeparationScreen {
				setDefaultScreen
			} {
				FrameSepIs FMcyan eq {
					getCyanScreen FMSetScreen
				} {
					FrameSepIs FMmagenta eq {
						getMagentaScreen FMSetScreen
					} {
						FrameSepIs FMyellow eq {
							getYellowScreen FMSetScreen
						} {
							getBlackScreen FMSetScreen
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	} ifelse 
} bind def
end
	/gstring FMLOCAL
	/gfile FMLOCAL
	/gindex FMLOCAL
	/orgrxfer FMLOCAL
	/orggxfer FMLOCAL
	/orgbxfer FMLOCAL
	/orgxfer FMLOCAL
	/orgproc FMLOCAL
	/orgrproc FMLOCAL
	/orggproc FMLOCAL
	/orgbproc FMLOCAL
	/organgle FMLOCAL
	/orgrangle FMLOCAL
	/orggangle FMLOCAL
	/orgbangle FMLOCAL
	/orgfreq FMLOCAL
	/orgrfreq FMLOCAL
	/orggfreq FMLOCAL
	/orgbfreq FMLOCAL
	/yscale FMLOCAL
	/xscale FMLOCAL
	/edown FMLOCAL
	/manualfeed FMLOCAL
	/paperheight FMLOCAL
	/paperwidth FMLOCAL
/FMDOCUMENT { 
	array /FMfonts exch def 
	/#copies exch def
	FrameDict begin
	0 ne /manualfeed exch def
	/paperheight exch def
	/paperwidth exch def
	0 ne /FrameNegative exch def 
	0 ne /edown exch def 
	/yscale exch def
	/xscale exch def
	FMLevel1 {
		manualfeed {setmanualfeed} if
		/FMdicttop countdictstack 1 add def 
		/FMoptop count def 
		setpapername 
		manualfeed {true} {papersize} ifelse 
		{manualpapersize} {false} ifelse 
		{desperatepapersize} {false} ifelse 
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		count -1 FMoptop {pop pop} for
		countdictstack -1 FMdicttop {pop end} for 
		}
		{{1 dict dup /PageSize [paperwidth paperheight]put setpagedevice}stopped
		{ (Can't select requested paper size for Frame print job!) FMFAILURE } if
		 {1 dict dup /ManualFeed manualfeed put setpagedevice } stopped pop }
	ifelse 
	
	FMPColor {
		currentcolorscreen
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
			cvlit /orgbproc exch def
				  /orgbangle exch def 
				  /orgbfreq exch def
			cvlit /orggproc exch def
				  /orggangle exch def 
				  /orggfreq exch def
			cvlit /orgrproc exch def
				  /orgrangle exch def 
				  /orgrfreq exch def
			currentcolortransfer 
			FrameNegative {
				1 1 4 { 
					pop { 1 exch sub } concatprocs 4 1 roll
				} for
				4 copy
				setcolortransfer
			} if
			cvlit /orgxfer exch def
			cvlit /orgbxfer exch def
			cvlit /orggxfer exch def
			cvlit /orgrxfer exch def
	} {
		currentscreen 
			cvlit /orgproc exch def
				  /organgle exch def 
				  /orgfreq exch def
				  
		currenttransfer 
		FrameNegative {
			{ 1 exch sub } concatprocs
			dup settransfer
		} if 
		cvlit /orgxfer exch def
	} ifelse
	end 
} def 
/pagesave FMLOCAL
/orgmatrix FMLOCAL
/landscape FMLOCAL
/pwid FMLOCAL
/FMBEGINPAGE { 
	FrameDict begin 
	/pagesave save def
	3.86 setmiterlimit
	/landscape exch 0 ne def
	landscape { 
		90 rotate 0 exch dup /pwid exch def neg translate pop 
	}{
		pop /pwid exch def
	} ifelse
	edown { [-1 0 0 1 pwid 0] concat } if
	0 0 moveto paperwidth 0 lineto paperwidth paperheight lineto 
	0 paperheight lineto 0 0 lineto 1 setgray fill
	xscale yscale scale
	/orgmatrix matrix def
	gsave 
} def 
/FMENDPAGE {
	grestore 
	pagesave restore
	end 
	showpage
	} def 
/FMFONTDEFINE { 
	FrameDict begin
	findfont 
	ReEncode 
	1 index exch 
	definefont 
	FMfonts 3 1 roll 
	put
	end 
	} def 
/FMFILLS {
	FrameDict begin dup
	array /fillvals exch def
	dict /patCache exch def
	end 
	} def 
/FMFILL {
	FrameDict begin
	 fillvals 3 1 roll put
	end 
	} def 
/FMNORMALIZEGRAPHICS { 
	newpath
	0.0 0.0 moveto
	1 setlinewidth
	0 setlinecap
	0 0 0 sethsbcolor
	0 setgray 
	} bind def
	/fx FMLOCAL
	/fy FMLOCAL
	/fh FMLOCAL
	/fw FMLOCAL
	/llx FMLOCAL
	/lly FMLOCAL
	/urx FMLOCAL
	/ury FMLOCAL
/FMBEGINEPSF { 
	end 
	/FMEPSF save def 
	/showpage {} def 
% See Adobe's "PostScript Language Reference Manual, 2nd Edition", page 714.
% "...the following operators MUST NOT be used in an EPS file:" (emphasis ours)
	/banddevice {(banddevice) FMBADEPSF} def
	/clear {(clear) FMBADEPSF} def
	/cleardictstack {(cleardictstack) FMBADEPSF} def 
	/copypage {(copypage) FMBADEPSF} def
	/erasepage {(erasepage) FMBADEPSF} def
	/exitserver {(exitserver) FMBADEPSF} def
	/framedevice {(framedevice) FMBADEPSF} def
	/grestoreall {(grestoreall) FMBADEPSF} def
	/initclip {(initclip) FMBADEPSF} def
	/initgraphics {(initgraphics) FMBADEPSF} def
	/initmatrix {(initmatrix) FMBADEPSF} def
	/quit {(quit) FMBADEPSF} def
	/renderbands {(renderbands) FMBADEPSF} def
	/setglobal {(setglobal) FMBADEPSF} def
	/setpagedevice {(setpagedevice) FMBADEPSF} def
	/setshared {(setshared) FMBADEPSF} def
	/startjob {(startjob) FMBADEPSF} def
	/lettertray {(lettertray) FMBADEPSF} def
	/letter {(letter) FMBADEPSF} def
	/lettersmall {(lettersmall) FMBADEPSF} def
	/11x17tray {(11x17tray) FMBADEPSF} def
	/11x17 {(11x17) FMBADEPSF} def
	/ledgertray {(ledgertray) FMBADEPSF} def
	/ledger {(ledger) FMBADEPSF} def
	/legaltray {(legaltray) FMBADEPSF} def
	/legal {(legal) FMBADEPSF} def
	/statementtray {(statementtray) FMBADEPSF} def
	/statement {(statement) FMBADEPSF} def
	/executivetray {(executivetray) FMBADEPSF} def
	/executive {(executive) FMBADEPSF} def
	/a3tray {(a3tray) FMBADEPSF} def
	/a3 {(a3) FMBADEPSF} def
	/a4tray {(a4tray) FMBADEPSF} def
	/a4 {(a4) FMBADEPSF} def
	/a4small {(a4small) FMBADEPSF} def
	/b4tray {(b4tray) FMBADEPSF} def
	/b4 {(b4) FMBADEPSF} def
	/b5tray {(b5tray) FMBADEPSF} def
	/b5 {(b5) FMBADEPSF} def
	FMNORMALIZEGRAPHICS 
	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
	fx fw 2 div add fy fh 2 div add  translate
	rotate
	fw 2 div neg fh 2 div neg translate
	fw urx llx sub div fh ury lly sub div scale 
	llx neg lly neg translate 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count def 
	} bind def
/FMENDEPSF {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMEPSF restore
	FrameDict begin 
	} bind def
FrameDict begin 
/setmanualfeed {
%%BeginFeature *ManualFeed True
	 statusdict /manualfeed true put
%%EndFeature
	} bind def
/max {2 copy lt {exch} if pop} bind def
/min {2 copy gt {exch} if pop} bind def
/inch {72 mul} def
/pagedimen { 
	paperheight sub abs 16 lt exch 
	paperwidth sub abs 16 lt and
	{/papername exch def} {pop} ifelse
	} bind def
	/papersizedict FMLOCAL
/setpapername { 
	/papersizedict 14 dict def 
	papersizedict begin
	/papername /unknown def 
		/Letter 8.5 inch 11.0 inch pagedimen
		/LetterSmall 7.68 inch 10.16 inch pagedimen
		/Tabloid 11.0 inch 17.0 inch pagedimen
		/Ledger 17.0 inch 11.0 inch pagedimen
		/Legal 8.5 inch 14.0 inch pagedimen
		/Statement 5.5 inch 8.5 inch pagedimen
		/Executive 7.5 inch 10.0 inch pagedimen
		/A3 11.69 inch 16.5 inch pagedimen
		/A4 8.26 inch 11.69 inch pagedimen
		/A4Small 7.47 inch 10.85 inch pagedimen
		/B4 10.125 inch 14.33 inch pagedimen
		/B5 7.16 inch 10.125 inch pagedimen
	end
	} bind def
/papersize {
	papersizedict begin
		/Letter {lettertray letter} def
		/LetterSmall {lettertray lettersmall} def
		/Tabloid {11x17tray 11x17} def
		/Ledger {ledgertray ledger} def
		/Legal {legaltray legal} def
		/Statement {statementtray statement} def
		/Executive {executivetray executive} def
		/A3 {a3tray a3} def
		/A4 {a4tray a4} def
		/A4Small {a4tray a4small} def
		/B4 {b4tray b4} def
		/B5 {b5tray b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	statusdict begin stopped end 
	} bind def
/manualpapersize {
	papersizedict begin
		/Letter {letter} def
		/LetterSmall {lettersmall} def
		/Tabloid {11x17} def
		/Ledger {ledger} def
		/Legal {legal} def
		/Statement {statement} def
		/Executive {executive} def
		/A3 {a3} def
		/A4 {a4} def
		/A4Small {a4small} def
		/B4 {b4} def
		/B5 {b5} def
		/unknown {unknown} def
	papersizedict dup papername known {papername} {/unknown} ifelse get
	end
	stopped 
	} bind def
/desperatepapersize {
	statusdict /setpageparams known
		{
		paperwidth paperheight 0 1 
		statusdict begin
		{setpageparams} stopped 
		end
		} {true} ifelse 
	} bind def
/DiacriticEncoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
/numbersign /dollar /percent /ampersand /quotesingle /parenleft
/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
/two /three /four /five /six /seven /eight /nine /colon /semicolon
/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
/udieresis /dagger /.notdef /cent /sterling /section /bullet
/paragraph /germandbls /registered /copyright /trademark /acute
/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
/periodcentered /quotesinglbase /quotedblbase /perthousand
/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
] def
/ReEncode { 
	dup 
	length 
	dict begin 
	{
	1 index /FID ne 
		{def} 
		{pop pop} ifelse 
	} forall 
	0 eq {/Encoding DiacriticEncoding def} if 
	currentdict 
	end 
	} bind def
FMPColor 
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPCOLOR} def
	/BEGINBITMAPCOLORc { 
		BITMAPCOLORc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUECOLOR } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUECOLORc } def
	}
	
	{
	/BEGINBITMAPCOLOR { 
		BITMAPGRAY} def
	/BEGINBITMAPCOLORc { 
		BITMAPGRAYc} def
	/BEGINBITMAPTRUECOLOR { 
		BITMAPTRUEGRAY } def
	/BEGINBITMAPTRUECOLORc { 
		BITMAPTRUEGRAYc } def
	}
ifelse
/K { 
	FMPrintAllColorsAsBlack {
		dup 1 eq 2 index 1 eq and 3 index 1 eq and not
			{7 {pop} repeat 0 0 0 1 0 0 0} if
	} if 
	FrameCurColors astore 
	pop combineColor
} bind def
/graymode true def
	/bwidth FMLOCAL
	/bpside FMLOCAL
	/bstring FMLOCAL
	/onbits FMLOCAL
	/offbits FMLOCAL
	/xindex FMLOCAL
	/yindex FMLOCAL
	/x FMLOCAL
	/y FMLOCAL
/setPatternMode {
	FMLevel1 {
		/bwidth  exch def
		/bpside  exch def
		/bstring exch def
		/onbits 0 def  /offbits 0 def
		freq sangle landscape {90 add} if 
			{/y exch def
			 /x exch def
			 /xindex x 1 add 2 div bpside mul cvi def
			 /yindex y 1 add 2 div bpside mul cvi def
			 bstring yindex bwidth mul xindex 8 idiv add get
			 1 7 xindex 8 mod sub bitshift and 0 ne FrameNegative {not} if
			 {/onbits  onbits  1 add def 1}
			 {/offbits offbits 1 add def 0}
			 ifelse
			}
			setscreen
		offbits offbits onbits add div FrameNegative {1.0 exch sub} if
		/FrameCurGray exch def
	} { 
		pop pop
		dup patCache exch known {
			patCache exch get
		} { 
			dup
			patDict /bstring 3 -1 roll put
			patDict 
			9 PatFreq screenIndex get div dup matrix scale
			makepattern
			dup 
			patCache 4 -1 roll 3 -1 roll put
		} ifelse
		/FrameCurGray 0 def
		/FrameCurPat exch def
	} ifelse
	/graymode false def
	combineColor
} bind def
/setGrayScaleMode {
	graymode not {
		/graymode true def
		FMLevel1 {
			setCurrentScreen
		} if
	} if
	/FrameCurGray exch def
	combineColor
} bind def
/normalize {
	transform round exch round exch itransform
	} bind def
/dnormalize {
	dtransform round exch round exch idtransform
	} bind def
/lnormalize { 
	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
	} bind def
/H { 
	lnormalize setlinewidth
	} bind def
/Z {
	setlinecap
	} bind def
	
/PFill {
	graymode FMLevel1 or not {
		gsave 1 setgray eofill grestore
	} if
} bind def
/PStroke {
	graymode FMLevel1 or not {
		gsave 1 setgray stroke grestore
	} if
	stroke
} bind def
	/fillvals FMLOCAL
/X { 
	fillvals exch get
	dup type /stringtype eq
	{8 1 setPatternMode} 
	{setGrayScaleMode}
	ifelse
	} bind def
/V { 
	PFill gsave eofill grestore
	} bind def
/Vclip {
	clip
	} bind def
/Vstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/N { 
	PStroke
	} bind def
/Nclip {
	strokepath clip newpath
	} bind def
/Nstrk {
	currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/M {newpath moveto} bind def
/E {lineto} bind def
/D {curveto} bind def
/O {closepath} bind def
	/n FMLOCAL
/L { 
 	/n exch def
	newpath
	normalize
	moveto 
	2 1 n {pop normalize lineto} for
	} bind def
/Y { 
	L 
	closepath
	} bind def
	/x1 FMLOCAL
	/x2 FMLOCAL
	/y1 FMLOCAL
	/y2 FMLOCAL
/R { 
	/y2 exch def
	/x2 exch def
	/y1 exch def
	/x1 exch def
	x1 y1
	x2 y1
	x2 y2
	x1 y2
	4 Y 
	} bind def
	/rad FMLOCAL
/rarc 
	{rad 
	 arcto
	} bind def
/RR { 
	/rad exch def
	normalize
	/y2 exch def
	/x2 exch def
	normalize
	/y1 exch def
	/x1 exch def
	mark
	newpath
	{
	x1 y1 rad add moveto
	x1 y2 x2 y2 rarc
	x2 y2 x2 y1 rarc
	x2 y1 x1 y1 rarc
	x1 y1 x1 y2 rarc
	closepath
	} stopped {x1 y1 x2 y2 R} if 
	cleartomark
	} bind def
/RRR { 
	/rad exch def
	normalize /y4 exch def /x4 exch def
	normalize /y3 exch def /x3 exch def
	normalize /y2 exch def /x2 exch def
	normalize /y1 exch def /x1 exch def
	newpath
	normalize moveto 
	mark
	{
	x2 y2 x3 y3 rarc
	x3 y3 x4 y4 rarc
	x4 y4 x1 y1 rarc
	x1 y1 x2 y2 rarc
	closepath
	} stopped
	 {x1 y1 x2 y2 x3 y3 x4 y4 newpath moveto lineto lineto lineto closepath} if
	cleartomark
	} bind def
/C { 
	grestore
	gsave
	R 
	clip
	setCurrentScreen
} bind def
/CP { 
	grestore
	gsave
	Y 
	clip
	setCurrentScreen
} bind def
	/FMpointsize FMLOCAL
/F { 
	FMfonts exch get
	FMpointsize scalefont
	setfont
	} bind def
/Q { 
	/FMpointsize exch def
	F 
	} bind def
/T { 
	moveto show
	} bind def
/RF { 
	rotate
	0 ne {-1 1 scale} if
	} bind def
/TF { 
	gsave
	moveto 
	RF
	show
	grestore
	} bind def
/P { 
	moveto
	0 32 3 2 roll widthshow
	} bind def
/PF { 
	gsave
	moveto 
	RF
	0 32 3 2 roll widthshow
	grestore
	} bind def
/S { 
	moveto
	0 exch ashow
	} bind def
/SF { 
	gsave
	moveto
	RF
	0 exch ashow
	grestore
	} bind def
/B { 
	moveto
	0 32 4 2 roll 0 exch awidthshow
	} bind def
/BF { 
	gsave
	moveto
	RF
	0 32 4 2 roll 0 exch awidthshow
	grestore
	} bind def
/G { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	PFill fill
	grestore
	} bind def
/Gstrk {
	savematrix
    newpath
    2 index 2 div add exch 3 index 2 div sub exch 
    normalize 2 index 2 div sub exch 3 index 2 div add exch 
    translate
    scale 
    0.0 0.0 1.0 5 3 roll arc 
    restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
    } bind def
/Gclip { 
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	clip newpath
	restorematrix
	} bind def
/GG { 
	gsave
	newpath
	normalize translate 0.0 0.0 moveto 
	rotate 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath
	PFill
	fill
	grestore
	} bind def
/GGclip { 
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	clip newpath
	restorematrix
	} bind def
/GGstrk { 
	savematrix
    newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath 
	restorematrix
    currentlinewidth exch setlinewidth PStroke setlinewidth
	} bind def
/A { 
	gsave
	savematrix
	newpath
	2 index 2 div add exch 3 index 2 div sub exch 
	normalize 2 index 2 div sub exch 3 index 2 div add exch 
	translate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/Aclip {
	newpath
	savematrix
	normalize translate 0.0 0.0 moveto 
	dnormalize scale 
	0.0 0.0 1.0 5 3 roll arc 
	closepath 
	strokepath clip newpath
	restorematrix
} bind def
/Astrk {
	Gstrk
} bind def
/AA { 
	gsave
	savematrix
	newpath
	
	3 index 2 div add exch 4 index 2 div sub exch 
	
	normalize 3 index 2 div sub exch 4 index 2 div add exch
	translate 
	rotate 
	scale 
	0.0 0.0 1.0 5 3 roll arc 
	restorematrix
	PStroke
	grestore
	} bind def
/AAclip {
	savematrix
	newpath
    normalize translate 0.0 0.0 moveto 
    rotate 
    dnormalize scale 
    0.0 0.0 1.0 5 3 roll arc 
    closepath
	strokepath clip newpath
	restorematrix
} bind def
/AAstrk {
	GGstrk
} bind def
	/x FMLOCAL
	/y FMLOCAL
	/w FMLOCAL
	/h FMLOCAL
	/xx FMLOCAL
	/yy FMLOCAL
	/ww FMLOCAL
	/hh FMLOCAL
	/FMsaveobject FMLOCAL
	/FMoptop FMLOCAL
	/FMdicttop FMLOCAL
/BEGINPRINTCODE { 
	/FMdicttop countdictstack 1 add def 
	/FMoptop count 7 sub def 
	/FMsaveobject save def
	userdict begin 
	/showpage {} def 
	FMNORMALIZEGRAPHICS 
	3 index neg 3 index neg translate
	} bind def
/ENDPRINTCODE {
	count -1 FMoptop {pop pop} for 
	countdictstack -1 FMdicttop {pop end} for 
	FMsaveobject restore 
	} bind def
/gn { 
	0 
	{	46 mul 
		cf read pop 
		32 sub 
		dup 46 lt {exit} if 
		46 sub add 
		} loop
	add 
	} bind def
	/str FMLOCAL
/cfs { 
	/str sl string def 
	0 1 sl 1 sub {str exch val put} for 
	str def 
	} bind def
/ic [ 
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
	0
	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
	] def
	/sl FMLOCAL
	/val FMLOCAL
	/ws FMLOCAL
	/im FMLOCAL
	/bs FMLOCAL
	/cs FMLOCAL
	/len FMLOCAL
	/pos FMLOCAL
/ms { 
	/sl exch def 
	/val 255 def 
	/ws cfs 
	/im cfs 
	/val 0 def 
	/bs cfs 
	/cs cfs 
	} bind def
400 ms 
/ip { 
	is 
	0 
	cf cs readline pop 
	{	ic exch get exec 
		add 
		} forall 
	pop 
	
	} bind def
/rip { 
	   
	  
	  bis ris copy pop 
      is
      0
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop 
	  ris gis copy pop 
	  dup is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
	  pop pop
	  gis bis copy pop 
	  dup add is exch 
	  
      cf cs readline pop 
      {       ic exch get exec 
              add 
              } forall 
      pop 
      
      } bind def
/wh { 
	/len exch def 
	/pos exch def 
	ws 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/bl { 
	/len exch def 
	/pos exch def 
	bs 0 len getinterval im pos len getinterval copy pop
	pos len 
	} bind def
/s1 1 string def
/fl { 
	/len exch def 
	/pos exch def 
	/val cf s1 readhexstring pop 0 get def
	pos 1 pos len add 1 sub {im exch val put} for
	pos len 
	} bind def
/hx { 
	3 copy getinterval 
	cf exch readhexstring pop pop 
	} bind def
	/h FMLOCAL
	/w FMLOCAL
	/d FMLOCAL
	/lb FMLOCAL
	/bitmapsave FMLOCAL
	/is FMLOCAL
	/cf FMLOCAL
/wbytes { 
      dup dup
      24 eq { pop pop 3 mul }
      { 8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse } ifelse
	} bind def
/BEGINBITMAPBWc { 
	1 {} COMMONBITMAPc
	} bind def
/BEGINBITMAPGRAYc { 
	8 {} COMMONBITMAPc
	} bind def
/BEGINBITMAP2BITc { 
	2 {} COMMONBITMAPc
	} bind def
/COMMONBITMAPc { 
		 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	r                    
	/is im 0 lb getinterval def 
	ws 0 lb getinterval is copy pop 
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{ip} image 
	bitmapsave restore 
	grestore
	} bind def
/BEGINBITMAPBW { 
	1 {} COMMONBITMAP
	} bind def
/BEGINBITMAPGRAY { 
	8 {} COMMONBITMAP
	} bind def
/BEGINBITMAP2BIT { 
	2 {} COMMONBITMAP
	} bind def
/COMMONBITMAP { 
	/r exch def
	/d exch def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def 
	r                    
	/is w d wbytes string def
	/cf currentfile def 
	w h d [w 0 0 h neg 0 h] 
	{cf is readhexstring pop} image
	bitmapsave restore 
	grestore
	} bind def
/ngrayt 256 array def
/nredt 256 array def
/nbluet 256 array def
/ngreent 256 array def
	/gryt FMLOCAL
	/blut FMLOCAL
	/grnt FMLOCAL
	/redt FMLOCAL
	/indx FMLOCAL
	/cynu FMLOCAL
	/magu FMLOCAL
	/yelu FMLOCAL
	/k FMLOCAL
	/u FMLOCAL
FMLevel1 {
/colorsetup {
	currentcolortransfer
	/gryt exch def
	/blut exch def
	/grnt exch def
	/redt exch def
	0 1 255 {
		/indx exch def
		/cynu 1 red indx get 255 div sub def
		/magu 1 green indx get 255 div sub def
		/yelu 1 blue indx get 255 div sub def
		/k cynu magu min yelu min def
		/u k currentundercolorremoval exec def
%		/u 0 def
		nredt indx 1 0 cynu u sub max sub redt exec put
		ngreent indx 1 0 magu u sub max sub grnt exec put
		nbluet indx 1 0 yelu u sub max sub blut exec put
		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
	} for
	{255 mul cvi nredt exch get}
	{255 mul cvi ngreent exch get}
	{255 mul cvi nbluet exch get}
	{255 mul cvi ngrayt exch get}
	setcolortransfer
	{pop 0} setundercolorremoval
	{} setblackgeneration
	} bind def
}
{
/colorSetup2 {
	[ /Indexed /DeviceRGB 255 
		{dup red exch get 255 div 
		 exch dup green exch get 255 div 
		 exch blue exch get 255 div}
	] setcolorspace
} bind def
} ifelse
	/tran FMLOCAL
/fakecolorsetup {
	/tran 256 string def
	0 1 255 {/indx exch def 
		tran indx
		red indx get 77 mul
		green indx get 151 mul
		blue indx get 28 mul
		add add 256 idiv put} for
	currenttransfer
	{255 mul cvi tran exch get 255.0 div}
	exch concatprocs settransfer
} bind def
/BITMAPCOLOR { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/bitmapsave save def
	FMLevel1 {	
		colorsetup
		/is w d wbytes string def
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{cf is readhexstring pop} {is} {is} true 3 colorimage 
	} {
		colorSetup2
		/is w d wbytes string def
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {cf is readhexstring pop} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPCOLORc { 
	/d 8 def
	gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
	/bitmapsave save def 
	FMLevel1 {	
		colorsetup
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		w h d [w 0 0 h neg 0 h] 
		{ip} {is} {is} true 3 colorimage
	} {
		colorSetup2
		/is im 0 lb getinterval def 
		ws 0 lb getinterval is copy pop 
		/cf currentfile def 
		7 dict dup begin
			/ImageType 1 def
			/Width w def
			/Height h def
			/ImageMatrix [w 0 0 h neg 0 h] def
			/DataSource {ip} bind def
			/BitsPerComponent d def
			/Decode [0 255] def
		end image	
	} ifelse
	bitmapsave restore 
	grestore
	} bind def
/BITMAPTRUECOLORc { 
	/d 24 def
        gsave
 	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris} {gis} {bis} true 3 colorimage
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUECOLOR { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop } 
        { cf gis readhexstring pop } 
        { cf bis readhexstring pop } 
        true 3 colorimage 
        bitmapsave restore 
        grestore
        } bind def
/BITMAPTRUEGRAYc { 
	/d 24 def
        gsave
	
	3 index 2 div add exch	
	4 index 2 div add exch	
	translate		
	rotate			
	1 index 2 div neg	
	1 index 2 div neg	
	translate		
	scale			
	/h exch def /w exch def
	/lb w d wbytes def 
	sl lb lt {lb ms} if 
        /bitmapsave save def 
        
	/is im 0 lb getinterval def	
	/ris im 0 w getinterval def	
	/gis im w w getinterval def	
	/bis im w 2 mul w getinterval def 
        ws 0 lb getinterval is copy pop 
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        {w rip pop ris gis bis w gray} image
        bitmapsave restore 
        grestore
        } bind def
/ww FMLOCAL
/r FMLOCAL
/g FMLOCAL
/b FMLOCAL
/i FMLOCAL
/gray { 
        /ww exch def
        /b exch def
        /g exch def
        /r exch def
        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
        r
        } bind def
/BITMAPTRUEGRAY { 
        gsave
		
		3 index 2 div add exch	
		4 index 2 div add exch	
		translate		
		rotate			
		1 index 2 div neg	
		1 index 2 div neg	
		translate		
		scale			
		/h exch def /w exch def
        /bitmapsave save def 
        /is w string def
        /gis w string def
        /bis w string def
        /cf currentfile def 
        w h 8 [w 0 0 h neg 0 h] 
        { cf is readhexstring pop 
          cf gis readhexstring pop 
          cf bis readhexstring pop w gray}  image
        bitmapsave restore 
        grestore
        } bind def
/BITMAPGRAY { 
	8 {fakecolorsetup} COMMONBITMAP
	} bind def
/BITMAPGRAYc { 
	8 {fakecolorsetup} COMMONBITMAPc
	} bind def
/ENDBITMAP {
	} bind def
end 
	/ALDsave FMLOCAL
	/ALDmatrix matrix def ALDmatrix currentmatrix pop
/StartALD {
	/ALDsave save def
	 savematrix
	 ALDmatrix setmatrix
	} bind def
/InALD {
	 restorematrix
	} bind def
/DoneALD {
	 ALDsave restore
	} bind def
/I { setdash } bind def
/J { [] 0 setdash } bind def
%%EndProlog
%%BeginSetup
(4.0) FMVERSION
1 1 0 0 595.3 841.9 0 1 20 FMDOCUMENT
0 0 /Times-Bold FMFONTDEFINE
1 0 /Times-Italic FMFONTDEFINE
2 0 /Times-Roman FMFONTDEFINE
3 0 /Helvetica-Bold FMFONTDEFINE
4 0 /Helvetica FMFONTDEFINE
5 0 /Courier-Bold FMFONTDEFINE
6 0 /Courier FMFONTDEFINE
32 FMFILLS
0 0 FMFILL
1 0.1 FMFILL
2 0.3 FMFILL
3 0.5 FMFILL
4 0.7 FMFILL
5 0.9 FMFILL
6 0.97 FMFILL
7 1 FMFILL
8 <0f1e3c78f0e1c387> FMFILL
9 <0f87c3e1f0783c1e> FMFILL
10 <cccccccccccccccc> FMFILL
11 <ffff0000ffff0000> FMFILL
12 <8142241818244281> FMFILL
13 <03060c183060c081> FMFILL
14 <8040201008040201> FMFILL
16 1 FMFILL
17 0.9 FMFILL
18 0.7 FMFILL
19 0.5 FMFILL
20 0.3 FMFILL
21 0.1 FMFILL
22 0.03 FMFILL
23 0 FMFILL
24 <f0e1c3870f1e3c78> FMFILL
25 <f0783c1e0f87c3e1> FMFILL
26 <3333333333333333> FMFILL
27 <0000ffff0000ffff> FMFILL
28 <7ebddbe7e7dbbd7e> FMFILL
29 <fcf9f3e7cf9f3f7e> FMFILL
30 <7fbfdfeff7fbfdfe> FMFILL
%%EndSetup
%%Page: "1" 1
%%BeginPaperSize: A4
%%EndPaperSize
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
J
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
113.4 694.5 544.26 739.85 R
7 X
0 0 0 1 0 0 0 K
V
0 18 Q
0 X
(Requir) 113.4 699.54 T
(ements Speci\336cation for Parallel Extensions to) 167.07 699.54 T
255.13 433.71 544.26 473.39 R
7 X
V
1 10 Q
0 X
(The status of this document is \322WORKING\323 if signed only by its) 255.13 466.73 T
(author\050s\051; it is \322ISSUED\323 if signed by the W) 255.13 454.73 T
(orkpackage Manager; it) 433.65 454.73 T
(is \322DELIVERED\323 if signed by the Pr) 255.13 442.73 T
(oject Dir) 404.76 442.73 T
(ector) 440.22 442.73 T
(.) 459.66 442.73 T
255.13 615.13 544.26 643.47 R
7 X
V
2 12 Q
0 X
(T) 255.13 635.47 T
(ony Mann, Eliot Miranda) 261.62 635.47 T
(________________________) 396.86 635.47 T
(Harlequin Ltd.) 255.13 621.47 T
255.13 547.09 544.26 586.78 R
7 X
V
0 X
(Peter Edwards) 255.13 578.78 T
(________________________) 396.86 578.78 T
(DRA) 255.13 564.78 T
255.13 501.74 544.26 530.09 R
7 X
V
0 X
(Gianluigi Castelli) 255.13 522.09 T
(________________________) 396.86 522.09 T
(Project Director) 255.13 508.09 T
113.4 615.13 226.78 643.47 R
7 X
V
0 F
0 X
(W) 113.4 635.47 T
(ritten by:) 125.18 635.47 T
113.4 558.43 226.78 586.78 R
7 X
V
0 X
(Issued by:) 113.4 578.78 T
113.4 501.74 226.78 530.09 R
7 X
V
0 X
(Deliver) 113.4 522.09 T
(ed by:) 150.5 522.09 T
113.4 388.36 226.78 416.7 R
7 X
V
0 X
-0.19 (Pr) 113.4 408.7 P
-0.19 (oject deliverable id:) 125.84 408.7 P
255.13 388.36 544.26 416.7 R
7 X
V
2 F
0 X
(TR5.7.1-01) 255.13 408.7 T
113.4 331.66 226.78 360.01 R
7 X
V
0 F
0 X
(Document code:) 113.4 352.01 T
113.4 274.97 226.78 303.32 R
7 X
V
0 X
(Date of \336rst issue:) 113.4 295.32 T
(Date of last issue:) 113.4 281.32 T
113.4 218.28 226.78 246.62 R
7 X
V
0 X
(A) 113.4 238.62 T
(vailability:) 121.17 238.62 T
255.13 331.66 544.26 360.01 R
7 X
V
2 F
0 X
(Harlequin GLUE5.7.1 - 01) 255.13 352.01 T
255.13 274.97 544.26 303.32 R
7 X
V
0 X
(1994-03-16) 255.13 295.32 T
(1994-03-16) 255.13 281.32 T
255.13 218.28 544.26 246.62 R
7 X
V
0 X
(Con\336dential) 255.13 238.62 T
255.13 155.91 544.26 189.93 R
7 X
V
1 10 Q
0 X
-0.12 (The contents of this document ar) 255.13 183.26 P
-0.12 (e con\336dential and subject to copyrights) 384.99 183.26 P
(pr) 255.13 171.26 T
(otection. Any infringement will be pr) 263.65 171.26 T
(osecuted by law) 410.5 171.26 T
(.) 473.64 171.26 T
198.43 59.54 544.26 133.24 R
7 X
V
1 0 1 0 0 1 0 K
0 93 Q
0 X
1 0 1 0 0 1 0 K
(omi/glue) 198.43 71.24 T
0 0 0 1 0 0 0 K
5.68 19.85 102.06 813.55 R
3 X
0 0 0 1 0 0 0 K
V
0.5 H
2 Z
0 X
N
113.4 751.19 544.26 790.87 R
7 X
V
1 0 1 0 0 1 0 K
0 0 0 1 0 0 0 K
0 36 Q
0 X
(ESPRIT PROJECT 6062) 116.53 736.07 T
0 18 Q
(TDF to support Dylan - including Run-time Support) 113.4 681.54 T
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "1" 1
%%Page: "1" 2
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
297.65 753.95 531.65 771.95 R
7 X
V
0 X
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
0 12 Q
(CHANGE HIST) 63.65 716.95 T
(OR) 147.78 716.95 T
(Y) 165.36 716.95 T
(This is the \336rst version.) 63.65 676.95 T
FMENDPAGE
%%EndPage: "1" 2
%%Page: "2" 3
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
3 8 Q
0 X
0 0 0 1 0 0 0 K
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
297.65 753.95 531.65 771.95 R
7 X
V
0 X
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
FMENDPAGE
%%EndPage: "2" 3
%%Page: "1" 4
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 96.95 531.65 96.95 2 L
2 Z
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
3 10 Q
(1) 526.09 84.9 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(support Dylan - including run-time support.) 297.65 756.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 12 Q
(1.) 63.65 736.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Purpose) 90.65 736.95 T
(1) 144.65 736.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(2.) 63.65 716.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Executive Summary) 90.65 716.95 T
(1) 206.3 716.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(3.) 63.65 696.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Thr) 90.65 696.95 T
(eads) 110.44 696.95 T
(1) 145.1 696.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
2 11 Q
(3.1) 90.65 683.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Synchronization) 117.65 683.62 T
(2) 200.75 683.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(3.2) 90.65 670.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(A Dylan Thread Model) 117.65 670.62 T
(3) 231.6 670.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(3.3) 90.65 657.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Implementation of the Dylan Thread Model in TDF) 117.65 657.62 T
(3) 356.26 657.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
2 10 Q
(3.3.1) 117.65 645.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Implementation of the dynamic environment with multiple threads) 144.65 645.29 T
(4) 421.02 645.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(3.3.2) 117.65 633.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Implementation of exceptions with multiple threads) 144.65 633.29 T
(5) 361.58 633.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 12 Q
(4.) 63.65 613.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Garbage Collection Algorithms for Thr) 90.65 613.95 T
(eads) 292.42 613.95 T
(6) 327.08 613.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
2 11 Q
(4.1) 90.65 600.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Heap-Based Automatic Storage Management) 117.65 600.62 T
(6) 328.13 600.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(4.2) 90.65 587.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Basic Algorithms) 117.65 587.62 T
(6) 205.96 587.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(4.3) 90.65 574.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Concurrent variants) 117.65 574.62 T
(8) 215.71 574.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
2 10 Q
(4.3.1) 117.65 562.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Concurrent Reference Counting Collectors) 144.65 562.29 T
(8) 326.01 562.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(4.3.2) 117.65 550.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Ef) 144.65 550.29 T
(fective Barrier Methods) 153.91 550.29 T
(8) 259.44 550.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(4.3.3) 117.65 538.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Concurrent T) 144.65 538.29 T
(racing Collectors) 197.9 538.29 T
(9) 276.5 538.29 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 12 Q
(5.) 63.65 518.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Implementing Garbage Collection Algorithms in TDF) 90.65 518.95 T
(10) 378.31 518.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
2 11 Q
(5.1) 90.65 505.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Synchronization for Garbage Collection in TDF) 117.65 505.62 T
(1) 339.76 505.62 T
(1) 344.85 505.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(5.2) 90.65 492.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Allocation in TDF) 117.65 492.62 T
(12) 209.93 492.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(5.3) 90.65 479.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Read and W) 117.65 479.62 T
(rite Barriers in TDF) 171.58 479.62 T
(12) 270.26 479.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(5.4) 90.65 466.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Locating Roots for Garbage Collection in TDF) 117.65 466.62 T
(13) 335.18 466.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(5.5) 90.65 453.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Expected costs and bene\336ts for TDF support) 117.65 453.62 T
(13) 324.79 453.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 12 Q
(6.) 63.65 433.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Conclusions) 90.65 433.95 T
(14) 164.66 433.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(7.) 63.65 413.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Refer) 90.65 413.95 T
(ences and Bibliography) 119.08 413.95 T
(14) 251.1 413.95 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "1" 4
%%Page: "2" 5
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
3 10 Q
(2) 63.65 84.9 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0 Z
N
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
(support Dylan - including run-time support.) 297.65 756.62 T
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
FMENDPAGE
%%EndPage: "2" 5
%%Page: "1" 6
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(1) 526.09 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
3 15 Q
(1.) 63.65 734.95 T
(Purpose) 90.65 734.95 T
2 12 Q
0.96 (The purpose of this document is to identify the features missing from TDF [TDF92] which are) 63.65 715.95 P
-0.1 (required to support a multi-threaded implementation of Dylan with garbage collection. In order to) 63.65 701.95 P
0.42 (do this, a study is made of some possible implementation techniques, and an analysis is made of) 63.65 687.95 P
(how much support TDF already provides for these techniques.) 63.65 673.95 T
(This work was sponsored by the Commission of the European Communities.) 63.65 652.95 T
3 15 Q
(2.) 63.65 613.95 T
(Executive Summary) 90.65 613.95 T
2 12 Q
-0.02 (Dylan is an advanced, modern, object oriented programming language [Apple92]. It contains fea-) 63.65 594.95 P
2.12 (tures not found in most other languages \321 such as automatic memory management, and an) 63.65 580.95 P
1.62 (exceptions mechanism. The language is still under development, and proposals are starting to) 63.65 566.95 P
(appear for standard libraries for the language.) 63.65 552.95 T
-0.04 (As part of their work with OMI/GLUE, Harlequin have undertaken to study the requirements of a) 63.65 531.95 P
0.19 (Dylan producer with support for a threads library) 63.65 517.95 P
0.19 (. This will establish the adequacy of the parallel) 300.49 517.95 P
-0.25 (TDF extensions developed by DRA in task 5.1, and point out any areas where TDF might be lack-) 63.65 503.95 P
(ing.) 63.65 489.95 T
-0.22 (Although a standard threads library for Dylan does not yet exist, Harlequin intend to develop their) 63.65 468.95 P
2.35 (own library) 63.65 454.95 P
2.35 (, which may later be proposed as a standard. It is not expected that the support) 120.87 454.95 P
(required from TDF will depend on the details of the \336nal threads standard chosen for Dylan.) 63.65 440.95 T
0.18 (This document looks at the features any Dylan threads library must provide, and attempts to map) 63.65 419.95 P
2.37 (them onto the experimental basic thread model described in [Edwards93]. This basic thread) 63.65 405.95 P
3.09 (model of) 63.65 391.95 P
3.09 (fers suitable support for synchronization, thread creation and thread deletion. The) 109.52 391.95 P
-0.22 (requirements of Dylan for garbage collection and other advanced features have been discussed for) 63.65 377.95 P
0.51 (a serial computation model in [Mann93][Mann93a][Currie93]. These areas require extension for) 63.65 363.95 P
(parallel computation models, and are not covered by the basic threads model.) 63.65 349.95 T
1.61 (Implementation techniques for Dylan\325) 63.65 328.95 P
1.61 (s advanced features on some important types of parallel) 251.46 328.95 P
0.6 (architectures are discussed. As explained in [Edwards93], there is no common model of parallel) 63.65 314.95 P
1.16 (computation, and TDF does not attempt to provide an architecture neutral solution. This docu-) 63.65 300.95 P
1.26 (ment shows, in principle, how architecture neutrality may be provided for these advanced fea-) 63.65 286.95 P
-0.24 (tures, just as for basic threads, using a combination of TDF token de\336nitions and platform speci\336c) 63.65 272.95 P
1.47 (run-time systems. A variety of very dif) 63.65 258.95 P
1.47 (ferent garbage collector designs may be used with this) 259.24 258.95 P
(level of abstraction.) 63.65 244.95 T
0.5 (By leaving the details of the support for threads to token de\336nitions and a suitable run-time sys-) 63.65 223.95 P
-0.27 (tem, the introduction of threads to the Dylan producer is not expected to introduce any further loss) 63.65 209.95 P
(of ef) 63.65 195.95 T
(\336ciency) 85.75 195.95 T
(, compared to an architecture speci\336c implementation.) 122.96 195.95 T
3 15 Q
(3.) 63.65 156.95 T
(Threads) 90.65 156.95 T
2 12 Q
0.3 0.02 (A) 63.65 137.95 B
1 F
0.3 0.02 (thr) 75.65 137.95 B
0.3 0.02 (ead) 89.26 137.95 B
2 F
0.3 0.02 (, or lightweight process, is an independent f) 106.64 137.95 B
0.3 0.02 (low of control in a single address space that) 318.51 137.95 B
0.3 0.1 (may share that address space with other threads. Three basic kinds of thread scheduling can be) 63.65 123.95 B
0.3 0.06 (distinguished. Threads may run truly concurrently on a shared memory multiprocessor) 63.65 109.95 B
0.3 0.06 (. Threads) 486.25 109.95 B
FMENDPAGE
%%EndPage: "1" 6
%%Page: "2" 7
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(2) 63.65 84.9 T
63.65 780.95 531.65 780.95 2 L
0 Z
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
0.3 0.17 (may be pseudo-parallel if scheduled by the host operating system, as is the case with a native) 63.65 736.95 B
0.3 0.04 (thread implementation on a uni-processor) 63.65 722.95 B
0.3 0.04 (. Finally) 265.84 722.95 B
0.3 0.04 (, threads may be run pseudo-parallel as corou-) 305.75 722.95 B
-0.05 (tines, as is typically the case with a thread library) 63.65 708.95 P
-0.05 (. T) 299.02 708.95 P
-0.05 (ruly concurrent implementations may provide) 311.89 708.95 P
(pseudo-parallel thread scheduling when there are more threads than processors.) 63.65 694.95 T
0.67 (Scheduling models may be pre-emptive or cooperative. A pre-emptive model allows a thread to) 63.65 673.95 P
0.32 (be suspended at an arbitrary point, whereas a cooperative model only deschedules a thread when) 63.65 659.95 P
-0.25 (the thread performs some action, such as calling a routine that will yield to other runnable threads.) 63.65 645.95 P
-0.1 (Scheduling models may provide thread priorities; for example, a model may provide the invariant) 63.65 631.95 P
-0.06 (that no lower priority thread runs while a runnable higher priority thread is waiting. Such a model) 63.65 617.95 P
0.48 (is partially pre-emptive because higher priority processes can pre-empt those of a lower priority) 63.65 603.95 P
0.48 (,) 528.65 603.95 P
(but processes at the same priority are scheduled cooperatively) 63.65 588.35 T
(.) 360.13 588.35 T
2 7.2 Q
(1) 363.13 593.15 T
2 12 Q
0.83 (Since threads share a common address space they can communicate via shared variables. Some) 63.65 567.35 P
0.38 (means of synchronization must be provided to coordinate the use of such \050see the following sec-) 63.65 553.35 P
1.08 (tion\051. Asynchronous communication between threads need not be provided primitively) 63.65 539.35 P
1.08 (, since it) 489.17 539.35 P
(can be synthesised from other thread primitives.) 63.65 523.75 T
2 7.2 Q
(2) 294.61 528.55 T
3 12 Q
(3.1) 63.65 489.75 T
(Synchronization) 90.65 489.75 T
2 F
0.04 (Parallel programs depend on synchronization mechanisms to ensure their harmonious and correct) 63.65 471.75 P
0.02 (interaction. Synchronization provides ways for compound operations to be performed indivisibly) 63.65 457.75 P
0.02 (,) 528.65 457.75 P
0.3 0.06 (by serialising concurrent executions of such critical code sequences. T) 63.65 443.75 B
0.3 0.06 (wo basic synchronization) 407.69 443.75 B
-0.27 (mechanisms exist: busy waiting mechanisms using) 63.65 429.75 P
4 10 Q
-0.25 (test-and-set) 309.33 429.75 P
2 12 Q
-0.27 ( or) 362.14 429.75 P
4 10 Q
-0.25 (load-store interlocked) 377.58 429.75 P
2 12 Q
-0.27 ( instructions) 472.92 429.75 P
0.12 ([Edwards93], which may be very quick but may cause excessive locking of the bus, and schedul-) 63.65 415.75 P
0.3 0.08 (ing mechanisms which are slow to execute because they may entail suspending and resuming a) 63.65 401.75 B
0.3 0.14 (thread, but do not tie up valuable resources while contending for a lock. Such facilities can be) 63.65 387.75 B
-0.21 (built from spin-locks and thread scheduling primitives, but on a uniprocessor one may simply rely) 63.65 373.75 P
0.3 0.21 (on cooperative scheduling. The choice of mechanism will depend on the grain of the activity) 63.65 359.75 B
-0.19 (being serialized. It is only practical to use busy waiting for short activities that are unlikely to pro-) 63.65 345.75 P
(voke contention.) 63.65 331.75 T
1.26 (Parallel systems using a garbage collected shared heap have two main requirements for thread) 63.65 310.75 P
1.54 (synchronization. First, certain operations on the heap need to be) 63.65 296.75 P
1 F
1.54 (serialized) 389.02 296.75 P
2 F
1.54 (, so that compound) 435.69 296.75 P
-0.11 (operations are always executed atomically) 63.65 282.75 P
-0.11 (. For example, in many systems allocating an object via) 265.69 282.75 P
1.58 (incrementing an allocation pointer) 63.65 268.75 P
1.58 (, this involves reading the value of the allocation pointer to) 232.88 268.75 P
0.03 (derive a new object\325) 63.65 254.75 P
0.03 (s address, and then incrementing the allocation pointer by the object\325) 160.7 254.75 P
0.03 (s size. If) 491.27 254.75 P
1.09 (two threads attempt to allocate an object at the same time one possible interleaving is for both) 63.65 240.75 P
1.65 (threads to read the same value of the allocation pointer and subsequently increment it, which) 63.65 226.75 P
0.86 (results in a doubly allocated object, and a mispositioned allocation pointer) 63.65 212.75 P
0.86 (. It must therefore be) 427.9 212.75 P
63.65 191.95 531.65 204.95 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 199.95 171.65 199.95 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
-8.35 24.95 603.65 816.95 C
2 9 Q
0 X
0 0 0 1 0 0 0 K
-0.1 (1.  One issue is how a pre-empted process is rescheduled. For example, the Smalltalk scheduler as speci\336ed in [GR83] will place a) 63.65 185.95 P
0.48 (pre-empted process at the back of the queue of runnable processes for its priority) 63.65 175.95 P
0.48 (. Subsequent Smalltalk implementations [Parc-) 360.48 175.95 P
0.07 (Place] place a pre-empted process at the head of the queue of runnable processes for its priority) 63.65 165.95 P
0.07 (, maintaining a cooperative sched-) 407.63 165.95 P
(uling model within each priority) 63.65 155.95 T
(.) 179.56 155.95 T
0.41 (2.  For example, asynchronous i/o noti\336cation can be implemented by one thread forking another thread to perform blocking i/o) 63.65 142.95 P
0.18 (which then sets a shared variable to signal the possibility of i/o. T) 63.65 132.95 P
0.18 (ruly asynchronous noti\336cation also typically requires the use of) 301.73 132.95 P
-0.15 (shared variables, because the only communication a signal handler has with its thread is via change of state, for example by setting) 63.65 122.95 P
(\337ag variables.) 63.65 112.95 T
FMENDPAGE
%%EndPage: "2" 7
%%Page: "3" 8
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(3) 526.09 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
-0.1 (possible to ensure that allocations occur serially without interleaving. On systems with a coopera-) 63.65 736.95 P
-0.27 (tive scheduler on a uniprocessor this situation may never occur) 63.65 722.95 P
-0.27 (, and hence no special machinery is) 362.99 722.95 P
1.67 (required. On pre-emptive schedulers, or true multiprocessors spin-locking is more appropriate) 63.65 708.95 P
(than a scheduling mechanism since allocation is a relatively high-frequency operation.) 63.65 694.95 T
1.38 (Secondly) 63.65 673.95 P
1.38 (, course-grain atomic operations need to be serialized using a scheduling mechanism.) 107.53 673.95 P
0.68 (One such activity peculiar to many practical concurrent garbage collectors is the need to update) 63.65 659.95 P
0.17 (references from thread-local registers and stacks to moved objects. This depends on the ability to) 63.65 645.95 P
(stop and subsequently restart all non-garbage-collector threads.) 63.65 631.95 T
3 F
(3.2) 63.65 597.95 T
(A Dylan Thread Model) 90.65 597.95 T
2 F
0.3 0.15 (A high-level object-oriented language such as Smalltalk, Common Lisp, or Dylan provides an) 63.65 579.95 B
0.3 0.2 (excellent basis for the provision of elegant parallel programming constructs. Since the object) 63.65 565.95 B
0.3 0.1 (models in these systems provide information hiding and encapsulation it is natural to hide syn-) 63.65 551.95 B
0.3 0.1 (chronization behind the languages\325 own implementations of these features. High-level services) 63.65 537.95 B
0.3 0.08 (such as Smalltalk\325) 63.65 523.95 B
0.3 0.08 (s) 152.95 523.95 B
4 10 Q
0.28 0.08 (SharedQueue) 161.07 523.95 B
2 12 Q
0.3 0.08 ( \050through which producers can safely and asynchronously pass) 224.17 523.95 B
-0.04 (values to consumers\051 are constructed from lower level facilities such as semaphores and mutexes.) 63.65 509.95 P
-0.15 (These services are used via message passing or generic function invocation, hiding the synchroni-) 63.65 495.95 P
0.3 0.24 (zation and its implementation, and hence require no explicit synchronization code in clients.) 63.65 481.95 B
0.3 0.02 (Anonymous functions \050lambdas\051 provide a convenient basis for thread abstractions; in Smalltalk) 63.65 467.95 B
0.3 0.09 (and many Common Lisp implementations \050for example:) 63.65 453.95 B
1 F
0.3 0.09 (LispW) 343.46 453.95 B
0.3 0.09 (orks) 373.49 453.95 B
2 F
0.3 0.09 (, Harlequin\325) 394.52 453.95 B
0.3 0.09 (s Common Lisp) 453.26 453.95 B
0.3 0.04 (development environment\051 one can create a thread by invoking a) 63.65 439.95 B
1 F
0.3 0.04 (fork) 383.97 439.95 B
2 F
0.3 0.04 ( operation upon an anony-) 403.48 439.95 B
0.3 0.17 (mous function. A thread is typically represented in the system as an object which implements) 63.65 425.95 B
0.3 0.02 (methods for suspension, resumption, and termination, and has state def) 63.65 411.95 B
0.3 0.02 (ining its priority and exe-) 407.89 411.95 B
0.3 0.01 (cution context. The thread model can be enriched, for example through subclassing, adding slots) 63.65 397.95 B
(to hold additional information such as thread parent-child links.) 63.65 383.95 T
(W) 63.65 362.95 T
(e propose that a Dylan thread model provide at least:) 74.02 362.95 T
5 11 Q
(\245) 63.65 341.95 T
2 12 Q
0.3 0.14 (a thread class, instances of which represent underlying system threads. It is possible to sus-) 77.39 341.95 B
0.27 (pend, resume and terminate a thread, and possible to assign the processing priority of a thread) 77.39 327.95 P
(while it is suspended.) 77.39 313.95 T
5 11 Q
(\245) 63.65 295.95 T
2 12 Q
0.3 0.04 (a semaphore class, instances of which represent counting semaphores, and support the opera-) 77.39 295.95 B
0.12 (tions signal and wait. A thread executing a wait on a semaphore with no outstanding signals is) 77.39 281.95 P
0.3 0.2 (suspended and added to the end of a queue of threads waiting on that semaphore. A signal) 77.39 267.95 B
0.3 0 (operation either removes the f) 77.39 253.95 B
0.3 0 (irst suspended thread waiting on the semaphore from that sema-) 221.93 253.95 B
0.3 0.08 (phore\325) 77.39 239.95 B
0.3 0.08 (s queue and resumes the thread, or increments the semaphore\325) 108.53 239.95 B
0.3 0.08 (s count if no threads are) 413.27 239.95 B
(queued.) 77.39 225.95 T
5 11 Q
(\245) 63.65 207.95 T
2 12 Q
0.3 0.1 (a scheduler class, instances of which represent the pool of runnable threads, with operations) 77.39 207.95 B
(that give access to the current thread, all threads at a particular priority level etc.) 77.39 193.95 T
3 F
(3.3) 63.65 159.95 T
(Implementation of the Dylan Thread Model in TDF) 90.65 159.95 T
2 F
0.09 (The proposed Dylan thread library provides a simple, portable, object oriented interface to thread) 63.65 141.95 P
0.3 0.01 (based computation. While there is an attempt to make the library integrate well with the features) 63.65 127.95 B
0 (of the Dylan language, there is no attempt to make the library make use of any unusual properties) 63.65 113.95 P
FMENDPAGE
%%EndPage: "3" 8
%%Page: "4" 9
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(4) 63.65 84.9 T
63.65 780.95 531.65 780.95 2 L
0 Z
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
0.09 (of threads. This means that any threads mechanism which has been designed to support more tra-) 63.65 736.95 P
-0.25 (ditional languages can also be used to support Dylan threads. In particular) 63.65 722.95 P
-0.25 (, basic thread operations) 415.74 722.95 P
0.3 0.17 (such as creation, deletion, synchronization and scheduling can all be implemented in terms of) 63.65 708.95 B
0.3 0.51 (either the low level TDF token interface called the \322Experimental Basic Thread Model\323) 63.65 694.95 B
([Edwards93] or any standard threads API.) 63.65 680.95 T
0.22 (It is anticipated that there will be a separate implementation of the Dylan threads library for each) 63.65 659.95 P
0.21 (standard threads API, and for the low level token interface. There is a hope, however) 63.65 645.95 P
0.21 (, that it may) 473.68 645.95 P
-0.02 (be possible to have a single, architecture neutral implementation of the threads library which uses) 63.65 631.95 P
0.89 (an interface of Dylan-speci\336c TDF tokens. T) 63.65 617.95 P
0.89 (oken de\336nitions for this library would expand into) 283.76 617.95 P
0.36 (either API calls or the low level tokens, as appropriate. This interface has not yet been designed,) 63.65 603.95 P
(and it is not essential to have this architecture neutral threads library for Dylan.) 63.65 589.95 T
2.61 (The details of the Experimental Basic Threads Model are not discussed here \321 since it is) 63.65 568.95 P
-0.3 (expected they will work as well for Dylan as for any other language. However) 63.65 554.95 P
-0.3 (, there are some fea-) 435.21 554.95 P
0.27 (tures of Dylan which require special implementation in TDF for serial computation, and some of) 63.65 540.95 P
0.92 (these require additional support for parallel computation; these features are: garbage collection,) 63.65 526.95 P
-0.14 (the dynamic environment and exceptions. Garbage collection is a complex issue, and is dealt with) 63.65 512.95 P
(in sections 5 and 6. The other requirements are considered in this section.) 63.65 498.95 T
3 10 Q
(3.3.1) 63.65 474.29 T
(Implementation of the dynamic environment with multiple threads) 90.65 474.29 T
2 12 Q
0.3 0.05 (Dylan provides language constructs which have) 63.65 459.95 B
1 F
0.3 0.05 (dynamic scope) 300.15 459.95 B
2 F
0.3 0.05 (. Each such construct establishes) 372.02 459.95 B
0.3 0.21 (an entry in the) 63.65 445.95 B
1 F
0.3 0.21 (dynamic envir) 140.15 445.95 B
0.3 0.21 (onment) 211.01 445.95 B
2 F
0.3 0.21 ( \050potentially visible from anywhere in the program\051, and) 247.58 445.95 B
0.3 0.14 (explicitly disestablishes it on exit. An exit may occur either through normal completion of the) 63.65 431.95 B
0.03 (construct, or by any transfer of control out of the construct. These features are de\336ned in terms of) 63.65 417.95 P
0.22 (a stack based model of computation, and must be extended to support multiple dynamic environ-) 63.65 403.95 P
0.3 0.14 (ments on separate stacks when threads are introduced. Semantically) 63.65 389.95 B
0.3 0.14 (, this means the constructs) 400.38 389.95 B
-0 (only ef) 63.65 375.95 P
-0 (fect the dynamic environment of the thread in which they are executed. Dylan has a subset) 97.09 375.95 P
0.3 0.03 (of the dynamically scoped features of Common Lisp which are described in [Mann93]. The fea-) 63.65 361.95 B
(tures it does provide are) 63.65 347.95 T
4 10 Q
(unwind-protect) 181.96 347.95 T
2 12 Q
( and) 247.54 347.95 T
4 10 Q
(handler-bind) 270.86 347.95 T
2 12 Q
(.) 326.44 347.95 T
0.49 (The purpose of) 63.65 326.95 P
4 10 Q
0.46 (unwind-protect) 140.77 326.95 P
2 12 Q
0.49 ( is to guarantee that a section of) 206.35 326.95 P
1 F
0.49 (clean-up) 365.58 326.95 P
2 F
0.49 ( code will always be exe-) 407.56 326.95 P
-0.23 (cuted after a section of) 63.65 312.95 P
1 F
-0.23 (pr) 174.81 312.95 P
-0.23 (otected) 185.03 312.95 P
2 F
-0.23 ( code \321 even if a transfer of control should occur during the exe-) 219.69 312.95 P
0.51 (cution of the protected code \050for example, because an exception handler causes a premature exit) 63.65 298.95 P
4.88 (from the protected code\051. Implementation techniques for) 63.65 284.95 P
4 10 Q
4.53 (unwind-protect) 372.44 284.95 P
2 12 Q
4.88 ( are described in) 438.02 284.95 P
-0.03 ([Mann93]. Basically) 63.65 270.95 P
-0.03 (, the techniques involve building an) 161.49 270.95 P
1 F
-0.03 (unwind pr) 335.63 270.95 P
-0.03 (otect frame) 384.16 270.95 P
2 F
-0.03 ( on the stack when-) 438.46 270.95 P
0.98 (ever the construct is encountered. The normal execution stack is therefore used to maintain the) 63.65 256.95 P
0.49 (stack of the currently active clean-up code references. Whenever a transfer of control occurs, all) 63.65 242.95 P
0.55 (intervening unwind protect frames must be located, and the clean-up code executed. The frames) 63.65 228.95 P
1.57 (can be found by chaining them together on the stack, so each frame points to the next oldest) 63.65 214.95 P
-0.21 (frame. The most recent frame is found by looking in a global variable \050at a de\336ned location or in a) 63.65 200.95 P
(register\051.) 63.65 186.95 T
4 10 Q
0.46 (handler-bind) 63.65 165.95 P
2 12 Q
0.5 ( is a language construct which allows handlers to be initialized for) 119.23 165.95 P
1 F
0.5 (conditions) 445.82 165.95 P
2 F
0.5 (, which) 495.82 165.95 P
0.16 (are objects which represent exceptions. Dylan de\336nes a programmer) 63.65 151.95 P
0.16 (-extensible hierarchy of con-) 392.89 151.95 P
1.28 (dition classes, which represent the dif) 63.65 137.95 P
1.28 (ferent types of exceptions which might occur \321 such as) 250.48 137.95 P
1.58 (warnings or errors. If an exception should occur within the dynamic scope of the) 63.65 123.95 P
4 10 Q
1.47 (handler-bind) 476.07 123.95 P
2 12 Q
-0.11 (body) 63.65 109.95 P
-0.11 (, then the condition signalling mechanism will call the handler) 86.87 109.95 P
-0.11 (, provided the class of the con-) 384.69 109.95 P
FMENDPAGE
%%EndPage: "4" 9
%%Page: "5" 10
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(5) 526.09 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
-0.08 (dition matches the class of the handler) 63.65 736.95 P
-0.08 (, and there was no more recent handler to handle the excep-) 246.64 736.95 P
2.46 (tion. The handler is called by the exception signaller with a normal function call, and it is) 63.65 722.95 P
1.79 (executed above the stack frame of the function which raised the exception. The handler may) 63.65 708.95 P
0.11 (choose what action to take, \050including declining to handle the exception, by calling the next most) 63.65 694.95 P
1.07 (recent handler\051. T) 63.65 680.95 P
1.07 (ypically) 150.59 680.95 P
1.07 (, the handler will transfer control to the execution context in which it) 188.47 680.95 P
(was de\336ned.) 63.65 666.95 T
0.7 (For Common Lisp,) 63.65 645.95 P
4 10 Q
0.65 (handler-bind) 160.44 645.95 P
2 12 Q
0.7 ( is implemented in terms of lower level primitives, such as) 216.02 645.95 P
4 10 Q
0.65 (catch) 507.75 645.95 P
2 12 Q
0.16 (and) 63.65 631.95 P
1 F
0.16 (special binding) 84.14 631.95 P
2 F
0.16 ( [Mann93]. In Dylan, these lower level primitives are not available \321 but the) 157.96 631.95 P
0.65 (implementation techniques will be similar) 63.65 617.95 P
0.65 (. Conceptually) 267.59 617.95 P
0.65 (, a) 337.46 617.95 P
1 F
0.65 (handler frame) 353.1 617.95 P
2 F
0.65 ( will be created on the) 422.08 617.95 P
0.34 (stack, in the same way as for an unwind protect frame. Frames for both constructs will be linked) 63.65 603.95 P
0.36 (in the same chain of dynamic frames \050which represents the dynamic environment\051, and the same) 63.65 589.95 P
0.13 (location is used to point to the most recent frame \050of either type\051. Whenever an exception occurs,) 63.65 575.95 P
-0.1 (the signaller must test each handler frame for appropriate handlers to determine the ordered list of) 63.65 561.95 P
(applicable handlers.) 63.65 547.95 T
0.22 (Since) 63.65 526.95 P
4 10 Q
0.21 (handler-bind) 93.54 526.95 P
2 12 Q
0.22 ( and) 149.12 526.95 P
4 10 Q
0.21 (unwind-protect) 172.89 526.95 P
2 12 Q
0.22 ( are implemented in terms of the normal execution stack, the) 238.47 526.95 P
0.21 (mechanism scales for multiple threads \050and hence multiple execution stacks\051 in a simple manner) 63.65 512.95 P
0.21 (.) 528.65 512.95 P
-0.15 (However) 63.65 498.95 P
-0.15 (, it is a requirement for each thread to maintain an independent location for the pointer to) 107.15 498.95 P
0.16 (the most recent frame. For pseudo-parallel threads, it is possible to achieve this without any TDF) 63.65 484.95 P
0.09 (support by arranging for a run-time system to update a global variable with the thread local value) 63.65 470.95 P
0.86 (of this frame pointer on each context switch. However) 63.65 456.95 P
0.86 (, for concurrent threads it is necessary to) 331 456.95 P
(have a truly thread local variable to implement this.) 63.65 442.95 T
0.83 (A native code compiler might implement the thread local variable for the most recent frame by) 63.65 421.95 P
0.43 (reserving a register for this purpose \050since registers are necessarily thread local\051. However) 63.65 407.95 P
0.43 (, there) 501.23 407.95 P
0.4 (is no way to specify this in TDF) 63.65 393.95 P
0.4 (. The only portable mechanism is to pass the pointer to the most) 219.84 393.95 P
0.05 (recent frame as a parameter on every language function call. Of course, this would have a serious) 63.65 379.95 P
(impact on performance if the installer is unable to optimize this parameter in a register) 63.65 365.95 T
(.) 478.25 365.95 T
2.45 (For concurrent threads, it is therefore a requirement for Dylan that there is some means of) 63.65 344.95 P
-0.06 (describing a thread local variable in TDF) 63.65 330.95 P
-0.06 (. As with other features related to parallelism, there is no) 259.62 330.95 P
0.27 (direct TDF support for this. Instead the feature will be implemented in terms of token de\336nitions) 63.65 316.95 P
0.15 (and possible support from the run-time system \321 as with the basic threads library itself. By inte-) 63.65 302.95 P
1.92 (grating these token de\336nitions with the Dylan token library de\336nitions for function calling it) 63.65 288.95 P
-0.15 (should be possible to implement thread local variables by parameter passing as a last resort mech-) 63.65 274.95 P
(anism.) 63.65 260.95 T
3 10 Q
(3.3.2) 63.65 236.29 T
(Implementation of exceptions with multiple threads) 90.65 236.29 T
2 12 Q
1.26 (The dynamic mechanisms for handling exceptions have been described above. But the mecha-) 63.65 221.95 P
0.06 (nisms for generating exceptions must also work with threads. These mechanisms are described in) 63.65 207.95 P
0.61 ([Currie93]. In particular) 63.65 193.95 P
0.61 (, the following TDF constructs must have an ef) 180.01 193.95 P
0.61 (fect which is local to the) 410.96 193.95 P
(thread in which they are used:) 63.65 179.95 T
4 F
(set_stack_limit) 99.65 165.95 T
(give_stack_limit) 207.65 165.95 T
2 F
(Similarly) 63.65 151.95 T
(, the following constructs which describe exception detection must work for all threads:) 107.54 151.95 T
4 F
(~set_signal_handler) 99.65 137.95 T
2 F
0.42 (It is assumed it will not be dif) 63.65 123.95 P
0.42 (\336cult for these constructs to support threads \321 but it is noted here) 209.35 123.95 P
(that this is a requirement for Dylan.) 63.65 109.95 T
FMENDPAGE
%%EndPage: "5" 10
%%Page: "6" 11
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(6) 63.65 84.9 T
63.65 780.95 531.65 780.95 2 L
0 Z
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
3 15 Q
(4.) 63.65 734.95 T
(Garbage Collection Algorithms for Threads) 90.65 734.95 T
3 12 Q
(4.1) 63.65 699.95 T
(Heap-Based Automatic Storage Management) 90.65 699.95 T
2 F
0.27 (In systems that provide heap-based automatic storage management, the heap may be viewed as a) 63.65 681.95 P
0.16 (directed graph whose nodes are) 63.65 667.95 P
1 F
0.16 (objects) 218.75 667.95 P
2 F
0.16 (, variable length regions of the heap, and whose edges are) 252.75 667.95 P
1 F
0.3 0.01 (pointers) 63.65 653.95 B
2 F
0.3 0.01 (, or) 103.08 653.95 B
1 F
0.3 0.01 (r) 122.74 653.95 B
0.3 0.01 (efer) 126.97 653.95 B
0.3 0.01 (ences) 145.24 653.95 B
2 F
0.3 0.01 ( from objects \050) 171.95 653.95 B
1 F
0.3 0.01 (r) 243.36 653.95 B
0.3 0.01 (efer) 247.59 653.95 B
0.3 0.01 (ees) 265.86 653.95 B
2 F
0.3 0.01 (\051 to other objects \050) 281.22 653.95 B
1 F
0.3 0.01 (r) 370.65 653.95 B
0.3 0.01 (efer) 374.88 653.95 B
0.3 0.01 (ents) 393.15 653.95 B
2 F
0.3 0.01 (\051. Depending on the sys-) 412.53 653.95 B
-0.08 (tem an object may contain only pointers, only non-pointer data or a mixture of both. The program) 63.65 639.95 P
0.12 (contains references to the graph, which are termed the) 63.65 625.95 P
1 F
0.12 (r) 327.3 625.95 P
0.12 (oots) 331.52 625.95 P
2 F
0.12 (. The program may alter the graph by) 351.53 625.95 P
0.17 (allocating new objects and by changing the edges to refer to other objects by assigning to pointer) 63.65 611.95 P
0.13 (\336elds in objects, and hence is termed the) 63.65 597.95 P
1 F
0.13 (mutator) 262.32 597.95 P
2 F
0.13 (. In the context of concurrent systems there may) 299.66 597.95 P
(be many threads, more than one of which may be a mutator) 63.65 583.95 T
(.) 348.26 583.95 T
-0.12 (As a result of mutator activity parts of the graph may become detached from the transitive closure) 63.65 562.95 P
1.16 (of references \050formed by transitively following edges from the roots until all reachable objects) 63.65 548.95 P
0.49 (have been enumerated\051. This unused space is called) 63.65 534.95 P
1 F
0.49 (garbage) 318.54 534.95 P
2 F
0.49 (; the job of the) 358.53 534.95 P
1 F
0.49 (garbage) 434 534.95 P
0.49 (collector) 477.49 534.95 P
2 F
0.49 ( is) 520.15 534.95 P
0.34 (to identify and reclaim it. Garbage collection \050GC\051 can therefore be viewed as a per) 63.65 520.95 P
0.34 (-object proof) 469 520.95 P
0.84 (of reachability from the roots. Algorithms which perform this proof by traversing the graph are) 63.65 506.95 P
1 F
0.01 (tracing) 63.65 492.95 P
2 F
0.01 ( collectors, whereas algorithms which perform this proof by counting the number of edges) 98.32 492.95 P
(into nodes are) 63.65 478.95 T
1 F
(r) 133.97 478.95 T
(efer) 138.19 478.95 T
(ence counting) 156.41 478.95 T
2 F
( collectors.) 223.39 478.95 T
1 F
0.06 (Incr) 63.65 457.95 P
0.06 (emental) 83.2 457.95 P
2 F
0.06 ( collectors attempt to collect objects interleaved with mutator activity) 121.19 457.95 P
0.06 (, and concurrent) 453.89 457.95 P
0.44 (systems allow more than one mutator to share the heap in parallel. In both cases heap manipula-) 63.65 443.95 P
1.12 (tion must be coordinated. Abstractly) 63.65 429.95 P
1.12 (, coordination is realised by the mutator\050s\051 having to cross) 242.31 429.95 P
0.49 (barriers before performing certain heap operations. A mutator may have to use a) 63.65 415.95 P
1 F
0.49 (r) 458.6 415.95 P
0.49 (ead-barrier) 462.83 415.95 P
2 F
0.49 ( to) 518.82 415.95 P
0.65 (indirect through a reference, a) 63.65 401.95 P
1 F
0.65 (write-barrier) 214.18 401.95 P
2 F
0.65 ( to store a reference, or an) 277.51 401.95 P
1 F
0.65 (allocation-barrier) 410.01 401.95 P
2 F
0.65 ( before) 497.35 401.95 P
0.26 (allocating an object. The barriers can serve to notify the collector of changes to the graph, and to) 63.65 387.95 P
1 F
-0.09 (serialize) 63.65 373.95 P
2 F
-0.09 ( accesses to the graph so that all possible interleavings of \050possibly multiple\051 mutator and) 104.32 373.95 P
0.52 (collector heap accesses leave the heap in a consistent state. For example, if objects are allocated) 63.65 359.95 P
1.44 (from a free list, an object must be removed from the head of the list, and the head of the list) 63.65 345.95 P
(updated atomically if the object is not to be inadvertently allocated twice.) 63.65 331.95 T
3 F
(4.2) 63.65 297.95 T
(Basic Algorithms) 90.65 297.95 T
2 F
0.3 0.04 (There are three basic GC algorithms;) 63.65 279.95 B
1 F
0.3 0.04 (r) 247.46 279.95 B
0.3 0.04 (efer) 251.72 279.95 B
0.3 0.04 (ence counting) 270.08 279.95 B
2 F
0.3 0.04 (,) 337.86 279.95 B
1 F
0.3 0.04 (mark-sweep) 344.23 279.95 B
2 F
0.3 0.04 (, and) 402.59 279.95 B
1 F
0.3 0.04 (copying) 429.74 279.95 B
2 F
0.3 0.04 ( garbage col-) 467.99 279.95 B
0.3 0.13 (lection, all of which have been used as the starting point for implementing concurrent garbage) 63.65 265.95 B
0.3 0.13 (collectors. Important variants of the latter two algorithms are) 63.65 251.95 B
1 F
0.3 0.13 (mark-compact) 370.2 251.95 B
2 F
0.3 0.13 (,) 441.11 251.95 B
1 F
0.3 0.13 (generational) 447.68 251.95 B
2 F
0.3 0.13 ( and) 510.62 251.95 B
1 F
0.3 0.02 (conservative) 63.65 237.95 B
2 F
0.3 0.02 ( collectors. W) 124.52 237.95 B
0.3 0.02 (e will f) 191.4 237.95 B
0.3 0.02 (irst give a brief overview of these algorithms before discussing) 225.49 237.95 B
0.3 0.01 (their parallel variants. A fuller treatment of current GC technology was given in [Mann93a], and) 63.65 223.95 B
0.13 (thorough reviews can be found in [AMR92][W) 63.65 209.95 P
0.13 (ilson92]. Reference counting was not discussed in) 290.57 209.95 P
0.3 0.06 ([Mann93a] because the technique has signif) 63.65 195.95 B
0.3 0.06 (icantly inferior performance to tracing collectors on) 278.03 195.95 B
(uni-processors, but it) 63.65 181.95 T
1 F
(does) 167.64 181.95 T
2 F
(have its uses in a concurrent context) 192.64 181.95 T
2 7.2 Q
(1) 366.6 186.75 T
2 12 Q
(, and so will be discussed here.) 370.2 181.95 T
1.85 (In reference counting garbage collectors each object has an associated reference count which) 63.65 160.95 P
-0.13 (records the number of references to that object. Counts are maintained using a write barrier; when) 63.65 146.95 P
63.65 118.95 531.65 131.95 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 126.95 171.65 126.95 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
-8.35 24.95 603.65 816.95 C
2 9 Q
0 X
0 0 0 1 0 0 0 K
(1.  This is widely used in distributed garbage collection algorithms [AMR92].) 63.65 112.95 T
FMENDPAGE
%%EndPage: "6" 11
%%Page: "7" 12
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(7) 526.09 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
-0.23 (an assignment to a slot occurs the previous reference in the slot is overwritten, so the previous ref-) 63.65 736.95 P
1.54 (erent has its count decremented, whilst the new referent acquires a reference, and its count is) 63.65 722.95 P
0.01 (incremented. If an object\325) 63.65 708.95 P
0.01 (s reference count falls to zero \050due to a reference count decrement\051 then) 186.98 708.95 P
0.71 (the garbage collection system can infer that no references to the object exist and can collect the) 63.65 694.95 P
1.26 (object, returning it to the free space pool. At this point references from the collected object to) 63.65 680.95 P
-0.25 (other objects can also be destroyed) 63.65 665.35 P
2 7.2 Q
-0.15 (1) 230.02 670.15 P
2 12 Q
-0.25 (, possibly resulting in the reclamation of further objects, hence) 233.62 665.35 P
(the term) 63.65 651.35 T
1 F
(r) 106.31 651.35 T
(ecursive fr) 110.53 651.35 T
(eeing) 161.08 651.35 T
2 F
(.) 187.07 651.35 T
-0.23 (Reference counting is incremental, because garbage collection activity is interleaved with mutator) 63.65 630.35 P
1.55 (activity) 63.65 616.35 P
1.55 (. However) 98.87 616.35 P
1.55 (, reference counting is inef) 149.91 616.35 P
1.55 (\336cient, since it performs work proportional to the) 284.18 616.35 P
0.87 (number of objects collected, and requires the management of free storage with free lists, which) 63.65 602.35 P
0.88 (complicates allocation.) 63.65 588.35 P
1 F
0.88 (Deferr) 179.05 588.35 P
0.88 (ed) 210.6 588.35 P
2 F
0.88 ( reference counting [DB76] improves performance by avoiding) 221.93 588.35 P
1.53 (counting references from the stack\050s\051 by deferring reclamation. The collector batches together) 63.65 574.35 P
0.11 (collections by queuing objects whose count goes to zero in the) 63.65 560.35 P
1 F
0.11 (zer) 367.81 560.35 P
0.11 (o count table) 382.03 560.35 P
2 F
0.11 (. When necessary) 444.91 560.35 P
0.11 (,) 528.65 560.35 P
0.9 (the mutator\050s\051 are stopped, objects accessible from the stack are marked and the queue is proc-) 63.65 546.35 P
0.1 (essed. Any objects in the queue which still have a zero count \050or whose count falls to zero during) 63.65 532.35 P
0.23 (recursive freeing\051 that are not marked can then be collected. But the major problem for reference) 63.65 518.35 P
-0.22 (counting is its inability) 63.65 504.35 P
-0.22 (, in general, to reclaim circular structures because isolated cycles of objects) 172.55 504.35 P
0.6 (have non-zero reference counts from their mutual references. For these reasons reference count-) 63.65 490.35 P
0.83 (ing has fallen from grace and is no longer considered a state-of-the-art technique for serial gar-) 63.65 476.35 P
(bage collection systems.) 63.65 462.35 T
3.63 (Mark-sweep garbage collectors defer garbage detection to a point at which free space is) 63.65 441.35 P
1.47 (exhausted. At this point all live objects are identi\336ed, by transitively tracing object references) 63.65 427.35 P
0.06 (from the system\325) 63.65 413.35 P
0.06 (s roots \050any global variables and the current computation\325) 144.43 413.35 P
0.06 (s references, for exam-) 421.53 413.35 P
2.78 (ple registers and/or stack\051. Once this marking phase has completed, memory is swept, and) 63.65 399.35 P
0.1 (unmarked objects returned to the free space pool. The sweeping phase can be performed by com-) 63.65 385.35 P
1.28 (pacting the retained objects into a contiguous region thereby eliminating fragmentation of free) 63.65 371.35 P
1.51 (space. This is the) 63.65 357.35 P
1 F
1.51 (mark-compact) 155.34 357.35 P
2 F
1.51 ( variation of mark-sweep. Mark-sweep also copes with cyclic) 224.65 357.35 P
(garbage since unreachable cycles are not marked, and hence reclaimed) 63.65 341.75 T
2 7.2 Q
(2) 402.85 346.55 T
2 12 Q
(.) 406.45 341.75 T
1.8 (Copying garbage collectors combine the mark phase with the compaction phase. The heap is) 63.65 320.75 P
0.7 (divided into two) 63.65 306.75 P
1 F
0.7 (semispaces) 147.44 306.75 P
2 F
0.7 (,) 201.42 306.75 P
1 F
0.7 (fr) 208.13 306.75 P
0.7 (om-space) 215.69 306.75 P
2 F
0.7 ( and) 261.67 306.75 P
1 F
0.7 (to-space) 286.41 306.75 P
2 F
0.7 (. Only from-space is used to hold objects,) 327.07 306.75 P
0.68 (new objects being allocated contiguously at the end of from-space. The garbage collector traces) 63.65 292.75 P
-0.11 (objects in from-space, starting from the system\325) 63.65 278.75 P
-0.11 (s roots, and copies each object into to-space, leav-) 291.94 278.75 P
0.1 (ing behind a) 63.65 264.75 P
1 F
0.1 (forwar) 126.28 264.75 P
0.1 (ding pointer) 158.51 264.75 P
2 F
0.1 ( so subsequent references to the copied object can be relocated to) 217.62 264.75 P
0.96 (the to-space copy) 63.65 250.75 P
0.96 (. After copying, all live data are in to-space and free-space is empty) 148.76 250.75 P
0.96 (. The two) 484.07 250.75 P
0.62 (spaces are then) 63.65 236.75 P
1 F
0.62 (\337ipped) 141.16 236.75 P
2 F
0.62 (, from-space becoming the new to-space, and vice versa. Copying collec-) 173.82 236.75 P
(tors allow object allocation to be done simply by incrementing an allocation pointer) 63.65 222.75 T
(.) 464.95 222.75 T
0.75 (One very important variation of the copying algorithm is Baker) 63.65 201.75 P
0.75 (\325) 375.1 201.75 P
0.75 (s incremental copying collector) 378.44 201.75 P
0.31 ([Baker78], an incremental, real-time algorithm. The algorithm incrementally copies objects from) 63.65 187.75 P
0.4 (from-space to to-space, leaving forwarding pointers behind. This algorithm maintains the invari-) 63.65 173.75 P
63.65 151.95 531.65 164.95 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 159.95 171.65 159.95 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
-8.35 24.95 603.65 816.95 C
2 9 Q
0 X
0 0 0 1 0 0 0 K
0.04 (1.  the destruction of references in a collected object can be deferred to the point at which the object is reallocated. This technique) 63.65 145.95 P
(is used in some real-time reference counting systems to reduce the pause times caused by recursive freeing.) 63.65 135.95 T
-0.2 (2.  For these reasons most practical reference counting garbage collectors rely on a mark-sweep garbage collector to reclaim cycles) 63.65 122.95 P
(and compact free space [GR83][Rovner85].) 63.65 112.95 T
FMENDPAGE
%%EndPage: "7" 12
%%Page: "8" 13
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(8) 63.65 84.9 T
63.65 780.95 531.65 780.95 2 L
0 Z
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
1.49 (ant that the mutator sees only to-space pointers. The mutator uses a read barrier; each read is) 63.65 736.95 P
0.14 (checked, and if made to a forwarded object the reference is updated and the read is redone on the) 63.65 722.95 P
0.05 (to-space copy) 63.65 708.95 P
0.05 (. This requires hardware support to be ef) 129.23 708.95 P
0.05 (\336cient and so was not widely used until the) 323.95 708.95 P
0.17 (techniques outlined in section [4.3.2] were developed. The collector does a small amount of trac-) 63.65 694.95 P
(ing on each allocation and hence provides real-time performance.) 63.65 680.95 T
-0.25 (Real-time GC algorithms typically provide two guarantees: \336rst, no invocation of the garbage col-) 63.65 659.95 P
0.67 (lector will last longer than a given time, and second, in any chosen period the garbage collector) 63.65 645.95 P
0.75 (will not run for more than a given percentage of time. The \336rst guarantee allows the mutator to) 63.65 631.95 P
0.18 (respond to events within some \336xed bound, because it is not blocked awaiting termination of GC) 63.65 617.95 P
2.55 (for longer than the constraints allow) 63.65 603.95 P
2.55 (. The second guarantee allows the mutator to progress,) 249.27 603.95 P
-0.04 (because it has available to it at least some percentage of available processing power) 63.65 589.95 P
-0.04 (. One conven-) 464.08 589.95 P
0.38 (ient way of implementing such real-time GC algorithms is to structure the garbage collector as a) 63.65 575.95 P
0.21 (cooperating process, the real-time garbage collector) 63.65 561.95 P
0.21 (\325) 313.74 561.95 P
0.21 (s execution being interleaved with the muta-) 317.08 561.95 P
0.68 (tor) 63.65 547.95 P
0.68 (. Note that Baker) 76.32 547.95 P
0.68 (\325) 160.79 547.95 P
0.68 (s algorithm is ef) 164.13 547.95 P
0.68 (fectively structured as two cooperating processes, and con-) 243.62 547.95 P
1.47 (tains considerable pseudo-parallelism, the collectors\325 tracing and copying/forwarding activities) 63.65 533.95 P
0.83 (being parallel to the mutators\325 allocation and pointer forwarding activities. Consequently) 63.65 519.95 P
0.83 (, many) 498.15 519.95 P
0.47 (algorithms for real-time GC are concurrent, and vice versa, but one should not in general equate) 63.65 505.95 P
(real-time and concurrent GC algorithms.) 63.65 491.95 T
3 F
(4.3) 63.65 457.95 T
(Concurrent variants) 90.65 457.95 T
2 F
0.3 0.04 (Computation in a shared heap will require synchronization to implement certain algorithms cor-) 63.65 439.95 B
0.3 0.08 (rectly) 63.65 425.95 B
0.3 0.08 (. It is not the job of a concurrent garbage collector \050CGC\051 to provide such facilities, but it) 90.68 425.95 B
0.27 (must at least maintain the integrity of the heap \050create no dangling pointers\051, and provide tempo-) 63.65 411.95 P
-0.08 (ral coherence \050preserve the order of stores into memory\051. In addition, CGCs have two main goals,) 63.65 397.95 P
0.14 (\336rst to allow concurrent execution of threads that can share the same garbage collected heap, and) 63.65 383.95 P
(second to collect garbage concurrently with the execution of threads.) 63.65 369.95 T
3 10 Q
(4.3.1) 63.65 345.29 T
(Concurrent Reference Counting Collectors) 90.65 345.29 T
2 12 Q
0.01 (Both goals are easily met in a reference counting collector) 63.65 330.95 P
0.01 (. Multiple threads can share a reference) 342.67 330.95 P
0.3 0.27 (counted heap if reference increment, decrement and allocation from free lists are serialized.) 63.65 316.95 B
-0.2 (Recursive freeing involves further reference counting operations, and adding of objects to the free) 63.65 302.95 P
0.03 (list, so collection can easily be parallelised if the reference counting and free list update therein is) 63.65 288.95 P
(similarly serialized [BM93]) 63.65 274.95 T
2 7.2 Q
(1) 196.97 279.75 T
2 12 Q
(.) 200.57 274.95 T
0.64 (The Cedar [Rovner85] and T) 63.65 253.95 P
0.64 (opaz [DeT) 204.68 253.95 P
0.64 (reville90] collectors are deferred reference counting sys-) 255.88 253.95 P
1.07 (tem with a separate thread to do collection. Mutators use a lock to serialize reference counting) 63.65 239.95 P
-0.21 (operations. Another lock is used to control insertions into the zero count table. A \336nal lock is used) 63.65 225.95 P
2.22 (to serialize allocations. The collector thread processes the queue asynchronously) 63.65 211.95 P
2.22 (, performing) 469.44 211.95 P
(recursive freeing collection.) 63.65 197.95 T
3 10 Q
(4.3.2) 63.65 173.29 T
(Effective Barrier Methods) 90.65 173.29 T
2 12 Q
-0.13 (The Appel, Ellis & Li collector [AEL88], a version of Baker) 63.65 158.95 P
-0.13 (\325) 353.42 158.95 P
-0.13 (s algorithm, was the \336rst collector to) 356.76 158.95 P
63.65 130.95 531.65 143.95 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 138.95 171.65 138.95 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
-8.35 24.95 603.65 816.95 C
2 9 Q
0 X
0 0 0 1 0 0 0 K
1.33 (1.  However) 63.65 124.95 P
1.33 (, the scheme in [BM93] uses per) 110.18 124.95 P
1.33 (-object mutexes, which appears hard to implement ef) 234.7 124.95 P
1.33 (\336ciently in TDF) 434.8 124.95 P
1.33 (, since no) 494.74 124.95 P
(assumptions can be made about the space requirements of a mutex.) 63.65 113.95 T
FMENDPAGE
%%EndPage: "8" 13
%%Page: "9" 14
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(9) 526.09 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
1.25 (use virtual memory \050VM\051 facilities [AL91] to implement ef) 63.65 736.95 P
1.25 (\336cient read and write barriers. The) 359.43 736.95 P
1.23 (Appel, Ellis & Li scheme sets the VM protection of unscanned pages in from-space to be \322no) 63.65 722.95 P
-0.13 (access\323. Mutator reads of unscanned objects therefore provoke a VM trap. The collector \336elds the) 63.65 708.95 P
0.84 (trap, scans all objects on the page, copies them to to-space, and forwards pointers as necessary) 63.65 694.95 P
0.84 (.) 528.65 694.95 P
0.58 (The mutator is then restarted at the faulting instruction. The pointer fetched after the restart will) 63.65 680.95 P
0.46 (now refer to to-space, and execution continues. Since reads are much more frequent than writes,) 63.65 666.95 P
1.51 (attention has now focused on algorithms that depend only on a write-barrier) 63.65 652.95 P
1.51 (, and the ef) 444.02 652.95 P
1.51 (\336cient) 501.65 652.95 P
0.01 (implementation of write barriers. The paper by Moss et al. [HMS92] gives a performance evalua-) 63.65 638.95 P
-0.07 (tion of write barriers implemented using software \050such as the sequential store buf) 63.65 624.95 P
-0.07 (fer described in) 457.15 624.95 P
(below\051 or virtual memory protection.) 63.65 610.95 T
3 10 Q
(4.3.3) 63.65 586.29 T
(Concurrent T) 90.65 586.29 T
(racing Collectors) 152.88 586.29 T
2 12 Q
0.5 (T) 63.65 571.95 P
0.5 (racing collectors include mark-sweep and copying collectors since both strategies involve trac-) 70.56 571.95 P
0.07 (ing the graph of live objects starting from the roots to determine the set of live objects. If the sec-) 63.65 557.95 P
0.34 (ond goal of parallelising the garbage collector is to be met using a write-barrier then the garbage) 63.65 543.95 P
1.79 (collector must cope with mutator modi\336cations to the graph whilst tracing is in progress, for) 63.65 529.95 P
0.83 (example when newly allocated objects are assigned to parts of the graph that may already have) 63.65 515.95 P
-0.18 (been scanned. This is suf) 63.65 501.95 P
-0.18 (\336ciently problematical that if pause times for copying are low enough, as) 183.02 501.95 P
-0.19 (they are in generational schemes, it may be expedient to simply stop all threads, perform scaveng-) 63.65 487.95 P
(ing, and then resume [PU88].) 63.65 473.95 T
0.28 (The abstraction of) 63.65 452.95 P
1 F
0.28 (T) 154.82 452.95 P
0.28 (ri-colour marking) 160.83 452.95 P
2 F
0.28 ( [DLMSS78] is useful in explaining the workings of incre-) 247.44 452.95 P
1.24 (mental write-barrier schemes in both mark-sweep and copying algorithms. At the start of each) 63.65 438.95 P
0.7 (trace all objects are untraced, and to indicate this are coloured white. As tracing proceeds white) 63.65 424.95 P
0.7 (objects are encountered that must be traced. Such objects are coloured grey) 63.65 410.95 P
0.7 (. Once an object has) 431.86 410.95 P
0.14 (been traced it is coloured black) 63.65 395.35 P
2 7.2 Q
0.08 (1) 213.97 400.15 P
2 12 Q
0.14 (. The collector) 217.57 395.35 P
1 F
0.14 (must) 290.63 395.35 P
2 F
0.14 ( trace all of the used portions of the graph, so) 313.3 395.35 P
1.18 (the write barrier must check for the storing of white objects into black objects.) 63.65 379.75 P
2 7.2 Q
0.71 (2) 454.88 384.55 P
2 12 Q
1.18 ( There are two) 458.48 379.75 P
(basic approaches:) 63.65 365.75 T
1 F
(Snapshot-at-beginning) 151.62 365.75 T
2 F
(, and) 260.95 365.75 T
1 F
(Incr) 287.28 365.75 T
(emental-update) 306.83 365.75 T
2 F
( [W) 381.48 365.75 T
(ilson92].) 399.32 365.75 T
-0.11 (Snapshot-at-beginning algorithms maintain the invariant that all objects active at the beginning of) 63.65 344.75 P
0.12 (tracing will be retained. This is done with a write-barrier; the mutator places overwritten pointers) 63.65 330.75 P
1.12 (and newly allocated objects in a queue that is examined by the tracer once it has traversed the) 63.65 316.75 P
0.41 (heap [Y) 63.65 301.15 P
0.41 (uaza90]. This scheme has the disadvantage of being \322conservative\323) 101.04 301.15 P
2 7.2 Q
0.24 (3) 427.86 305.95 P
2 12 Q
0.41 ( because objects that) 431.46 301.15 P
(become unreachable are not reclaimed until the after next trace.) 63.65 287.15 T
0.67 (Incremental-update algorithms attempt to be \322less conservative\323 by gathering information about) 63.65 266.15 P
1.64 (updates as tracing proceeds. They ef) 63.65 252.15 P
1.64 (fectively maintain the minimum invariant, required of all) 246.22 252.15 P
0.51 (such garbage collectors, that objects live at the end of the tracing phase are retained. They solve) 63.65 238.15 P
-0.28 (the problem of storing references to white \050untraced\051 objects into black \050already traced\051 objects by) 63.65 224.15 P
1.74 (using a write-barrier) 63.65 210.15 P
1.74 (. When such a write occurs the collector can either turn the white object) 164.44 210.15 P
0.2 (black, or turn the black object grey and rescan it later) 63.65 196.15 P
0.2 (. At the end of the initial tracing phase trac-) 320.57 196.15 P
63.65 174.95 531.65 187.95 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 182.95 171.65 182.95 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
-8.35 24.95 603.65 816.95 C
2 9 Q
0 X
0 0 0 1 0 0 0 K
(1.  This can be seen as an extension of traditional marking where the only colours are white \050untraced\051 and black \050marked\051.) 63.65 168.95 T
-0.13 (2.  The problem of assigning a white object into a blackening object \050one in the process of being scanned\051 can either be handled by) 63.65 155.95 P
(scanning an object atomically) 63.65 145.95 T
(, or by turning it black before scanning, and rescanning if an assignment occurs.) 170.3 145.95 T
0.23 (3.  A confusing term! Here conservative refers to the fact that free storage is not reclaimed immediately) 63.65 132.95 P
0.23 (, but de\336nitely will be by) 439.97 132.95 P
-0.07 (the next cycle, whereas in) 63.65 122.95 P
1 F
-0.07 (conservative) 158.75 122.95 P
2 F
-0.07 ( collectors it refers to the fact that mistaken pointer identi\336cations may cause storage reten-) 204.24 122.95 P
(tion for an arbitrary length of time, or preclude its collection altogether) 63.65 112.95 T
(.) 318.61 112.95 T
FMENDPAGE
%%EndPage: "9" 14
%%Page: "10" 15
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(10) 63.65 84.9 T
63.65 780.95 531.65 780.95 2 L
0 Z
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
0.24 (ing must be completed; any remaining grey objects must be scanned. For mark-sweep collectors,) 63.65 736.95 P
-0.27 (only once this \336nal tracing is complete may memory be swept to reclaim storage. In copying algo-) 63.65 722.95 P
1.21 (rithms a \337ip must be performed. In Boehm\325) 63.65 708.95 P
1.21 (s mostly parallel collector [BDS91], a mark-sweep) 280.77 708.95 P
0.21 (algorithm, the tracing of remaining grey objects, and the sweeping of memory is done by the GC) 63.65 694.95 P
-0.02 (thread after it stops all mutator threads. Measurements show that the additional tracing takes little) 63.65 680.95 P
0.09 (extra time, and that sweeping takes even less, so pause times introduced by this phase are accept-) 63.65 666.95 P
(able.) 63.65 652.95 T
0.18 (VM write barriers are not always appropriate because trap handling can be expensive, some plat-) 63.65 631.95 P
0.46 (forms provide no such facilities, and because page-size granularity may cause too much work to) 63.65 617.95 P
1.72 (be done. O\325T) 63.65 603.95 P
1.72 (oole and Nettle\325) 129.89 603.95 P
1.72 (s concurrent replicating realtime collector [ON93] uses a simple) 209.98 603.95 P
1 F
1.52 (sequential stor) 63.65 589.95 P
1.52 (e buffer) 135.73 589.95 P
2 F
1.52 ( or) 174.25 589.95 P
1 F
1.52 (stor) 193.29 589.95 P
1.52 (elist) 211.51 589.95 P
2 F
1.52 ( where writes are recorded. On each write the mutator must) 231.52 589.95 P
-0.14 (place a reference to the written object into the storelist) 63.65 574.35 P
2 7.2 Q
-0.09 (1) 323.29 579.15 P
2 12 Q
-0.14 (. The collector incrementally builds a copy) 326.89 574.35 P
0.67 (of from-space in to-space using a conventional copying algorithm. The mutators use only from-) 63.65 560.35 P
0.49 (space. The collector has completed a collection once the storelist is empty) 63.65 546.35 P
0.49 (, all objects accessible) 423.53 546.35 P
0.72 (from the mutators\325 roots have been replicated in to-space, and all the mutators\325 roots have been) 63.65 532.35 P
(updated to refer to the to-space replicas.) 63.65 518.35 T
0.28 (Replication proceeds asynchronously; mutators must serialize access to the storelist and the allo-) 63.65 497.35 P
0.03 (cation pointer) 63.65 483.35 P
0.03 (. The collector can process entries in the storelist asynchronously and update the to-) 129.34 483.35 P
1.19 (space replicas of the from-space objects in the storelist. Once the storelist is empty it stops all) 63.65 469.35 P
1.13 (mutators, updates their roots, and \337ips. An important space optimization is to store forwarding) 63.65 455.35 P
1.17 (pointers in the headers of replicated from-space objects. This requires that mutators use a read) 63.65 441.35 P
0.02 (barrier to access header words, which is an infrequent activity) 63.65 427.35 P
0.02 (. No synchronization is required for) 360.27 427.35 P
-0.01 (this read barrier since the collector writes the header word into the to-space replica before writing) 63.65 413.35 P
0.16 (the forwarding pointer into the from-space object\325) 63.65 399.35 P
0.16 (s header; all that is required is that the memory) 304.57 399.35 P
-0.22 (system perform word writes atomically) 63.65 385.35 P
-0.22 (, and that a sequence of writes issued by a processor is per-) 250.64 385.35 P
(formed in order) 63.65 371.35 T
(.) 138.3 371.35 T
-0.04 (Common to all these systems is the need to serialize allocation. Contention for the allocation lock) 63.65 350.35 P
0.91 (can be radically reduced with copying algorithms by arranging that the allocator in each thread) 63.65 336.35 P
0.4 (grabs lar) 63.65 322.35 P
0.4 (ge chunks from the global allocation pointer which it uses to satisfy thread-local alloca-) 105.49 322.35 P
0.98 (tion requests by using a thread-local allocation pointer [FMY91], but this can pose problems if) 63.65 308.35 P
(there are a lar) 63.65 294.35 T
(ge number of threads [AEL88].) 129.06 294.35 T
3 15 Q
(5.) 63.65 255.35 T
(Implementing Garbage Collection Algorithms in TDF) 90.65 255.35 T
2 12 Q
0.3 0.17 (As has been discussed above, and in [Mann93a], garbage collection for Dylan in TDF will be) 63.65 236.35 B
-0.1 (implemented using a combination of a run-time system and a cooperating compiled program. The) 63.65 222.35 P
0.3 0.14 (TDF installer is responsible for the f) 63.65 208.35 B
0.3 0.14 (inal phase of creating the compiled program, and hence it) 244.92 208.35 B
(must be able to generate any support required by the run-time system.) 63.65 194.35 T
63.65 168.95 531.65 181.95 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 176.95 171.65 176.95 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
-8.35 24.95 603.65 816.95 C
2 9 Q
0 X
0 0 0 1 0 0 0 K
0.75 (1.  A software write barrier can be ef) 63.65 162.95 P
0.75 (\336cient compared with VM schemes if suf) 202.16 162.95 P
0.75 (\336cient care is taken. The main advantage of the) 355.46 162.95 P
0.2 (sequential store buf) 63.65 152.95 P
0.2 (fer is that on uni-processors it can be implemented as a short in-lined sequence of jump free instructions, giv-) 134.37 152.95 P
0.2 (ing good performance, with an acceptably small increase in code size. If the pointer to the store buf) 63.65 142.95 P
0.2 (fer is kept in a register then it) 424.53 142.95 P
-0.22 (may be implemented in as little as two instructions: increment the pointer and indirect through it. However) 63.65 132.95 P
-0.22 (, in a concurrent system,) 444.53 132.95 P
0.32 (explicit synchronization may be required, for example in a system with a shared sequential store buf) 63.65 122.95 P
0.32 (fer) 429.25 122.95 P
0.32 (. In cases such as these, a) 438.74 122.95 P
(software write barrier requires jump instructions, and a VM write barrier using page-based scanning may be more attractive.) 63.65 112.95 T
FMENDPAGE
%%EndPage: "10" 15
%%Page: "11" 16
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(1) 521.08 84.9 T
(1) 526.09 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
0.2 (The amount and the details of the cooperation between the program and the run-time system will) 63.65 736.95 P
1.19 (depend on the choice of the garbage collection algorithm. It is not practical to choose a single) 63.65 722.95 P
-0.17 (algorithm for garbage collection on all platforms as algorithms have very dif) 63.65 708.95 P
-0.17 (ferent characteristics,) 429.19 708.95 P
(and their relative ef) 63.65 694.95 T
(\336ciency may be very dependent on the nature of the program or the platform.) 157.07 694.95 T
0.6 (Whatever the chosen algorithm, it is known that cooperation is only required for certain distinct) 63.65 673.95 P
(operations, each of which may require some form of synchronization. These are:) 63.65 659.95 T
5 11 Q
(\245) 63.65 638.95 T
2 12 Q
(Allocation) 77.39 638.95 T
5 11 Q
(\245) 63.65 620.95 T
2 12 Q
(Reading from objects) 77.39 620.95 T
5 11 Q
(\245) 63.65 602.95 T
2 12 Q
(W) 77.39 602.95 T
(riting to objects) 88.24 602.95 T
5 11 Q
(\245) 63.65 584.95 T
2 12 Q
(Location of roots) 77.39 584.95 T
-0.04 (Although the details of the required cooperation for each of these operations is algorithm depend-) 63.65 556.95 P
0.58 (ent, portability may still be achieved by describing the cooperation in terms of an abstract inter-) 63.65 542.95 P
0.49 (face using TDF tokens. A particular algorithm will be supported by a combination of a run-time) 63.65 528.95 P
0.59 (system which implements the garbage collector) 63.65 514.95 P
0.59 (, and suitable token de\336nitions which implement) 294.43 514.95 P
0.67 (the cooperative support from the program. This principle is also used for implementing garbage) 63.65 500.95 P
(collection for serial programs [Mann93a] and for implementing parallelism itself [Edwards93].) 63.65 486.95 T
0.29 (The token library which will describe this cooperation has not yet been fully designed \321 but the) 63.65 465.95 P
(sections which follow show it is possible to express the cooperation in terms of tokens.) 63.65 451.95 T
3 F
(5.1) 63.65 417.95 T
(Synchronization for Garbage Collection in TDF) 90.65 417.95 T
2 F
0.3 0.22 (It was mentioned in section 3.1 that garbage collectors may require synchronization between) 63.65 399.95 B
0.3 0.1 (threads in order to serialize allocation and tracing operations. The requirement for allocation is) 63.65 385.95 B
0.3 0.05 (simply lightweight mutual exclusion, for which a TDF mechanism is described in [Edwards93].) 63.65 371.95 B
0.3 0.21 (In fact, this mutual exclusion will occur inside the run-time system, and will probably not be) 63.65 357.95 B
(implemented in terms of TDF) 63.65 343.95 T
(.) 206.02 343.95 T
1.28 (A possible requirement for synchronization during garbage collector tracing is that all mutator) 63.65 322.95 P
0.4 (threads are stopped while the garbage collector updates references from thread-local variables to) 63.65 308.95 P
-0.14 (relocated objects. This is a coarse-grain form of synchronization which is not a part of the Prelim-) 63.65 294.95 P
-0.24 (inary Parallel Extensions for TDF) 63.65 280.95 P
-0.24 (. The need for this exclusive right to computation resources only) 224.39 280.95 P
(occurs inside the garbage collector) 63.65 266.95 T
(, which is a part of the run-time system.) 229.79 266.95 T
-0.04 (Depending on the host system, it may be possible to implement the suspension of mutator threads) 63.65 245.95 P
0.3 (without requiring any support from TDF) 63.65 231.95 P
0.3 (. However) 259.18 231.95 P
0.3 (, if the host system does not provide a mecha-) 308.98 231.95 P
0.34 (nism for stopping and restarting other threads, and accessing their state, then the mutator threads) 63.65 217.95 P
0.41 (themselves must arrange to cooperate with the garbage collector) 63.65 203.95 P
0.41 (. It is possible to achieve this by) 374.82 203.95 P
-0.21 (arranging for each mutator thread to poll the garbage collector as part of the read and/or write bar-) 63.65 189.95 P
-0.06 (rier code. If the mutator thread determines that it is about to attempt a dangerous operation during) 63.65 175.95 P
0.64 (the critical stage of the garbage collector) 63.65 161.95 P
0.64 (, then it must arrange to suspend itself and restart itself) 262.28 161.95 P
-0.26 (appropriately) 63.65 147.95 P
-0.26 (. This may signi\336cantly add to the cost of the barrier \321 although it might be possible) 126.85 147.95 P
-0.18 (to do this with little or no extra cost as the part of the normal synchronization in the barrier) 63.65 133.95 P
-0.18 (. In any) 495.68 133.95 P
(case, this cost is not related to the use of TDF) 63.65 119.95 T
(.) 281.66 119.95 T
FMENDPAGE
%%EndPage: "11" 16
%%Page: "12" 17
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(12) 63.65 84.9 T
63.65 780.95 531.65 780.95 2 L
0 Z
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
2.31 (Some simple coding tricks can reduce the cost of barriers. Many synchronization primitives) 63.65 736.95 P
0.12 (depend on a read-modify-write cycle which requires locking the bus, and is potentially both slow) 63.65 722.95 P
0 (and prevents other bus accesses. A naive spin-lock might be written to attempt to get a lock using) 63.65 708.95 P
1.03 (a read-modify-write cycle in a tight loop. One common technique is to \336rst use a conventional) 63.65 694.95 P
(read cycle to check that the lock is free, and only then attempt the read-modify-write cycle.) 63.65 680.95 T
(Naive) 99.65 659.95 T
(Pragmatic) 351.65 659.95 T
6 10 Q
(get_lock:) 99.65 644.29 T
(get_lock:) 351.65 644.29 T
(loop:) 99.65 633.29 T
(loop:) 351.65 633.29 T
(test_and_set lock) 135.65 622.29 T
(read lock) 387.65 622.29 T
(if not got lock) 135.65 611.29 T
(if not lock free) 387.65 611.29 T
(jump loop) 171.65 600.29 T
(jump loop) 423.65 600.29 T
(got_lock:) 99.65 589.29 T
(test_and_set lock) 387.65 589.29 T
(if not got lock) 387.65 578.29 T
(jump loop) 423.65 567.29 T
(got_lock:) 351.65 556.29 T
2 12 Q
0.68 (In this way one can drastically reduce the number of read-modify-write cycles executed for fre-) 63.65 532.95 P
0.29 (quently accessed locks. Furthermore, the costs of coarse-grain thread GC synchronization can be) 63.65 518.95 P
0.28 (amortised within lock access. If threads need to poll to synchronize with the GC one can arrange) 63.65 504.95 P
(that polling only happens when an attempt to access a lock fails:) 63.65 490.95 T
6 10 Q
(get_lock:) 99.65 471.29 T
(read lock) 135.65 460.29 T
(if not lock free) 135.65 449.29 T
(jump poll) 171.65 438.29 T
(test_and_set lock) 135.65 427.29 T
(if not got lock) 135.65 416.29 T
(jump poll) 171.65 405.29 T
(jump got_lock) 135.65 394.29 T
(poll:) 99.65 383.29 T
(if GC_wants_to_synch) 135.65 372.29 T
(jump sync_with_GC) 171.65 361.29 T
(got_lock:) 99.65 350.29 T
2 12 Q
-0.15 (When the GC thread wants to synchronize it grabs the lock. Thus a thread only polls when it can\325) 63.65 326.95 P
-0.15 (t) 528.31 326.95 P
-0.05 (make progress because it has to wait for the lock to be released, or because the GC actually wants) 63.65 312.95 P
(to synchronize.) 63.65 298.95 T
3 F
(5.2) 63.65 264.95 T
(Allocation in TDF) 90.65 264.95 T
2 F
-0.24 (The interface between the program and the run-time system will be implemented in terms of a call) 63.65 246.95 P
0.27 (to a function in the run-time system. All allocation requests will be serviced by the run-time sys-) 63.65 232.95 P
0.15 (tem, which may require an allocation barrier for a concurrent system. The implementation of this) 63.65 218.95 P
(is solely the responsibility of the run-time system, and is therefore outside of the domain of TDF) 63.65 204.95 T
(.) 526.32 204.95 T
3 F
(5.3) 63.65 170.95 T
(Read and W) 90.65 170.95 T
(rite Barriers in TDF) 159.11 170.95 T
2 F
0.07 (It has been shown that either a read-barrier or a write-barrier \050or both\051 may be necessary to main-) 63.65 152.95 P
0.3 0.02 (tain a consistent view of live data as seen by the garbage collector and the running program. For) 63.65 138.95 B
0.3 0.04 (hardware implementations of barrier there is no need for the code of the program to contain any) 63.65 124.95 B
(explicit cooperation with the run-time system \321 when using a VM barrier) 63.65 110.95 T
(, for example.) 420.12 110.95 T
FMENDPAGE
%%EndPage: "12" 17
%%Page: "13" 18
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(13) 520.53 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 12 Q
0.53 (For software barriers however) 63.65 736.95 P
0.53 (, there must be explicit code in the program to implement the bar-) 209.7 736.95 P
0.17 (rier) 63.65 722.95 P
0.17 (. The nature of this explicit code is algorithm dependent. For a reference counting collector) 79.64 722.95 P
0.17 (, it) 518.8 722.95 P
0.42 (will be in the form of an update of the reference count, synchronized by a mutual exclusion. For) 63.65 708.95 P
0.34 (tracing collectors, the barrier may be implemented with an extra indirection, or with a sequential) 63.65 694.95 P
(store buf) 63.65 680.95 T
(fer) 105.76 680.95 T
(, amongst other successful techniques.) 118.6 680.95 T
0.35 (Whatever the details of the read or write barrier) 63.65 659.95 P
0.35 (, it is possible to provide an algorithm dependent) 294.54 659.95 P
0.26 (implementation by writing a suitable token de\336nition for read and write operations, and ensuring) 63.65 645.95 P
2.07 (that the Dylan producer generates a use of this token whenever the \336elds within objects are) 63.65 631.95 P
-0.25 (accessed. This mechanism is identical to that described in [Mann93a] for the support of incremen-) 63.65 617.95 P
(tal serial garbage collectors.) 63.65 603.95 T
3 F
(5.4) 63.65 569.95 T
(Locating Roots for Garbage Collection in TDF) 90.65 569.95 T
2 F
0.3 0.18 (Garbage collection roots include global variables and local variables. T) 63.65 551.95 B
0.3 0.18 (echniques for locating) 420.57 551.95 B
-0.27 (these roots in a serial computation model using TDF were described in [Mann93a]. The set of glo-) 63.65 537.95 P
0.3 0.03 (bal roots is static information for a given program, and it is straightforward to communicate this) 63.65 523.95 B
-0.07 (to the run-time system. The introduction of parallelism does not af) 63.65 509.95 P
-0.07 (fect the location of global roots) 381.69 509.95 P
(since these are shared by each thread.) 63.65 495.95 T
-0.23 (The introduction of parallelism does af) 63.65 474.95 P
-0.23 (fect local root determination, since there are local variables) 249.24 474.95 P
0.28 (associated with each thread. However) 63.65 460.95 P
0.28 (, the mechanism for locating local roots with serial compu-) 245.88 460.95 P
0.96 (tation [Mann93a] actually builds a linked chain on the stack of maps of live local variables for) 63.65 446.95 P
0.59 (each stack frame. Since this chain is maintained on the stack itself, the mechanism may be used) 63.65 432.95 P
(with equal ef) 63.65 418.95 T
(fect in the presence of multiple threads.) 126.08 418.95 T
0.74 (The garbage collector must arrange to scan the map of local variables for each thread. The way) 63.65 397.95 P
0.94 (this is done is algorithm dependent, and it may be done either with a parallel garbage collector) 63.65 383.95 P
0.62 (thread, or by a function call from a thread into the run-time system. In the former case, the run-) 63.65 369.95 P
-0.28 (time system is responsible for maintaining housekeeping information about where to \336nd the head) 63.65 355.95 P
0.54 (of the chain for each thread. In the latter case, the function call will be part of one of the barrier) 63.65 341.95 P
0.32 (activities \050either at a read, write or allocation request\051 and will be synchronized as appropriate in) 63.65 327.95 P
0.67 (the same way as all barrier operations. The head of the chain will be passed as a parameter to a) 63.65 313.95 P
0.2 (function in the run-time system, with the parameter in a known location, according to the normal) 63.65 299.95 P
(calling convention.) 63.65 284.35 T
2 7.2 Q
(1) 155.64 289.15 T
3 12 Q
(5.5) 63.65 250.35 T
(Expected costs and bene\336ts for TDF support) 90.65 250.35 T
2 F
0.3 0.15 (The addition of multiple threads to the garbage collector requirements for Dylan increases the) 63.65 232.35 B
0.3 0.02 (complexity of the garbage collector algorithms. However) 63.65 218.35 B
0.3 0.02 (, these algorithms may be implemented) 340.87 218.35 B
0.3 0.09 (in a platform dependent manner) 63.65 204.35 B
0.3 0.09 (, and will not suf) 220.39 204.35 B
0.3 0.09 (fer in performance compared with native code) 304.01 204.35 B
(implementations.) 63.65 190.35 T
1.91 (Support for locating local variables will incur the same costs as for serial garbage collection) 63.65 169.35 P
([Mann93a].) 63.65 155.35 T
63.65 128.95 531.65 141.95 C
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 136.95 171.65 136.95 2 L
0.25 H
2 Z
0 X
0 0 0 1 0 0 0 K
N
-8.35 24.95 603.65 816.95 C
2 9 Q
0 X
0 0 0 1 0 0 0 K
0.24 (1.  Note that in the important case of a conservative garbage collector it is not necessary for the garbage collector to make use of) 63.65 122.95 P
(the map of live variables. In this case, there will be null de\336nitions of the tokens which are de\336ned to build the chain of maps.) 63.65 112.95 T
FMENDPAGE
%%EndPage: "13" 18
%%Page: "14" 19
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(14) 63.65 84.9 T
63.65 780.95 531.65 780.95 2 L
0 Z
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
3 15 Q
(6.) 63.65 734.95 T
(Conclusions) 90.65 734.95 T
2 12 Q
0.3 0.02 (It should be possible to implement a threads library for Dylan by using a mixture of architecture) 63.65 715.95 B
0.3 0.18 (specif) 63.65 701.95 B
0.3 0.18 (ic token def) 92.7 701.95 B
0.3 0.18 (initions and an architecture specif) 151.4 701.95 B
0.3 0.18 (ic run time system. Core TDF provides no) 320.05 701.95 B
0.13 (direct support for architecture neutrality \321 but this is a conscious decision for the design of TDF) 63.65 687.95 P
(since there is no common model of parallel computation.) 63.65 673.95 T
0.3 0.1 (The thread models described in the Preliminary Parallelism Extensions document [Edwards93]) 63.65 652.95 B
0.3 0.02 (are well suited for implementing threads in Dylan. However there are some language features of) 63.65 638.95 B
(Dylan which are not covered by this model.) 63.65 624.95 T
0.3 0.02 (There is a requirement for multi-thread support for the exception handling mechanism described) 63.65 603.95 B
-0.07 (in Proposed Extensions to TDF for Ada and Lisp [Currie93], as well as a requirement for a mech-) 63.65 589.95 P
(anism to de\336ne a thread-local variable to support the dynamic features of Dylan.) 63.65 575.95 T
0.19 (Implementation of garbage collection for a multi-threaded language is a complex problem \321 but) 63.65 554.95 P
0.3 0.02 (existing industry-standard techniques can be used with TDF) 63.65 540.95 B
0.3 0.02 (. Since compiler support for garbage) 354.19 540.95 B
0.3 0.17 (collection is limited to the three areas of read barriers, write barriers and root detection, these) 63.65 526.95 B
0.3 0.18 (areas may be implemented in the most appropriate manner for a given algorithm by using the) 63.65 512.95 B
(combination of TDF token de\336nitions and a run time system.) 63.65 498.95 T
0.3 0.03 (The introduction of multiple threads into a TDF implementation of Dylan is not expected to add) 63.65 477.95 B
0.3 0.12 (any extra inef) 63.65 463.95 B
0.3 0.12 (f) 131.7 463.95 B
0.3 0.12 (iciency problems, other than those inevitably encountered when implementing a) 135.16 463.95 B
(language that uses a parallel garbage collection system.) 63.65 449.95 T
3 15 Q
(7.) 63.65 410.95 T
(References and Bibliography) 90.65 410.95 T
2 10 Q
([AMR92]) 63.65 393.29 T
0.25 0.13 (Abdullahi, S.E., Miranda, E.E., Ringwood, G.A., \322Distributed Garbage Collection\323, 1992 Interna-) 124.85 393.29 B
(tional W) 124.85 381.29 T
(orkshop on Memory Management, St. Malo, France, September 1992, SpringerV) 158.77 381.29 T
(erlag.) 482.62 381.29 T
([Appel89]) 63.65 363.29 T
0.25 0.05 (Appel, A.W) 124.85 363.29 B
0.25 0.05 (., "Runtime T) 173.27 363.29 B
0.25 0.05 (ags Aren't Necessary", Journal of Lisp and Symbolic Computation, V) 228.34 363.29 B
0.25 0.05 (ol. 2,) 510.87 363.29 B
(1989.) 124.85 351.29 T
([AEL88]) 63.65 333.29 T
0.25 0.11 (Appel, A.W) 124.85 333.29 B
0.25 0.11 (., Ellis, J.R., Li, K., \322Realtime Concurrent Collection on Stock Microprocessors\323, Pro-) 173.86 333.29 B
0.25 0 (ceedings of SIGPLAN \32488 Conference on Programming Language Design and Implementation, June) 124.85 321.29 B
(1988, ACM.) 124.85 309.29 T
([AL91]) 63.65 291.29 T
0.25 0.14 (Appel, A.W) 124.85 291.29 B
0.25 0.14 (., Li, K., \322V) 174.18 291.29 B
0.25 0.14 (irtual Memory Primitives for User Programs\323, Proceedings of SIGARCH/) 223.91 291.29 B
-0.01 (SIGOPS/SIGPLAN Conference on Architectural Support for Programming Languages and Operating) 124.85 279.29 P
(Systems, April 1991, ACM.) 124.85 267.29 T
([Apple92]) 63.65 249.29 T
(Apple Computer) 124.85 249.29 T
(, \322Dylan; An object oriented dynamic language\323, April 1992.) 191.39 249.29 T
([BM93]) 63.65 231.29 T
0.25 0.08 (Balou, A.T) 124.85 231.29 B
0.25 0.08 (., Miranda, E.E., \322The Design of SPIRIT Multiprocessor Smalltalk\323, Queen Mary W) 169.88 231.29 B
0.25 0.08 (est-) 517.05 231.29 B
(\336eld College, Department of Computer Science tech. report #627, March 1993.) 124.85 219.29 T
([BW88]) 63.65 201.29 T
0.13 (Boehm, H-J., W) 124.85 201.29 P
0.13 (eiser) 189.58 201.29 P
0.13 (, M., \322Garbage Collection in an Uncooperative Environment\323, Software Practice) 208.06 201.29 P
(and Experience, vol. 18, #9, September 1988.) 124.85 189.29 T
([BDS91]) 63.65 171.29 T
0.03 (Boehm, H-J., Demers, A.J., Shenker) 124.85 171.29 P
0.03 (, S., \322Mostly Parallel Garbage Collection\323, Proceedings of SIGP-) 270.36 171.29 P
(LAN \32491 Conference on Programming Language Design and Implementation, June 1991, ACM) 124.85 159.29 T
([Currie93]) 63.65 141.29 T
0.17 (Currie, I., \322Proposed Extensions to TDF for Ada and Lisp\323, GLUE Deliverable 4.1.1, DRA Malvern,) 124.85 141.29 P
(September 1993) 124.85 129.29 T
FMENDPAGE
%%EndPage: "14" 19
%%Page: "15" 20
595.3 841.9 0 FMBEGINPAGE
[0 0 0 1 0 0 0]
[ 0 1 1 0 1 0 0]
[ 1 0 1 0 0 1 0]
[ 1 1 0 0 0 0 1]
[ 1 0 0 0 0 1 1]
[ 0 1 0 0 1 0 1]
[ 0 0 1 0 1 1 0]
 7 FrameSetSepColors
FrameNoSep
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
0 0 0 1 0 0 0 K
63.65 780.95 531.65 780.95 2 L
0.5 H
0 Z
0 X
0 0 0 1 0 0 0 K
N
3 8 Q
(ESPRIT Project 6062 OMI/GLUE - D5.7.1) 63.65 766.62 T
63.65 96.95 531.65 96.95 2 L
2 Z
N
3 10 Q
(15) 520.53 84.9 T
3 8 Q
(Requirements speci\336cation for parallel extensions to TDF to) 297.65 766.62 T
(support Dylan - including run-time support.) 297.65 756.62 T
2 10 Q
([Detlefs91]) 63.65 738.29 T
0.03 (Detlefs, D., \322Concurrent Garbage Collection for C++\323, in) 124.85 738.29 P
1 F
0.03 (T) 358.01 738.29 P
0.03 (opics in Advanced Language Implementa-) 362.65 738.29 P
(tion) 124.85 726.29 T
2 F
(, Lee, P) 140.41 726.29 T
(. ed, 1991, MIT Press.) 169.85 726.29 T
([DeT) 63.65 708.29 T
(reville90]) 84.4 708.29 T
-0.04 (DeT) 124.85 708.29 P
-0.04 (reville, J., \322Experience with Garbage Collection for Modula-2+ in the T) 142.27 708.29 P
-0.04 (opaz Environment\323, DEC) 428.69 708.29 P
(SRC Research Report #63, 1990.) 124.85 696.29 T
([DB76]) 63.65 678.29 T
0.25 0.07 (Deutsch, L.P) 124.85 678.29 B
0.25 0.07 (., Bobrow) 176.71 678.29 B
0.25 0.07 (, D., \322An Ef) 216.62 678.29 B
0.25 0.07 (f) 266.3 678.29 B
0.25 0.07 (icient Incremental, Automatic Garbage Collector\323, Communica-) 269.15 678.29 B
(tions of the ACM, vol. 19, #7, July 1976.) 124.85 666.29 T
([DLMSS78]) 63.65 648.29 T
0.11 (Dijkstra, E.W) 124.85 648.29 P
0.11 (., Lamport, L., Martin, A.J., Scholten, C.S., Stef) 179.31 648.29 P
0.11 (fens, E.F) 372.12 648.29 P
0.11 (.M., "On-the-Fly Garbage Col-) 407.26 648.29 P
(lection: An Exercise in Cooperation", Communications of the ACM, vol. 21 #1) 124.85 636.29 T
(1, November 1978.) 441.88 636.29 T
([Edwards93]) 63.65 618.29 T
0.19 (Edwards, P) 124.85 618.29 P
0.19 (., \322Preliminary Parallelism Extensions\323, GLUE Deliverable 5.1.1, DRA Malvern, October) 169.47 618.29 P
(1993) 124.85 606.29 T
([FMY91]) 63.65 588.29 T
-0.16 (Furusou, S., Matsuoka, S., Y) 124.85 588.29 P
-0.16 (onezawa, A., \322Parallel Conservative Garbage Collection with Fast Object) 238.79 588.29 P
0.25 0.17 (Allocation\323, OOPSLA \32491 Conference on Object-Oriented Systems, Languages and Applications) 124.85 576.29 B
(workshop on Garbage Collection,) 124.85 564.29 T
6 F
(anon. ftp cs.utexas.edu /pub/garbage/GC91.) 262.33 564.29 T
2 F
([HMS92]) 63.65 546.29 T
0.14 (Hosking, A.L., Moss, J.E.B., Stefanovi\253c, D., \322A Comparative Performance Evaluation of W) 124.85 546.29 P
0.14 (rite Bar-) 497.9 546.29 P
0.25 0.07 (rier Implementations", Proceedings of OOPSLA \32492 Conference on Object-Oriented Systems, Lan-) 124.85 534.29 B
(guages and Applications, SIGPLAN Notices vol. 27 #10, ACM, October 1992.) 124.85 522.29 T
([KMY93]) 63.65 504.29 T
-0.08 (Kamada, T) 124.85 504.29 P
-0.08 (., Matsuoka, S., Y) 168.46 504.29 P
-0.08 (onezawa, A., \322Ef) 239.45 504.29 P
-0.08 (\336cient Parallel Global Garbage Collection on Massively) 307.69 504.29 P
-0.09 (parallel Computers\323, OOPSLA \32493 Conference on Object-Oriented Systems, Languages and Applica-) 124.85 492.29 P
0.25 0.3 (tions workshop on Garbage Collection,) 124.85 480.29 B
6 F
0.6 0.3 (anon. ftp cs.utexas.edu /pub/garbage/) 296.99 480.29 B
(GC93.) 124.85 468.29 T
2 F
([KHM89]) 63.65 450.29 T
0.25 0.04 (Kranz, D.A., Halstead, R.H., Mohr) 124.85 450.29 B
0.25 0.04 (, E., \322Mul-T) 266.69 450.29 B
0.25 0.04 (: A High-Performance Parallel Lisp\323, Proceedings of) 316.32 450.29 B
-0.14 (SIGPLAN \32489 Conference on Programming Language Design and Implementation, June 1989, ACM.) 124.85 438.29 P
([Mann93]) 63.65 420.29 T
(Mann, T) 124.85 420.29 T
(., \322TDF Support required by Lisp\323, GLUE Deliverable 4.2.1, Harlequin Ltd., 1993.) 158.55 420.29 T
([Mann93a]) 63.65 402.29 T
0.25 0.15 (Mann, T) 124.85 402.29 B
0.25 0.15 (., \322Initial evaluation of TDF Support for Garbage Collection\323, GLUE Deliverable 4.2.2a,) 159.88 402.29 B
(Harlequin Ltd., 1993.) 124.85 390.29 T
([NO93]) 63.65 372.29 T
0.25 0.03 (Nettles, S., O\325T) 124.85 372.29 B
0.25 0.03 (oole, J., \322Real-T) 188.1 372.29 B
0.25 0.03 (ime Replication Garbage Collection\323, Proceedings of SIGPLAN \32493) 254.49 372.29 B
(Conference on Programming Language Design and Implementation, June 1993, ACM.) 124.85 360.29 T
([ON93]) 63.65 342.29 T
0.25 0.05 (O\325T) 124.85 342.29 B
0.25 0.05 (oole, J., Nettles, S., \322Concurrent Replicating Garbage Collection\323, OOPSLA \32493 Conference on) 140.94 342.29 B
0.25 0.17 (Object-Oriented Systems, Languages and Applications workshop on Garbage Collection,) 124.85 330.29 B
6 F
0.6 0.17 (anon.) 500.97 330.29 B
(ftp cs.utexas.edu /pub/garbage/GC93.) 124.85 318.29 T
2 F
([PU88]) 63.65 300.29 T
0.25 0.05 (Pallas, J., Ungar) 124.85 300.29 B
0.25 0.05 (, D., \322Multiprocessor Smalltalk: A Case Study of a Multiprocessor) 191.11 300.29 B
0.25 0.05 (-Based program-) 463.23 300.29 B
0.25 0.13 (ming Environment\323, Proceedings of SIGPLAN 88 Conference on Programming Language Design) 124.85 288.29 B
(and Implementation, June 1988, ACM.) 124.85 276.29 T
([Rovner85]) 63.65 258.29 T
0.25 0.25 (Rovner) 124.85 258.29 B
0.25 0.25 (, P) 155.41 258.29 B
0.25 0.25 (., \322On Adding Garbage Collection and Runtime T) 165.87 258.29 B
0.25 0.25 (ypes to a Strongly-T) 378.3 258.29 B
0.25 0.25 (yped, Statically) 465.37 258.29 B
(Checked, Concurrent Language\323, tech. report CSL-84-7, Xerox P) 124.85 246.29 T
(ARC, June 1985.) 386.37 246.29 T
([SS91]) 63.65 228.29 T
0.25 0.07 (Sharma, R., Sof) 124.85 228.29 B
0.25 0.07 (fa, M.L., \322Parallel Generational Garbage Collection\323, Proceedings of OOPSLA \32491) 189.88 228.29 B
0.25 0.15 (Conference on Object-Oriented Systems, Languages and Applications, SIGPLAN Notices vol. 26) 124.85 216.29 B
(#1) 124.85 204.29 T
(1, ACM, November 1991, ACM.) 134.48 204.29 T
([Steenkiste91]) 63.65 186.29 T
0.25 0.07 (Steenkiste, P) 124.85 186.29 B
0.25 0.07 (., \322The Implementation of T) 176.57 186.29 B
0.25 0.07 (ags and Run-T) 291.53 186.29 B
0.25 0.07 (ime T) 351.48 186.29 B
0.25 0.07 (ype Checking\323, in) 374.99 186.29 B
1 F
0.25 0.07 (T) 451.99 186.29 B
0.25 0.07 (opics in Advanced) 456.7 186.29 B
(Language Implementation) 124.85 174.29 T
2 F
(, Lee, P) 230.12 174.29 T
(. Ed, MIT Press, 1991.) 259.56 174.29 T
([TDF92]) 63.65 156.29 T
(Foster) 124.85 156.29 T
(, M., Currie, I., \322TDF Speci\336cation\323, DRA Malvern, September 1992.) 149.45 156.29 T
([W) 63.65 138.29 T
(ilson92]) 76.02 138.29 T
-0.07 (W) 124.85 138.29 P
-0.07 (ilson, P) 133.89 138.29 P
-0.07 (., \322Uniprocessor Garbage Collection T) 162.72 138.29 P
-0.07 (echniques\323, 1992 International W) 316.16 138.29 P
-0.07 (orkshop on Memory) 450.12 138.29 P
(Management, St. Malo, France, SpringerV) 124.85 126.29 T
(erlag, September 1992.) 294.27 126.29 T
FMENDPAGE
%%EndPage: "15" 20
%%Trailer
%%BoundingBox: 0 0 595.3 841.9
%%PageOrder: Ascend
%%Pages: 20
%%DocumentFonts: Times-Bold
%%+ Times-Italic
%%+ Times-Roman
%%+ Helvetica-Bold
%%+ Helvetica
%%+ Courier-Bold
%%+ Courier
%%EOF

{\rtf1\ansi \deff7\deflang1033{\fonttbl{\f1\froman\fcharset2\fprq2 Symbol;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f49\fswiss\fcharset0\fprq2 Tahoma;}}{\colortbl;\red0\green0\blue0;
\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;
\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar \f7\fs20 \snext0 Normal;}{\s1\qr\keepn\widctlpar \b\shad\f5\fs32\lang2057 \sbasedon0\snext0 heading 1;}{
\s2\li-900\ri-720\keepn\widctlpar \b\f7\fs20\lang2057 \sbasedon0\snext0 heading 2;}{\*\cs10 \additive Default Paragraph Font;}{\s15\widctlpar \cbpat9 \f49\fs20 \sbasedon0\snext15 Document Map;}{\s16\widctlpar\tqc\tx4320\tqr\tx8640 \f7\fs20 
\sbasedon0\snext16 footer;}{\*\cs17 \additive\sbasedon10 page number;}{\s18\widctlpar\tqc\tx4320\tqr\tx8640 \f7\fs20 \sbasedon0\snext18 header;}{\s19\li720\widctlpar \f5\fs32\lang2057 \sbasedon0\snext19 Body Text 2;}{\s20\li-810\widctlpar 
\b\f7\fs20\lang2057 \sbasedon0\snext20 Body Text Indent 2;}{\*\cs21 \additive\b\f5\fs40\ulnone\lang2057\nosupersub \sbasedon10 Slide Title;}{\s22\widctlpar \f5\fs36\lang2057 \sbasedon0\snext22 Slide Body;}{\s23\li90\widctlpar \b\f7\fs20\lang2057 
\sbasedon0\snext23 Body Text Indent 3;}{\s24\widctlpar \b\f7\fs20\lang2057 \sbasedon0\snext24 Body Text;}}{\info{\title C Types in Dylan}{\author Keith Playford}{\operator Hugh George Greene}{\creatim\yr1998\mo10\dy15\hr12\min1}
{\revtim\yr1998\mo10\dy16\hr12\min7}{\version2}{\edmins0}{\nofpages1}{\nofwords686}{\nofchars3912}{\*\company  }{\vern57431}}\margl547\margr806\margt446\margb547 \widowctrl\ftnbj\aendnotes\aftnstart0\hyphhotz0\aftnnar\hyphcaps0 \fet0\sectd 
\psz1\linex0\headery709\footery709\cols2\colsx709\linebetcol\endnhere {\footer \pard\plain \s16\qc\ri360\widctlpar\tqc\tx4320\tqr\tx8640 \f7\fs20 {\cs17\i\shad 
\par }{\i\lang2057 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s20\widctlpar \b\f7\fs20\lang2057 {\f5 An Introduction to the Dylan C FFI
\par 
\par Practical 1: The FFI Playground}{\b0\f5 
\par 
\par The purpose of this practical is just to get familiar with manipulating C data in Dylan by experimenting in an interactor.
\par 
\par Use the environment to generate a development mode GUI application called }{\f5 ffi-playground}{\b0\f5  that uses both the c-ffi and win32 libraries. 
\par 
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}}\pard \s20\fi-360\li360\widctlpar\tx360{\*\pn \pnlvlblt\pnf1\pnstart1\pnindent360\pnhang{\pntxtb \'a8}}{\b0\f5 Don\rquote t ask the wizard to include template code.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Use the wizard\rquote s \ldblquote Typical\rdblquote  libraries selector.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}We want standard IO support and the win32 API only; no OLE, no DUIM, no database support.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Once generated, ensure that the project is set to interactive development mode.
\par }\pard \s20\widctlpar {\b0\f5 
\par Open an interactor on the project. You will be prompted to build it. Once the interactor opens, you are in a position to experiment with allocating and manipulating C objects.
\par 
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}}\pard \s20\fi-360\li360\widctlpar\tx360{\*\pn \pnlvlblt\pnf1\pnstart1\pnindent360\pnhang{\pntxtb \'a8}}{\b0\f5 Experiment with the introspective operations }{\f5 size-of}{\b0\f5  and }{\f5 alignment-of}{\b0\f5 
 by calling them on some of the designator classes exported from }{\f5 c-ffi}{\b0\f5  and the win32 libraries: e.g }{\f5 <C-int>}{\b0\f5 , }{\f5 <C-double>}{\b0\f5 , }{\f5 <C-char*>}{\b0\f5 ,  and also the structs }{\f5 <EVENTMSG>}{\b0\f5  and }{\f5 
<POINT>}{\b0\f5  from win32.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Heap allocate an array of C }{\f5 int}{\b0\f5 s 100 elements long (i.e. }{\f5 make}{\b0\f5  an instance of }{\f5 <C-int*>}{\b0\f5  with }{\f5 element-count:}{\b0\f5 
 100) and experiment with getting and setting elements (e.g. initialize its elements to the numbers 0 to 99).
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Make a new pointer into the middle of the }{\f5 int}{\b0\f5  array using }{\f5 pointer-value-address}{\b0\f5 . Set a common element via one pointer and verify that it has changed via the other.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Cast the original }{\f5 int}{\b0\f5  array to an array of }{\f5 char}{\b0\f5 s using }{\f5 c-type-cast}{\b0\f5 
 and compare overlapping elements. Again, change an element through one pointer and observe the change through the other.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Heap allocate an array of 10 }{\f5 <POINT>}{\b0\f5  structs. Use }{\f5 pointer-value-address}{\b0\f5  to get a pointer to the 5}{\b0\f5\super th}{\b0\f5  struct. Note that calling }{\f5 element}{\b0\f5 
 on the array will fail here because the FFI doesn\rquote t allow immediate structs to be manipulated directly.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Heap allocate a single instance of a win32 point struct: by calling }{\f5 make}{\b0\f5  on its pointer type with no other arguments. Try reading and writing its slots using the accessors }{\f5 x-value}{\b0\f5 , }{\f5 
x-value-setter}{\b0\f5 , }{\f5 y-value}{\b0\f5 , and  }{\f5 y-value-setter}{\b0\f5 .}{\b0 
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}}{\b0\f5 Call }{\f5 format-out}{\b0\f5  to see the point\rquote s default print representation. A }{\f5 \\n}{\b0\f5  at the end of the format string will force the output to be displayed immediately.}{\b0 
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}}{\b0\f5 Write a new method on }{\f5 print-object}{\b0\f5  for instances of }{\f5 <LPPOINT>}{\b0\f5  that displays the struct\rquote s x and y values. You can find out the signature of }{\f5 print-object}{\b0\f5 
 by entering its name into the interactor, right-clicking on the generic function returned, and taking \ldblquote Browse\rdblquote . Use }{\f5 format}{\b0\f5  in the body of your method to print the new representation.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}Now call }{\f5 format-out}{\b0\f5  again to see the result. Different methods like this can be written for any pointer type you import because each imported type has its own class.
\par }\pard \s20\widctlpar {\b0\f5 
\par Also in the interactor, you can try calling directly a C function that has already been imported by the win32 interface libraries. }{\f5 MessageBox}{\b0\f5  takes the handle
 of its owning window or NULL,  a nul-terminated message string, a nul-terminated title string, and a flag word.
\par 
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}}\pard \s20\fi-360\li360\widctlpar\tx360{\*\pn \pnlvlblt\pnf1\pnstart1\pnindent360\pnhang{\pntxtb \'a8}}{\b0\f5 There\rquote s no owning window to hand, so just pass NULL as the first argument. That argument\rquote 
s type is }{\f5 HWND}{\b0\f5  in C, and the corresponding Dylan class is, following the win32 import naming convention, }{\f5 <HWND>}{\b0\f5 . Use }{\f5 null-pointer}{\b0\f5  to get a NULL pointer to pass in.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}To get the two C strings, use the FFI utility class }{\f5 <C-string>}{\b0\f5  which is both a pointer designator class and a conforming subclass of Dylan\rquote s }{\f5 <string>}{\b0\f5 
 collection class. As such, you can use }{\f5 as}{\b0\f5  to convert literal Dylan strings to }{\f5 <C-string>}{\b0\f5  to get the message text and title arguments.
\par {\pntext\pard\plain\f1\fs20 \'a8\tab}The last argument is a flag word. Experiment with combinations of these imported constants: at most one of }{\f5 $MB-OK}{\b0\f5 , }{\f5 $MB-OKCANCEL}{\b0\f5 , }{\f5 $MB-YESNO}{\b0\f5 
 to choose the button arrangement; at most one of }{\f5 $MB-ICONHAND}{\b0\f5 , }{\f5 $MB-ICONQUESTION}{\b0\f5 , }{\f5 $MB-ICONEXCLAMANTION}{\b0\f5  to choose the icon shown. Flags should be combined with }{\f5 logior}{\b0\f5 : e.g. }{\f5 
logior($MB-OK, $MB-ICONHAND)}{\b0\f5 
\par }\pard \s20\widctlpar {\b0\f5 
\par A complete call might look like this:
\par }{\f5 
\par }{\b0\f5   }{\f5 MessageBox
\par     (null-pointer(<HWND>),
\par      as(<C-string>, \ldblquote Yo Dylan!\rdblquote ),
\par      as(<C-string>, \ldblquote Dylan Message\rdblquote ),
\par      logior($MB-OK, 
\par                 $MB-ICONEXCLAMATION));}{\b0\f5 
\par 
\par This is OK for an experiment, but note that the memory allocated for the C strings here will never be deallocated because no handle on the pointers remains in order to }{\f5 destroy}{\b0\f5 
 them after the call. Just as in C, careful use of stack allocation or reuse of heap allocated buffers is required when dealing with C interfaces from Dylan.
\par 
\par If there\rquote s time left, just try stuff out in the interactor and see what happens.
\par 
\par Something else to try is to type }{\f5 <C-value>}{\b0\f5  into the object text field of a browser in the environment and expand its subclasses. }{\f5 <C-value>}{\b0\f5 
 is the superclass of all the Dylan classes that designate C types, including all the types imported from win32.
\par }}
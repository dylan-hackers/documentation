<?xml version='1.0'?>
<!DOCTYPE book PUBLIC
 "UNREGISTERED::Gwydion Dylan Maintainers//DTD DylanDoc V4.2//EN"
 "dylandoc.dtd"
 [
 <!ENTITY % entities SYSTEM "./dylandoc.ent">
 %entities;
 ]
>

<book id="tutorial">
  <bookinfo>
    <title>Getting Started with &dylan;</title>
    <titleabbrev>&dylan; Tutorial</titleabbrev>
    <authorgroup>
      <author>&contact.emk;</author>
    </authorgroup>

    <othercredit role='converter'>
      &person.fulgham;
      <contrib>
	Conversion from DocBook 3.1 (SGML) to DocBook 4.2 (XML).
      </contrib>
    </othercredit>

    <copyright>
      <year>1995</year>
      <year>1996</year>
      <year>1998</year>
      <year>1999</year>
      <holder>&person.emk;</holder>
    </copyright>
    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <holder>The Gwydion Maintainers</holder>
    </copyright>

    <abstract>
      <para>
	<citetitle>Getting Started with &dylan;</citetitle> introduces
	<ulink url="http://www.apple.com/">Apple Computer</ulink>'s &dylan;
	programming language. &dylan; is a object-oriented dynamic language
	designed for efficient compilation. It uses an algebraic infix syntax
	similar to Pascal or C, but supports an object model not unlike the
	Common Lisp Object System (<acronym>CLOS</acronym>).
      </para>

      <para>
	This tutorial is written primarily for those with solid
	programming experience in &cpp; or another object-oriented static
	language. It provides a gentler introduction to &dylan; than does the
	&drm;, although it refers to the latter book frequently.
      </para>
    </abstract>
  </bookinfo>


  <!-- ==================== Chapter 1 ==================== -->
  <chapter id="why-dylan">
    <title>Why &dylan;?</title>

    <para>
      What earthly reason could there be for learning yet <emphasis>
      another</emphasis> computer language?  And why should that language be
      &dylan;?
    </para>

    <para>
      &dylan; has an interesting combination of features. It is a dynamic
      language, but is designed to perform nearly as well as a static language.
      It is a <link linkend="functional">functional</link> language&mdash;like
      Scheme or TCL&mdash;but uses an algebraic infix syntax similar to C's.
      &dylan; is object-oriented from the ground up, supports multiple 
      inheritence and exceptions, implements <link linkend="multiple-dispatch">
      multiple dispatch</link>, and <link linkend="gc">collects garbage</link>.
    </para>
    
    <sect1 id="dynamic-vs-static">
      <title>Dynamic vs. Static Languages</title>

      <para>
	<glossterm>Static</glossterm> languages need to know the type
	of every variable at compile time. Examples of static languages include
	C, Pascal, and Eiffel. Code written in static languages typically
	compiles efficiently, and strong type-checking at compile-time reduces
	the risk of errors.
      </para>

      <para>
	<glossterm>Dynamic</glossterm> languages allow the programmer to
	create variables without explicitly specifying the type of information
	they contain. This simplifies prototyping and cleans up certain kinds
	of object oriented code. Typical dynamic languages include LISP, Perl,
	and SmallTalk.
      </para>

      <para>
	&dylan; provides a good balance between the advantages of static
	and dynamic languages. The programmer may choose to specify or omit
	type declarations as desired. Code using explicit variable types can
	be compiled very efficiently, and type mismatch errors can be caught
	at compile time. Code omitting those type declarations gains the
	flexibility of a dynamic language.
      </para>
    </sect1>

    <sect1 id="functional">
      <title>Functional Languages</title>

      <para>
	<glossterm>Functional</glossterm> languages, such as LISP,
	Scheme and to a large extent TCL, view an entire program as one large
	function to be evaluated. Expressions, statements and even control
	structures all return values, which may in turn be used as arguments
	elsewhere.
      </para>

      <para>
	&dylan; is a functional language, permitting programmers to write
	functions like the following:
      </para>

      <programlisting>
define method shoe-size(person :: &lt;string&gt;)
  if (person = "Larry")
    14;
  else
    11;
  end if;
end method;
      </programlisting>
      
      <para>
	The function <function>shoe-size</function> has one argument,
	a string, and an untyped return value. (If this function didn't link
	against external code, the compiler could easily infer the return
	type.)  If <literal>person</literal> equals <literal>"Larry"</literal>,
	then the <literal>if</literal> statement evaluates to 14, otherwise
	it returns 11. Since no other statements follow the <literal>if
	</literal>, its return value is used as the return value of the entire
	function.
      </para>

      <para>
	The same function could also have been written as follows, in a
	more <glossterm>imperative</glossterm> idiom:
      </para>

      <programlisting>
define method shoe-size(person :: &lt;string&gt;)
  let the-size = 11;
  if (person = "Joe")
    the-size := 14;
  end if;
  the-size;
end method;
      </programlisting>

    </sect1>

    <sect1 id="algebraic">
      <title>Algebraic Infix Syntax</title>
	
      <para>
	Languages based on LISP typically use a notation called
	<glossterm>fully-parethesized prefix syntax</glossterm>. This consists
	of innumerable nested paretheses, as seen in the following Scheme
	version of the <function>shoe-size</function> function:
      </para>

      <programlisting>
(define (shoe-size person)
  (if (equal? person "Joe")
    14
    11))
      </programlisting>

      <para>
	This has a certain elegance, but takes some time to learn to
	read. Dylan, as shown in <link linkend="functional">the previous
	section</link>, uses a syntax similar to those of C and Pascal.
      </para>
    </sect1>

    <sect1 id="object-oriented">
      <title>Object Orientation</title>
	
      <para>
	Unlike many other object-oriented languages, Dylan uses objects
	for every data value. Integers and strings are objects, as are
	functions and classes themselves.
      </para>

      <para>
	Dylan's design makes this reasonably efficient. Compile-time
	analysis and explicit <link linkend="type-declarations">type
	declarations</link> allow the compiler to optimize away most of the
	overhead. Other language features permit the programmer to mark
	certain classes as <glossterm>sealed</glossterm>, that is, inelligible
	for further subclassing.
      </para>

      <para>
	Dylan's object model, detailed in the following sections of this
	tutorial, differs from that of &cpp; in several important respects.
	Multiple inheritance may be used freely, without concern for
	<glossterm>object slicing</glossterm>, erroneous down-casting or a
	whole host of other gotchas familiar to &cpp; programmers. Methods are
	separate from class declarations, allowing a programmer to write new
	polymorphic functions without editing the relevant base class.  Methods
	may also dispatch ploymorphically on more than one parameter, a
	powerful technique known as <glossterm>multiple dispatch</glossterm>.
	All of these features will be explained in greater detail later on.
      </para>
    </sect1>

    <sect1 id="gc">
      <title>Garbage Collection</title>

      <para>
	Languages with <glossterm>garbage collection</glossterm> have no
	need of a <function>free</function> or <function>delete</function>
	operator, because unused heap memory gets reclaimed automatically by
	the language runtime. This reduces the complexity of source code,
	eliminates the need of keeping reference counts for shared objects,
	and prevents most memory allocation bugs and all memory leaks.
      </para>

      <para>
	Over the years, garbage collection has gained a reputation for
	inefficiency. A large, object-oriented LISP program performed
	terribly compared to hand coded, micro-optimized assembly, and a good
	portion of the blame was placed on garbage collection.
      </para>

      <para>
	Times have changed, however. Garbage collection technology has
	improved. Processors speed has increased enormously. Most importantly,
	however, the standard practice of the industry has changed, and large
	commerical software is now built in &cpp;.
      </para>

      <para>
	No good benchmarks exist for the relative performance of large
	&cpp; systems (greater than 15 thousand lines of code or so), and
	similar systems <emphasis>designed from the ground up</emphasis> to use
	garbage collection. The benchmarks which do exist typically test the
	performance of relatively small pieces of code&mdash;small enough
	that one programmer can optimize the overall usage of memory&mdash;or
	have compared a good system without garbage collection to a direct
	reimplementation of that system using a garbage collector. Overall,
	no one seems to know just how fast GC is, relative to a typical large
	&cpp; program. It <emphasis>is</emphasis> known, however, that good
	GC code uses different designs than non-GC code, and often spends less
	time needlessly copying data.
      </para>
    </sect1>

    <sect1 id="why-not">
      <title>Why Not Dylan?</title>
	
      <para>
	Dylan's greatest weakness is the lack of commercial-quality
	compilers, especially on the Macintosh. Apple has refused to comment
	on the future of their technology release, and <ulink
	url="http://www.functionalobjects.com/">functional Objects</ulink> is
	targeting the Windows and Linux markets with their compiler. The
	&gwydprj;'s Dylan implementation will support multiple UNIXs, Windows,
	and Macintosh when complete.
      </para>

      <para>
	Even when good Dylan environments become available, experience
	suggests that Dylan applications will use more RAM than programs
	written in traditional languages.
      </para>
    </sect1>
  </chapter>


  <!-- ==================== chapter 2 ==================== -->

  <chapter id="expressions-variables">
    <title>Expressions &amp; Variables</title>

    <para>
      Dylan identifiers may contain a greater variety of characters
      than those of C or Pascal. Specifically, variable names may contain all
      alphanumeric characters, plus the symbols <literal>! &amp; * &lt; = &gt;
      | ^ $ % @ _ - + ~ ? /</literal>. Identifiers may not begin with the
      symbols <literal>- + ~ ? /</literal>, although identifiers may begin
      with numbers, provided they contain at least two alphabetic characters
      in a row. As in Pascal, variable names are not case sensitive.
      <remark>Need &drm; footnote here.</remark>
    </para>

    <para>
      This means that <literal>(a - b)</literal> subtracts one variable
      from another, whereas <literal>(a-b)</literal> simply returns the value
      of the hyphenated variable named <literal>a-b</literal>. Because of this,
      infix operators, such as addition, subtraction and equality, must be
      surrounded by whitespace.
    </para>

    <para>
      As in &cpp;, Dylan infix operators may also be refered to as
      functions. In &cpp;, <literal>(a + b)</literal> could also be written
      as <literal>operator+(a, b)</literal>. In Dylan, the same expression
      could be written <literal>\+(a, b)</literal>. In both languages,
      programmers can use this flexibility to define operators for custom
      numeric classes.
    </para>

    <sect1 id="naming-conventions">
      <title>Naming Conventions</title>

      <para>
	Dylan uses the extra characters permitted in variable names to
	support a number of standard naming conventions, as shown in
	<xref linkend="table.naming-conventions"/>.
      </para>

      <table id="table.naming-conventions">
        <title>Naming Conventions</title>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><literal>&lt;string&gt;</literal></entry>
	      <entry>a class</entry>
            </row>
            <row>
              <entry><literal>insert!</literal></entry>
              <entry>mutative function (modifies arguments destructively)
              </entry>
            </row>
            <row>
              <entry><literal>empty?</literal></entry>
              <entry>predicate function (tests one or more arguments and
              returns either true or false)</entry>
            </row>
            <row>
              <entry><literal>write-line</literal></entry>
              <entry>a two word name</entry>
            </row>
            <row>
              <entry><literal>$name</literal></entry>
              <entry>constant</entry>
            </row>
            <row>
              <entry><literal>*name*</literal></entry>
              <entry>module-level variable</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect1>

    <sect1 id="true-and-false">
      <title>True and False</title>

      <para>
	Dylan represents true as <literal>#t</literal> and false as
	<literal>#f</literal>. When evaluated in a Boolean context, all values
	other than <literal>#f</literal> return true. Thus, the number zero
	&mdash;and other common <quote>false</quote> values&mdash;evaluate as
	true in Dylan.
      </para>
    </sect1>

    <sect1 id="nature-of-variables">
      <title>The Nature of Variables</title>

      <para>
	Dylan variables differ from those found in C and Pascal. Instead
	of <emphasis>holding</emphasis> their values, Dylan variables
	<emphasis>refer</emphasis> to them. Conceptually, they resemble a
	cross between pointers and &cpp; references. Like references, Dylan
	variables may be evaluated without any indirection. Like pointers,
	they may be set to point to new objects whenever the programmer
	desires.
      </para>

      <para>
	Furthermore, there's only one of any given numeric value in a
	Dylan program, at least from the programmer's point of view. All
	variables which refer to the integer 2&mdash;or, in Dylan-speak, are
	<glossterm>bound</glossterm> to the integer 2&mdash;point to the
	exact same thing.
      </para>

      <programlisting>
let x = 2; // creates x and binds it to 2
x := 3;    // rebinds x to the value 3
let y = x; // creates y, and binds it to
           // whatever x is bound to
      </programlisting>

      <para>
	If two variables are bound to one object with internal
	structure, the results may suprise C and Pascal programmers.
      </para>

      <programlisting>
let car1 = make(&lt;car&gt;); // bind car1 to a
                              // new car object
car1.odometer := 10000;       // set odometer
let car2 = car1;              // bind new name
car2.odometer := 0;           // reset odometer
car1.odometer;                // evaluates to 0!
      </programlisting>

      <para>
	As long as one or more variables refer to an object, it
	continues to exist. However, as soon as the last reference either
	goes out of scope or gets rebound, the object becomes <glossterm>
	garbage</glossterm>. Since there's no way that the program could ever
	refer to the object again, the <glossterm>garbage collector
	</glossterm> feels free to reuse the memory which once held it.
      </para>

      <para>
	Note that Dylan variables <emphasis>must</emphasis> be bound to a
	particular value when they are declared. In the name of type safety
	and implementation efficiency, every variable must refer to some
	well-defined object.
      </para>
    </sect1>

    <sect1 id="equals">
      <title>Assignment, Equality and Identity</title>
	
      <para>
	Dylan uses all three of the <quote>equals</quote> operators
	found in C and Pascal, albeit in a different fashion. The Pascal
	assignment operator, <literal>:=</literal>, rebinds Dylan variable
	names to new values. The Pascal equality operator, <literal>=
	</literal>, tests for equality in Dylan and also appears in some
	language constructs such as <literal>let</literal>. (Two Dylan objects
	are equal, generally, if they belong to the same class and have equal
	substructure.)
      </para>

      <para>
	The C equality operator, <literal>==</literal>, acts as the
	<glossterm>identity</glossterm> operator in Dylan. Two variables are
	<glossterm>identical</glossterm> if and only if they are bound to the
	exact same object. For example, the following three expressions mean
	roughly the same thing:
      </para>

      <programlisting>
(a == b)   // in Dylan
(&amp;a == &amp;b) // in C or C++
(@a = @b) // in Pascal
      </programlisting>

      <para>
	The following piece of source code demonstrates all three
	operators in actual use.
      </para>

      <programlisting>
let car1 = make(&lt;car&gt;);
let car2 = make(&lt;car&gt;);
let car3 = car2;

car2 = car3;	// #t
car1 = car2;	// ??? (see below)
car2 == car3;	// #t
car1 == car2;	// #f

car2 := car1;	// rebind
car1 == car2;	// #t

let x = 2;
let y = 2;

x = y;			// #t
x == y;			// #t (only one 2!)
      </programlisting>

      <para>
	Two of the examples merit further explanation. First, we don't
	know whether <literal>car1 = car2</literal>, because we don't know if
	make creates each car with the same serial number, driver and other
	information as previous cars. If and only if none of those values
	differ, then <literal>car1</literal> equals <literal>car2</literal>.
	Second, <literal>x == y</literal> because every variable bound to a
	given number refers to the exact same instance of that number, at least
	from the programmer's perspective. (The compiler will normally do
	something more useful and efficient when generating the actual machine
	code.)  Strings behave in a fashion different from numbers&mdash;
	instances of strings are stored separately, and two equal strings are
	not necessarily the same string.
      </para>
    </sect1>

    <sect1 id="parallel-values">
      <title>parallel Values</title>

      <para>
	It's possible to bind more than one variable at a time in Dylan.
	For example, a single <literal>let</literal> statement could bind
	<literal>x</literal> to 2, <literal>y</literal> to 3 and <literal>z
	</literal> to 4.
      </para>

      <programlisting>
let (x, y, z) = values (2, 3, 4);
      </programlisting>

      <para>
	In Perl, the equivalent statement would assign a vector of
	values to a vector of variables. In Dylan, no actual vectors or lists
	are used. All three values are assigned directly, using some
	implementation-dependant mechanism.
      </para>
    </sect1>

    <sect1 id="type-declarations">
      <title>Type Declarations</title>

      <para>
	Dylan variables may have explicit types. This allows the
	compiler to generate better code and to catch type-mismatch errors at
	compile time. To take advantage of this feature, use the <literal>::
	</literal> operator:
      </para>

      <programlisting>
let x :: &lt;integer&gt; = 2;
let vehicle :: &lt;vehicle&gt; = make(&lt;car&gt;);
let y :: &lt;number&gt; = 3; // any numeric class
let z :: &lt;integer&gt; = vehicle; // error!
      </programlisting>

      <para>
	As seen in the example, a variable may be bound to values of its
	declared type or to values of subclasses of its declared type. Type
	mismatch errors should be caught at compile time. In general, the
	compiler may infer the types of variables at when generating machine
	code. If a local variable never gets rebound to anything other than an
	integer, for example, the compiler can rely on this fact to optimize
	the resulting code.
      </para>
    </sect1>

    <sect1 id="module-variables">
      <title>Module Variables and Constants</title>

      <para>
	Dylan supports <glossterm>module-level</glossterm> variables,
	which serve roughly the same purpose as C's global variables. Although
	the <literal>let</literal> function may only be used within <glossterm>
	methods</glossterm> (Dylan-speak for regular functions), the forms
	<literal>define variable</literal> and <literal>define constant
	</literal> may be used at the top level.
      </para>

      <programlisting>
define variable *x* :: &lt;integer&gt; = 3;
define variable *y* = 4;
define constant $hi = "Hi!";
      </programlisting>

      <para>
	Note that there's not much point in declaring types for
	constants. Any remotely decent compiler will be able to figure that
	information out on its own.
      </para>
    </sect1>
  </chapter>


  <!-- ==================== chapter 3 ==================== -->

  <chapter id="methods-generic-functions">
    <title>Methods &amp; Generic functions</title>

    <para>
      Dylan <glossterm>methods</glossterm> correspond roughly to the
      functions found in C and Pascal. They take zero or more named parameters,
      but also return zero or more named return values. A minimal Dylan method
      might look like the following:
    </para>

<programlisting>
define method hello-world()
  puts("Hello, world!");
end;
</programlisting>

    <para>
      This method has no parameters and an unspecified return value. It
      could return any number of values of any type. In order to make the
      above code more clear, the function could be rewritten as follows:
    </para>

    <programlisting>
define method hello-world() =&gt; ();
  puts("Hello, world!");
end method;
    </programlisting>

    <para>
      There have been two changes. The function now officially returns
      no value whatsoever. Also note that <literal>end</literal> has been
      replaced by <literal>end method</literal> which could in turn be
      rewritten as <literal>end method hello-world</literal>. In general,
      Dylan permits all the obvious combinations of keywords and labels to
      follow an end statement.
    </para>

    <sect1 id="parameters">
      <title>parameters &amp; parameter Lists</title>

      <para>
	Dylan methods declare parameters in fashion similar to that of
	conventional languages, except for the fact that parameters may
	optionally be untyped. Both of the following methods are legal:
      </para>

      <programlisting>
define method foo(x :: &lt;integer&gt;, y) end;
define method bar(m, s :: &lt;string&gt;) end;
      </programlisting>

      <para>
	Both <function>foo</function> and <function>bar</function> have
	one typed and one untyped parameter, but neither has a well-defined
	return value (or actually does anything). As in C, each typed parameter
	must have its own type declaration; there's no syntax for saying
	<quote>the last three parameters were all integers</quote>.
      </para>

      <para>
	Functions with variable numbers of parameters include the
	<literal>#rest</literal> keyword at the end of their parameter lists.
	Thus, the declaration for C's <function>printf</function> function
	would appear something like the following in Dylan:
      </para>

      <programlisting>
define method printf(format-string :: &lt;string&gt;, #rest arguments) =&gt; ();
  // Print the format string, extracting
  // one at a time from &quot;arguments&quot;. Note
  // that Dylan actually allows us to
  // verify the types of variables,
  // preventing those nasty printf errors,
  // such as using %d instead of %ld.
  // ...
end method printf;
      </programlisting>

      <para>
	For an actual implementation of a lightweight <function>printf
	</function>function, see Appendix A.
	<!-- <link linkend="printf-code"/Appendix      A/. -->
      </para>

      <para>
	Note that Dylan makes no provision for passing variables by
	reference in the Pascal sense, or for passing pointers to variables.
	parameter names are simply bound to whatever values are passed, and may
	be rebound like regular variables. This means that there's no way to
	write a <function>swap</function> function in Dylan (except by using
	macros). However, the following function works just fine, because it
	modifies the <glossterm>internal state</glossterm> of another
	object:
      </para>

      <programlisting>
define method sell(car :: &lt;car&gt;, new-owner :: &lt;string&gt;) =&gt; ();
  if (credit-check(new-owner))
    car.owner = new-owner;
  else
    error(&quot;Bad credit!&quot;);
  end;
end;
      </programlisting>

      <para>
	If this sounds unclear, reread the chapter on <link
	linkend="expressions-variables">variables and expressions</link>.
      </para>
    </sect1>

    <sect1 id="return-values">
      <title>Return Values</title>
      
      <para>
	Because Dylan methods can't have normal <quote>output</quote>
	parameters in their parameter lists, they're allowed considerably
	more flexibility when it comes to return values. Methods may return
	more than one value. As with parameters, these values may be typed or
	untyped. Interestingly enough, all return values <emphasis>must
	</emphasis> be named.
      </para>

      <para>
	A Dylan method&mdash;or any other control construct&mdash;returns
	the value of the last expression in its body.
      </para>

      <programlisting>
define method foo() =&gt; sample :: &lt;string&gt;;
  &quot;Sample string.&quot;;		// return string
end;

define method bar() =&gt; my-untyped-value;
  if (weekend-day?(today()))
    &quot;Let's party!&quot;;	// return string
  else
    make(&lt;excuse&gt;);	// return object
  end if;
end method;

define method moby( )
  =&gt;	sample :: &lt;string&gt;, my-untyped-value;
  values( foo(), bar() ); // return both!
end;

define method baz( ) =&gt; ( );
  let (x,y) = moby( );		// assign both
end;
      </programlisting>

    </sect1>

    <sect1 id="bare-methods">
      <title>Bare Methods</title>

      <para>
	Nameless methods may be declared inline. Such <glossterm>bare
	methods</glossterm> are typically used as parameters to other methods.
	For example, the following code fragment squares each element of a list
	using the built in <function>map</function> function and a bare
	method:
      </para>

      <programlisting>
define method square-list(in :: &lt;list&gt;)
  =&gt; out :: &lt;list&gt;
  map(method(x) x * x end, in);
end;
      </programlisting>

      <para>
	The <function>map</function> function takes each element of
	the list <literal>in</literal> and applies the anonymous method. It
	then builds a new list using the resulting values and returns it.
	The method <function>square-list</function> might be invoked as
	follows:<remark>Must distinguish return values from code.
	</remark>
      </para>

      <programlisting>
square-list( #(1,2,3,4) );
=&gt; #(1,4,9,16)
      </programlisting>

    </sect1>


    <sect1 id="local-methods">
      <title>Local Methods</title>

      <para>
	Local methods resemble bare methods but have names. They are
	declared within other methods, often as private utility routines. Local
	methods are typically used in a fashion similar to Pascal's local
	functions.
      </para>

      <programlisting>
define method sum-squares(in :: &lt;list&gt;) =&gt; sum-of-element-squares :: &lt;integer&gt;;
  local method square( x )
          x * x;
        end,
        method sum(list :: &lt;list&gt;)
          reduce1(\+, list);
        end;
  sum(map(square, in));
end;
      </programlisting>

      <para>
	Local methods can actually outlive the invocation of the
	function which created them. parameters of the parent function remain
	bound in a local method, allowing some interesting techniques:
      </para>

      <programlisting>
define method build-put(string :: &lt;string&gt;) =&gt; &lt;function&gt;;
  local method string-putter()
          puts(string);
        end;
  string-putter; // return local method
end;

define method print-hello() =&gt; ();
  let f = build-put(&quot;Hello!&quot;);
  f();				// print &quot;Hello1&quot;
end;
      </programlisting>

      <para>
	Local functions which contain bound variables in the above
	fashion are known as <glossterm>closures</glossterm>.
      </para>
    </sect1>


    <sect1 id="generic-functions">
      <title>Generic functions</title>

      <para>
	A <glossterm>generic function</glossterm> represents zero or more
	similar methods. Every method created by means of <literal>define
	method </literal> is automatically <glossterm>contained</glossterm>
	within the generic function of the same name. For example, a 
	programmer could define three methods named <function>display
	</function>, each of which acted on a different data type:
      </para>

      <programlisting>
define method display(i :: &lt;integer&gt;)
  do-display-integer(i);
end;

define method display(s :: &lt;string&gt;)
  do-display-string(s);
end;

define method display(f :: &lt;float&gt;)
  do-display-float(f);
end;
      </programlisting>

      <para>
	When a program calls <function>display</function>, Dylan examines
	all three methods. Depending on the number and type of arguments to
	<function>display</function>, Dylan invokes one of the above methods.
	If no methods match the actual parameters, an error occurs.
      </para>

      <para>
	In &cpp;, this process occurs only at compile time. (It's called
	operator overloading.) In Dylan, calls to <function>display</function>
	may be resolved either at compile time or while the program is actually
	executing. This makes it possible to define methods like:
      </para>

      <programlisting>
define method display(c :: &lt;collection&gt;)
  for (item in c)
    display(item); // runtime dispatch
  end;
end;
      </programlisting>

      <para>
	This method extracts objects of unknown type from a collection,
	and attempts to invoke the generic function <function>display
	</function> on each of them. Since there's no way for the compiler
	to know what type of objects the collection actually contains, it
	must generate code to identify and invoke the proper method at
	runtime. If no applicable method can be found, the Dylan runtime
	environment throws an exception.
      </para>

      <para>
	Generic functions may also be declared explicity, allowing the
	programmer to exercise control over what sort of methods get added.
	For example, the following declaration limits all <function>display
	</function> methods to single parameter and no return value:
      </para>

      <programlisting>
define generic display(thing :: &object;) =&gt; ()
      </programlisting>

      <para>
	Generic functions are explained in greater detail in the chapter on
	<link linkend="multiple-dispatch">multiple dispatch</link>.
      </para>
    </sect1>

    <sect1 id="keyword-arguments">
      <title>Keyword Arguments</title>
	
      <para>
	Functions may accept <glossterm>keyword arguments</glossterm>,
	extra parameters which are identified by a label rather than by their
	postion in the argument list. Keyword arguments are often used in a
	fashion similar to <glossterm>default parameter values</glossterm>
	in &cpp;. For example, the following hypothetical method might print
	records to an output device:
      </para>

      <programlisting>
define method print-records(records :: &lt;collection&gt;,
  #key init-codes = &quot;&quot;, lines-per-page = 66) =&gt; ();

  send-init-codes(init-codes);
  // ...print the records
end method;
      </programlisting>

      <para>
	This method could be invoked in one of several ways. The first
	specifies no keyword arguments, and the latter two specify some
	combination of them. Note that order of keyword arguments doesn't
	matter.
      </para>

      <programlisting>
print-records(recs);
print-records(recs, lines-per-page: 65);
print-records(recs, lines-per-page: 120, init-codes: &quot;***42\n&quot;);
      </programlisting>

      <para>
	Programmers have quite a bit of flexibility in specifying
	keyword arguments. They may optionally omit the default value for a
	keyword (in which case <literal>#f</literal> is used). Default value
	specifiers may actually be function calls themselves, and may rely on
	regular parameters already being in scope. Variable names may be
	different from keyword names, a handy tool for preventing name
	conflicts.
      </para>

      <para>
	For more information on keyword arguments, especially their use
	with <link linkend="generic-functions">generic functions</link>,
	see the &drm;.
      </para>
    </sect1>
  </chapter>


  <!-- ==================== chapter 4 ==================== -->

  <chapter id="objects">
    <title>Objects</title>

    <para>
      The features of Dylan's object system don't map directly onto the
      features found in &cpp;. Dylan handles access control using <glossterm>
      modules</glossterm>, not <literal>private</literal> declarations within
      individual objects. Standard Dylan has no destructors, but instead relies
      upon the garbage collector to recover memory and on exception handling
      blocks to recover other resources. Dylan objects don't even have real
      member functions.
    </para>

    <para>
      Despite these oddities, Dylan's object system is at least as
      powerful as that of &cpp;. Multiple inheritance works smoothly,
      constructors are rarely needed and there's no such thing as object
      slicing. Alternate constructs replace the missing &cpp; features. Quick
      and dirty classes can be turned into clean classes with little editing
      of existing code.
    </para>

    <para>
      Before starting, temporarily set aside any low-level expertise in
      &cpp; or Object Pascal. Dylan differs enough that such knowledge can
      actually interfere with the initial learning process.
    </para>

    <sect1 id="built-in-classes">
      <title>Built-In Classes</title>
      
      <para>
	Dylan has a large variety of built-in classes. Several of these
	represent primitive data types, such as <literal>&lt;integer&gt;
	</literal> and <literal>&lt;character&gt;</literal>. A few represent
	actual language-level entities, such as <literal>&lt;class&gt;
	</literal> and <literal>&lt;function&gt;</literal>. Most of the others
	implement collection classes, similar to those found in &cpp;'s
	Standard Template Library. A few of the most important classes are
	shown in <xref linkend="figure.class-tree"/>.
      </para>

      <figure id="figure.class-tree">
	<title>Several Standard Dylan Classes</title>
	<graphic fileref="class-tree.pic" format="PIC"></graphic>
      </figure>

      <para>
	The built-in collection classes include a number of common data
	structures. Arrays, tables, vectors, ranges and deques should be
	provided by all Dylan implementations. The language specification
	also standardizes strings and byte-strings, certainly a welcome
	convenience.
      </para>

      <para>
	Not all the built-in classes may be subclassed. This allows the
	compiler to heavily optimize code dealing with basic numeric types
	and certain common collections. The programmer may also mark classes
	as <glossterm>sealed</glossterm>, restricting how and where they may be
      subclassed. See <xref linkend="modules-libraries"/> for details.
      </para>
    </sect1>

    <sect1 id="slots">
      <title>Slots</title>

      <para>
	Objects have <glossterm>slots</glossterm>, which resemble the data
	members found in most other object-oriented languages. Like
	variables, slots are bound to values; they don't actually contain
	their data. A simple Dylan class shows how slots are declared:
      </para>

      <programlisting>
define class &lt;vehicle&gt; (&object;)
  slot serial-number;
  slot owner;
end;
      </programlisting>

      <para>
	The above code would quick and convenient to write while building
	a prototype, but it could be improved. The slots have no types, and
	worse, they have no initial values. (That's no easy achievement in
	Dylan, to create an uninitialized variable!) The following snippet
	fixes both problems:
      </para>

      <programlisting>
define class &lt;vehicle&gt; (&object;)
  slot serial-number :: &lt;integer&gt;,
    required-init-keyword: sn:;
  slot owner :: &lt;string&gt;,
    init-keyword: owner:, // optional
    init-value: &quot;Northern Motors&quot;;
end class &lt;vehicle&gt;;
      </programlisting>

      <para>
	The type declarations work just like type declarations anywhere
	else in Dylan; they limit a binding to objects of a given class or of
	one of its subclasses, and they let the compiler optimize. The new
	keywords describe how the slots get their initial values. (The keyword
	<literal>init-function</literal> may also be used; it must be followed
	by a function with no arguments and the appropriate return type.)
      </para>

      <para>
	To create a vehicle object using the new class declaration, a
	programmer could write one of the following:
      </para>

      <programlisting>
make(&lt;vehicle&gt;, sn: 1000000)
make(&lt;vehicle&gt;, sn: 2000000, owner: &quot;Sal&quot;)
      </programlisting>

      <para>
	In the first example, <function>make</function> returns a vehicle
	with the specified serial number and the default owner. In the second
	example, <function>make</function> sets both slots using the keyword
	arguments.
      </para>

      <para>
	Only one of <literal>required-init-keyword</literal>, <literal>
	init-value</literal> and <literal>init-function</literal> may be
	specified. However, <literal>init-keyword</literal> may be paired with
	either of the latter two if desired. More than one slot may be
	initialized by a given keyword.
      </para>

      <para>
	Dylan also provides for the equivalent of &cpp; <literal>static
	</literal> members, plus several other useful allocation schemes. See
	the &drm; for the full specifications.
      </para>
    </sect1>

    <sect1 id="getters-setters">
      <title>Getters and Setters</title>

      <para>
	An object's slots are accessed using to functions: a getter and
	a setter. By default, the getter function has the same name as the
	slot, and the setter function appends <quote><literal>-setter
	</literal></quote>. These functions may be invoked as follows:
      </para>

      <programlisting>
owner(sample-vehicle);	// returns owner
owner-setter(sample-vehicle, &quot;Faisal&quot;);
      </programlisting>

      <para>
	Dylan also provides some convenient <quote>syntactic sugar</quote>
	for these two functions. They may also be written as:
      </para>

      <programlisting>
sample-vehicle.owner;		// returns owner
sample-vehicle.owner := &quot;Faisal&quot;;
      </programlisting>

    </sect1>

    <sect1 id="generic-functions-objects">
      <title>Generic functions and Objects</title>

      <para>
	Generic functions, introduced in <link linkend=
	"methods-generic-functions">Methods and Generic functions
	</link>, provide the equivalent of &cpp; and Object Pascal member
	functions. In the simplest case, just declare a generic function
	which dispatches on the first parameter.
      </para>

      <programlisting>
define generic tax(v :: &lt;vehicle&gt;)
  =&gt; tax-in-dollars :: &lt;float&gt;;

define method tax(v :: &lt;vehicle&gt;)
  =&gt; tax-in-dollars :: &lt;float&gt;;
  100.00;
end;

//=== Two new subclasses of vehicle

define class &lt;car&gt; (&lt;vehicle&gt;)
end;

define class &lt;truck&gt; (&lt;vehicle&gt;)
  slot capacity,
    required-init-keyword: tons:;
end;

//=== Two new &quot;tax&quot; methods

define method tax( c :: &lt;car&gt; )
  =&gt; tax-in-dollars :: &lt;float&gt;;
  50.00;
end method;

define method tax( t :: &lt;truck&gt; )
  =&gt; tax-in-dollars :: &lt;float&gt;;
  // standard vehicle tax plus $10/ton
  next-method( ) + t.capacity * 10.00;
end method;
      </programlisting>

      <para>
	The function <function>tax</function> could be invoked as
	<literal>tax(v)</literal> or <literal>v.tax</literal>, because it
	only has one argument. Generic functions with two or more arguments
	must be invoked in the usual Dylan fashion; no syntactic sugar exists
	to make them look like &cpp; member functions.
      </para>

      <para>
	The version of tax for <literal>&lt;truck&gt;</literal> objects
	calls a special function named <function>next-method</function>. This
	function invokes the next most specific method of a generic function;
	in this case, the method for <literal>&lt;vehicle&gt;</literal>
	objects.  Parameters to the current method get passed along
	automatically.
      </para>

      <para>
	Technically, <function>next-method</function> is a special
	parameter to a method, and may be passed explicitly using <literal>
	#next</literal>. &mindy;, a popular but incomplete bytecode compiler
	written as part of the &gwydprj;, currently requires the use of
	<literal>#next</literal>.
      </para>

      <programlisting>
define method tax(t :: &lt;truck&gt;, #next next-method)
  =&gt; tax-in-dollars :: &lt;float&gt;;
  // standard vehicle tax plus $10/ton
  next-method() + t.capacity * 10.00;
end method;
      </programlisting>

      <para>
	Dylan's separation of classes and generic functions provides some
	interesting design ideas. Classes no longer need to <quote>contain
	</quote> their member functions; it's possible to write a new generic
	function without touching the class definition. For example, a module
	handling traffic simulations and one handling municipal taxes could
	each have many generic functions involving vehicles, but both could
	use the same vehicle class.
      </para>

      <para>
	Slots in Dylan may also be replaced by programmer-defined accessor
	functions, all without modifying existing clients of the class. The
	&drm; describes numerous ways to accomplish the change; several should
	be apparent from the preceding discussion. This flexibility frees
	programmers from creating functions like <literal>GetOwnerName
	</literal> and <literal>SetOwnerName</literal>, not to mention the
	corresponding private member variables and constructor code.
      </para>

      <para>
	For even more creative uses of generic functions and the Dylan
	object model, see the chapter on <link linkend="multiple-dispatch">
	Multiple Dispatch</link>.
      </para>
    </sect1>


    <sect1 id="initializers">
      <title>Initializers</title>

      <para>
	The <function>make</function> function handles much of the
	drudgery of object construction. It processes keywords and initializes
	slots. Programmers may, however, customize this process by adding
	methods to the generic function <function>initialize</function>. For
	example, if vehicle serial numbers must be at least seven digits:
      </para>

      <programlisting>
define method initialize(v :: &lt;vehicle&gt;, #all-keys) // accepts all keywords
  next-method( );
  if (v.serial-number &lt; 1000000)
    error(&quot;Bad serial number!&quot;);
  end if;
end method;
      </programlisting>

      <para>
	<function>Initialize</function> methods get called after regular
	slot initialization. They typically perform error checking or calculate
	values for unusual slots. Initialize methods must accept all keywords
	using <literal>#all-keys</literal>.
      </para>

      <para>
	It's possible to access the values of slot keywords from
	<function>initialize</function> methods, and even to specify additional
	keywords in the class declaration. See the &drm; for further details.
      </para>
    </sect1>

    <sect1 id="abstract-classes">
      <title>Abstract Classes and Overriding Make</title>

      <para>
	Abstract classes define the interface, not the implementation,
	of an object. There are no direct instances of an abstract class.
	Concrete classes actually implement their interfaces. Every abstract
	class will typically have one or more concrete subclasses. For example,
	if plain vanilla vehicles shouldn't exist, <literal>&lt;vehicle&gt;
	</literal> could be defined as follows:
      </para>

      <programlisting>
define abstract class &lt;vehicle&gt; (&object;)
  // ...as before
end;
      </programlisting>

      <para>
	The above modification prevents the creation of direct instances
	of <literal>&lt;vehicle&gt;</literal>. At the moment, calling
	<function>make</function> on this class would result in an error.
	However, a programmer could add a method to make which allowed the
	intelligent creation of vehicles based on some criteria, thus making
	<literal>&lt;vehicle&gt;</literal> an <glossterm>instantiable abstract
	class</glossterm>:
      </para>

      <programlisting>
define method make(class == &lt;vehicle&gt;,
  #rest keys, #key big? (#f), #all-keys)
  =&gt; &lt;vehicle&gt;;

  if ( big? )
    make( &lt;truck&gt;, keys, tons: 2 );
  else
    make( &lt;car&gt;, keys );
  end;
end;
      </programlisting>

      <para>
	A number of new features appear in the parameter list. The
	expression <quote><literal>class == &lt;vehicle&gt;</literal></quote>
	specifies a <glossterm>singleton</glossterm>, one particular object
	of a class which gets treated as a special case. Singletons are
	discussed in the chapter on <link linkend="multiple-dispatch">
	Multiple Dispatch</link>. The use of <literal>#rest</literal>,
	<literal>#key</literal> and <literal>#all-keys</literal> in the same
	parameter list accepts any and all keywords, binds one of them to
	<literal>big?</literal> and places all of them into the variable
	<literal>keys</literal>. The new make method could be invoked in
	any of the following fashions:
      </para>

      <programlisting>
let x = 1000000;
make(&lt;vehicle&gt;, sn: x, big?: #f); =&gt;car
make(&lt;vehicle&gt;, sn: x, big?: #t); =&gt;truck
make(&lt;vehicle&gt;, sn: x);           =&gt;car
      </programlisting>

      <para>
	Methods added to <function>make</function> don't actually need
	to create new objects. Dylan officially allows them to return existing
	objects. This can be used to manage lightweight shared objects, such
	as the <quote>flyweights</quote> described by Gamma, et al., in
	<ulink url="http://st-www.cs.uiuc.edu/users/patterns/DPBook/DPBook.html">
	  <citetitle>Design Patterns</citetitle>
	</ulink>.
      </para>
    </sect1>
  </chapter>


  <!-- ==================== chapter 5 ==================== -->

  <chapter id="multiple-dispatch">
    <title>Multiple Dispatch</title>

    <para>
      <glossterm>Multiple dispatch</glossterm> is one of the most powerful
      and elegant features of Dylan. As explained in the section on <link
      linkend="generic-functions-objects">generic functions and objects</link>,
      Dylan methods are declared separately from the classes upon which they
      act.  <glossterm>Polymorphism</glossterm>, the specialization of methods
      for use with particular classes, can be implemented by declaring several
      methods with different parameters and attaching them to one generic
      function:
    </para>

    <programlisting>
define generic inspect-vehicle(v :: &lt;vehicle&gt;, i :: &lt;inspector&gt;) =&gt; ();

define method inspect-vehicle(v :: &lt;vehicle&gt;, i :: &lt;inspector&gt;) =&gt; ();
  look-for-rust(v);
end;

define method inspect-vehicle(car :: &lt;car&gt;, i :: &lt;inspector&gt;) =&gt; ();
  next-method(); // perform vehicle inspection
  check-seat-belts(car);
end;

define method inspect-vehicle(truck :: &lt;truck&gt;, i :: &lt;inspector&gt;) =&gt; ();
  next-method(); // perform vehicle inspection
  check-cargo-attachments(truck);
end;
    </programlisting>

    <para>
      However, different types of vehicle inspectors may have different
      policies. A state inspector, in addition to the usual procedures, will
      also typically check a car's insurance policy. To implement this, add
      another method to the generic function <function>inspect&mdash;vehicle
      </function>:
    </para>

    <programlisting>
define method inspect-vehicle(car :: &lt;car&gt;, i :: &lt;state-inspector&gt;) =&gt; ();
  next-method(); // perform car inspection
  check-insurance(car);
end;

let inspector = make(&lt;state-inspector&gt;);
let car = make(&lt;car&gt;);
inspect-vehicle(car, inspector);
    </programlisting>

    <para>
      Calling the generic function <function>inspect-vehicle</function>
      with these arguments performs three separate tasks:  <function>
      look-for-rust</function>, <function>check-seat-belts </function> and
      <function>check-insurance</function>. The most specific method on
      <function>inspect-vehicle</function>&mdash;the one for the classes
      <literal>&lt;car&gt;</literal> and <literal>&lt;state-inspector&gt;
      </literal>&mdash;is invoked first and calls <function>next-method
      </function> to invoke the less-specific methods in turn.
    </para>

    <para>
      For an exact definition of <quote>specific</quote>, see the &drm;.
    </para>


    <sect1 id="singleton-dispatch">
      <title>Dispatching on Specific Objects</title>

      <para>
	Dylan also allows functions to dispatch on specific objects. For
	example, state inspectors might pass the governor's car without
	actually looking at it. Dylan expresses this situation using
	<glossterm>singletons</glossterm>, objects which are treated as
	though they were in a class of their own. For example:
      </para>

      <programlisting>
define constant $governors-car = make(&lt;car&gt;);

define method inspect-vehicle(car == $governors-car,
  i :: &lt;state-inspector&gt;) =&gt; ();
  wave-through(car);
end;
      </programlisting>

      <para>
	(In this example, none of the usual inspection methods will be
	invoked since the above code neglects to call <function>next-method
	</function>.)
      </para>
    </sect1>
  </chapter>


  <!-- ==================== chapter 6 ==================== -->

  <chapter id="modules-libraries">
    <title>Modules &amp; Libraries</title>

    <para>
      Modules and libraries provide the structure of a Dylan program. Modules
      represent namespaces and control access to objects and functions.
      Libraries contain modules, and act as units of compilation in a
      finished Dylan program.
    </para>

    <sect1 id="simple-modules">
      <title>Simple Modules</title>

      <para>
	Modules import the symbols of other modules and export their
	own. The dependencies between modules must form a directed, acyclic
	graph. Two modules may not use each other, and no circular
	dependencies may exist.
      </para>

      <para>
	Modules only export variables. Since the names of classes and
	generic functions are actually stored in variables, this represents
	no hardship. A sample module containing the vehicle classes from
	earlier chapters might resemble:
      </para>

      <programlisting>
define module Vehicles
  use Dylan;
  export
    &lt;vehicle&gt;,
      serial-number,
      owner, owner-setter,
      tax,
    &lt;car&gt;,
    &lt;truck&gt;,
      capacity;
end module;
      </programlisting>

      <para>
	Like all normal modules, this one uses the <literal>Dylan
	</literal> module, which contains all of the standard built-in
	functions and classes. In turn, the <literal>Vehicles</literal>
	module exports all three of the vehicle classes, the generic function
	<literal>tax</literal>, several getter functions and a single
	setter function.
      </para>

      <para>
	To control access to a slot, export some combination of its
	getter and setter functions. To make a slot public, export both. To
	make it read-only, export just the getter function. To make it
	private, export neither. In the above example, the slot
	<literal>serial-number</literal> is read-only, while the slot
	<literal>owner</literal> is public.
      </para>

      <para>
	Note that when some module adds a method to a generic function,
	the change affects all modules using that function. The new method
	actually gets added <emphasis>into</emphasis> the variable representing
	the generic function. Since the variable has been previously exported,
	all clients can access the new value.
      </para>
    </sect1>

    <sect1 id="import-options">
      <title>Import Options</title>

      <para>
	Dylan allows very precise control over how symbols are imported
	from other modules. For example, individual symbols may be imported
	by name. They may be renamed, either one at a time, or by adding a
	prefix to all a module's symbols at once. Some or all of them may be
	re-exported immediately. See the &drm; for specific examples.
      </para>

      <para>
	Dylan's import system has a number of advantages. Name conflicts
	occur rarely. Programmers don't need to define or maintain function
	prototypes. There's no explicit need for header files. Modules may
	also provide different interfaces to the same objects&mdash;one module
	exports a complete interface, which another module imports, redefines
	and re-exports.
      </para>
    </sect1>

    <sect1 id="libraries">
      <title>Libraries</title>

      <para>
	Libraries contain modules. For example, the <literal>Dylan
	</literal> library contains the <literal>Dylan</literal> module
	described earlier, the <literal>Extensions</literal> module, and
	possibly several other implementation-dependent modules. Note that
	a library and a module may share a given name. Modules with the
	same name may also appear in more than one library.
      </para>

      <para>
	By default, a Dylan environment provides a library called
	<literal>Dylan-User</literal> for the convenience of the programmer.
	This is typically used for short, single library programs which
	depend only on modules found in the Dylan library.
      </para>

      <para>
	Additionally, every library contains an implicit module, also
	known as <literal>Dylan-User</literal>, which imports all of the
	modules found in the <literal>Dylan</literal> library. This may be
	used for single module programs. Many Dylan environments, however,
	use it to bootstrap new library definitions. The vehicle library,
	for example, might be defined as follows in a <literal>Dylan-User
	</literal> module:
      </para>

      <programlisting>
define library Vehicles
  use Dylan;            // This is the library!
  export                // These are modules.
    Vehicles,           // (Defined above.)
    Traffic-Simulation,
    Crash-Testing,
    Inspection;         // (Hypothetical.)
end library Vehicles;
      </programlisting>

      <para>
	This library could in turn be imported by another library:
      </para>

      <programlisting>
define library Vehicle-Application
  use Dylan;
  use My-GUI-Classes;
  use Vehicles;
end;
      </programlisting>

      <para>
	Libraries import other libraries and export modules, whereas
	modules import other modules and export variables. In general, a
	module may import any module found in its own library or exported
	from a library imported by its own library. The following module, for
	example, could belong to the <literal>Vehicle-Application</literal>
	library.
      </para>

      <programlisting>
define module Sample-Module
  // module name         source library
  use Dylan;          // Dylan
  use Extensions;     // Dylan
  use Menus;          // My-GUI-Classes
  use Vehicles;       // Vehicles
  use Inspection;     // Vehicles
end module;
      </programlisting>

    </sect1>


    <sect1 id="sample-libraries">
      <title>A Sample Set of Libraries</title>

      <para>
	<xref linkend="figure.mindy-libraries"/> and <xref linkend=
	"table.mindy-libraries-modules"/> show the libraries included
	with &mindy;, a bytecode compiler produced as part of the
	&gwydprj;. Also shown are the dependencies between the libraries and
	the major modules contained within each. For more information on
	these libraries and their use, see the &mindy; documentation and
	source code.
      </para>

      <figure id="figure.mindy-libraries">
        <title>Dependencies Among the Standard Mindy Libraries</title>
	<graphic fileref="mindy-libraries.pic" format="PIC"></graphic>
      </figure>

      <table id="table.mindy-libraries-modules">
        <title>Standard Mindy Libraries and Modules</title>
        <tgroup cols="3">
	  <thead>
	    <row role="label">
	      <entry>Library</entry>
	      <entry>Module</entry>
	      <entry>Purpose</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><literal>Dylan</literal></entry>
	      <entry><literal>Dylan</literal></entry>
	      <entry>standard Dylan</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Extensions</literal></entry>
	      <entry>Mindy extensions</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>System</literal></entry>
	      <entry>general functions</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>File-Descriptors</literal></entry>
	      <entry>UNIX-style file support</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Threads</literal></entry>
	      <entry>threads and semaphores</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Hash-Tables</literal></entry>
	      <entry>additional table support</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Introspection</literal></entry>
	      <entry>program examination</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Cheap-IO</literal></entry>
	      <entry>basic, unformatted I/O</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Extern</literal></entry>
	      <entry>support for linking to C</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Transcendental</literal></entry>
	      <entry>trig and other math</entry>
	    </row>

	    <row>
	      <entry><literal>Collection-Extensions</literal></entry>
	      <entry><literal>Heap</literal></entry>
	      <entry>standard heaps</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Self-Organizing-List</literal></entry>
	      <entry><quote>poor man's hash table</quote></entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Vector-Search</literal></entry>
	      <entry>search, replace support</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Subseq</literal></entry>
	      <entry>slices of sequences</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Sequence-Diff</literal></entry>
	      <entry><quote>diff</quote> for sequences</entry>
	    </row>

	    <row>
	      <entry><literal>String-Extensions</literal></entry>
	      <entry><literal>String-Conversions</literal></entry>
	      <entry>strings to/from integers</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Character-Type</literal></entry>
	      <entry>similar to C's <quote><literal>ctype.h</literal>
		    </quote></entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>String-Hacking</literal></entry>
	      <entry>useful string functions</entry>
	    </row>
	    <row>
	      <entry></entry>
          <entry><literal>Substring-Search</literal></entry>
	      <entry>similar to Perl</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Regular-Expressions</literal></entry>
	      <entry>similar to Perl</entry>
	    </row>

	    <row>
	      <entry><literal>Streams</literal></entry>
	      <entry><literal>Streams</literal></entry>
	      <entry>UNIX stream I/O</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Standard-IO</literal></entry>
	      <entry>the 3 standard streams</entry>
	    </row>

	    <row>
	      <entry><literal>Print</literal></entry>
	      <entry><literal>PPrint</literal></entry>
	      <entry>Pretty-printing</entry>
	    </row>
	    <row>
	      <entry></entry>
	      <entry><literal>Print</literal></entry>
	      <entry>General object output</entry>
	    </row>

	    <row>
	      <entry><literal>Format</literal></entry>
	      <entry><literal>Format</literal></entry>
	      <entry>Formatted output</entry>
	    </row>

	    <row>
	      <entry><literal>Random</literal></entry>
	      <entry><literal>Random</literal></entry>
	      <entry>Random distributions</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <para>
	The <literal>String-Extensions</literal> library, in particlar,
	contains a number of useful functions. It provides many of Perl's
	popular text-manipulation features.
      </para>
    </sect1>

    <sect1 id="sealing">
      <title>Sealing</title>

      <para>
	Classes and generic functions may be <glossterm>sealed</glossterm>
	using a number of Dylan forms. This prevents code in other libraries
	from subclassing objects or adding methods to generic functions, and
	lets the compiler optimize more effectively. Both classes and generic
	functions are sealed by default.
      </para>

      <para>
	To allow code in other libraries to subclass a given class,
	declare it as <literal>open</literal>:
      </para>

      <programlisting>
define open class &lt;sample&gt; (&object;) end;
      </programlisting>

      <para>
	To allow other libraries to add methods to a generic function,
	use a similar syntax:
      </para>

      <programlisting>
define open generic sample-function( o :: &object; ) =&gt; ();
      </programlisting>

      <para>
	A third form, <literal>define inert domain</literal>, partially
	seals a generic function, disallowing only some additions from outside
	a library.
      </para>

      <para>
	For more information on sealing, see the chapter
	<quote>Controlling Dynamism</quote> in the &drm;.
      </para>
    </sect1>
  </chapter>


  <!-- ==================== Chapter 7 ==================== -->

  <chapter id="conditions">
    <title>Conditions</title>

    <para>
      Dylan offers sophisticated exception handling, allowing programs
      to recover smoothly from error conditions. Like &cpp;, Dylan represents
      errors with objects. Dylan also supports advisory warnings and
      potentially correctable errors.
    </para>

    <para>
      When something unusual happens, a program can <glossterm>signal
      </glossterm> a <glossterm>condition</glossterm>. <glossterm>Handlers
      </glossterm> specify how to react to various sorts of conditions.
    </para>

    <sect1 id="blocks">
      <title>Blocks</title>

      <para>
	A <glossterm>block</glossterm> is a group of statements. As with
	other control structures, it may return a value. A simple block
	might appear as follows:
      </para>

      <programlisting>
block ()
  1 + 1;
end; // returns 2
      </programlisting>

      <para>
	Blocks also support non-local exits. These allow a block to exit at
	any time, optionally returning a value. In some ways, they are
	similar to <literal>goto</literal> statements or the <acronym>
	POSIX</acronym> <function>longjmp</function> function. To use them,
	specify a name in the parentheses following a <literal>block
	</literal> statement. Dylan binds this name to an <glossterm>exit 
	function</glossterm> which can be called from anywhere within the
	block or the functions it calls. The following block returns either
	<literal>"Weird!"</literal> or <literal>"All's well."</literal>,
	depending on the color of the sky.
      </para>

      <programlisting>
block (finished)
  if (sky-is-green())
    finished("Weird!");
  end;
  "All's well."
end block;
      </programlisting>

      <para>
	Many programs need to dispose of resources or perform other cleanup
	work, regardless of how a block is exited. Blocks may contain
	an optional <literal>cleanup</literal> clause, which doesn't affect
	the return value of the block and will always be executed.
      </para>

      <programlisting>
let fd = open-input-file();
block (return)
  let (errorcode, data) = read-data(fd);
  if (errorcode)
    return(errorcode);
  end if;
  process-data(data);
cleanup
  close(fd);
end;
      </programlisting>

    </sect1>
  </chapter>
</book>

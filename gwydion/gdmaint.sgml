<!DOCTYPE BOOK PUBLIC "UNREGISTERED::Eric Kidd//DTD DylanDoc V3.1//EN" [
 <!ENTITY % entities SYSTEM "dylandoc.ent">
 %entities;

 <!ENTITY base-lib
   '<link linkend="gdmaint-d2c-base"><dlibrary>Compiler-Base</dlibrary>
    library</link>' >
 <!ENTITY parser-lib
   '<link linkend="gdmaint-d2c-parser"><dlibrary>Compiler-Parser</dlibrary>
    library</link>' >
 <!ENTITY convert-lib
   '<link linkend="gdmaint-d2c-convert"><dlibrary>Compiler-Convert</dlibrary>
    library</link>' >
 <!ENTITY front-lib
   '<link linkend="gdmaint-d2c-front"><dlibrary>Compiler-Front</dlibrary>
    library</link>' >
 <!ENTITY optimize-lib
   '<link linkend="gdmaint-d2c-optimize"><dlibrary>Compiler-Optimize</dlibrary>
    library</link>' >
 <!ENTITY cback-lib
   '<link linkend="gdmaint-d2c-cback"><dlibrary>Compiler-CBack</dlibrary>
    library</link>' >
 <!ENTITY main-lib
   '<link linkend="gdmaint-d2c-main"><dlibrary>Compiler-Main</dlibrary>
    library</link>' >

 <!ENTITY load-state-param '
  <param>
   <paramname>state</paramname>
   <paramtype>&lt;load-state&gt;</paramtype>
  </param>'>
]>
<BOOK id="gdmaint">
  <title>Gwydion Dylan Porting and Maintenance Guide</title>
  <titleabbrev>Maintenance Guide</titleabbrev>

  <bookinfo>
    <COPYRIGHT>
      <YEAR>1998</YEAR>
	<YEAR>1999</YEAR>
	<YEAR>2000</YEAR>
	<YEAR>2001</YEAR>
	<YEAR>2002</YEAR>
      <HOLDER>Carnegie Mellon University</HOLDER>
      <HOLDER>Gwydion Dylan Maintainers</HOLDER>
    </COPYRIGHT>
    &cmu.terms;
    <bookbiblio>
      <date>11 July 2001</date>
      <editor>&person.housel;</editor>
      <editor>&person.emk;</editor>
	<editor>&person.auclair;</editor>
    </bookbiblio>
  </bookinfo>

  <CHAPTER id="gdmaint-introduction">
    <TITLE>Introduction</TITLE>

    <PARA>This manual serves as a guide to porting and maintaining
    Gywdion &dylan;. It includes:</PARA>

    <ITEMIZEDLIST>
      <LISTITEM>
	<PARA>Suggestions for working with other Gwydion developers.</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>Guidelines for porting &mindy; and &d2c; to new platforms</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>An overview of the &mindy; interpreter</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>A detailed guide to the internals of the &d2c; compiler</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>A guide to the internals of the
	<COMMAND>melange</COMMAND> interface generator</PARA>
      </LISTITEM>

      <LISTITEM>
	<PARA>An appendix containing the Gwydion Project coding
	guidelines.</PARA>
      </LISTITEM>
    </ITEMIZEDLIST>

  </CHAPTER>

  <chapter id="gdmaint-conventions">
    <docinfo><author>&person.emk;</author></docinfo>
    <title>Development Conventions</title>
    
    <note>
      <para>None of the advice contained in this chapter is binding.
      However, an attempt has been made to accurately represent the working
      style and informal rules followed by the current developers.</para>

      <para>If you think that this chapter does not represent the way we
      work, please tell me and I'll fix it. It's a
      <quote>descriptive</quote> document, not <quote>prescriptive</quote>
      one.</para>
    </note>

    <para>Gwydion Dylan was originally developed by the Gwydion Project at
    CMU. Today, it is maintained by a loose group of volunteers, some of
    whom have been working on it for over a year. This chapter attempts to
    summarize the way we do things.</para>

    <sect1 id="gdmaint-conventions-principles">
      <title>Basic Principles</title>

      <para>We try to follow a few basic principles:</para>

      <itemizedlist>
	<listitem>
	  <formalpara>
	    <title>Decisions are made by consensus</title>

            <para>In general, we make an effort to discuss tricky problems
	    until all the major contributors agree. This is similar to the
	    <acronym>IETF</acronym>'s philosophy of <quote>rough consensus
	    and running code</quote>. If you think a decision is wrong,
	    explain your viewpoint carefully and be prepared to back it up
	    with code. Use the magic phrase often: <quote>Does anybody
	    object to this?</quote></para>
	  </formalpara>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>Final rulings are made by the core team</title>

	    <para>The core team consists of the most prolific Gwydion
      	    developers and those who have been involved the longest. If the
      	    other contributors would feel guilty about making a decision
      	    without considering your opinion, you're effectively a member
      	    of the core team.</para>
	  </formalpara>

	  <para>Decisions within the core team should be made by unanimous
	  consent whenever possible. This seems to have worked well enough
	  historically. If this process ever breaks down in the future, the
	  core team might choose to vote as measure of last resort.</para>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>No due dates</title>
	    
	    <para>As a matter of policy, we do not promise completion dates
	    to outside entities. This is because of the volunteer nature of
	    the project and the traditional unreliablity of software
	    estimation. Of course, individuals may promise due dates of
	    their own, but nobody else will take responsibility for meeting
	    those dates.</para>
	  </formalpara>
	</listitem>
	<listitem>
	  <formalpara>
	    <title>Don't bite off more than you can chew</title>

	    <para>Work on one or two projects at a time. Don't commit to
	    implementing many separate libraries or fixing many separate
	    bugs. By <quote>reserving</quote> too many areas, you
	    effectively discourage others from working on them.</para>
	  </formalpara>
	</listitem>
      </itemizedlist>
    </sect1>

    <sect1 id="gdmaint-conventions-cvs">
      <title>CVS Suggestions</title>

      <para>The source in CVS should always work correctly. Those who break
      the build will be tickled with feathers or suffer a similar
      fate. Always, always, always test your code before committing it. For
      compiler changes, you should at least run the test suites in
      <filename>gd/src/tests</filename> as a smoke test. Also, a full
      bootstrap cycle is strongly recommended before commiting more
      complicated changes.</para>
    </sect1>
  </chapter>

  <CHAPTER id="gdmaint-porting">
    <TITLE>Porting Gwydion Dylan to a New Platform</TITLE>

    <PARA>Here's a rough overview of how to port &d2c;. Take this with a
    grain of salt; the rules change occasionally.</PARA>

    <itemizedlist>
      <listitem>
	<para>Add your platform to the <filename>platforms.descr</filename>
	file and <filename>configure.in</filename>. This will require a bit
	of delibrate research.</para>
      </listitem>
      <listitem>
	<para>Look in other places, such as the various
	<filename>Makegen</filename> files and platform-specific Melange
	code. Do something intelligent.</para>
      </listitem>
      <listitem>
	<para>Make sure that the Boehm GC runs on your platform. If not,
	you need to talk to the Boehm list.</para>
      </listitem>
      <listitem>
	<para>Run <command>configure</command> with the flag
	<literal>--enable-mindy-bootstrap</literal>, then run
	<command>make</command>. Be prepared to wait, and be ready to fix
	any bugs you encounter.</para>
      </listitem>
      <listitem>
	<para>Gripe to <email>gd-hackers@gwydiondylan.org</email> when it
	breaks. We'll help you sort out the mess.</para>
      </listitem>
    </itemizedlist>

    <para>The more your platform looks like a 32-bit Unix system with the
    GNU tools, the easier things will be. Supporting 64-bit platforms is a
    minor project requiring a number of changes to &d2c; (Mindy already
    works on Alpha Linux, thanks to the efforts of Jeff Dubrule). Windows
    support has been broken slightly since the 2.0 days, but most of the
    problems are in the build system, not the source itself.</para>

    <para>Macintoshes, vendor C compilers and other such oddities are the
    responsibility of those who use them. We'll be happy to help, but
    you'll probably need to find a significant number of dedicated
    volunteers to help you fix any problems you encounter.</para>
  </CHAPTER>

  <CHAPTER id="gdmaint-mindy-internals">
    <TITLE>Mindy Internals Guide</TITLE>

    <PARA>Relatively little has been written down about the internal
    workings of Mindy. Interested parties are encouraged to submit a
    chapter for this manual.</PARA>
  </CHAPTER>

  <chapter id="gdmaint-d2c-internals">
    <docinfo><author>&person.emk;</author></docinfo>
    <title>&d2c; Internals Guide</title>

    <para>The &d2c; compiler was developed by the Gwydion Project at
    CMU. This chapter explains the structure of &d2c; and gives a brief
    overview of how the various components interact.</para>

    <para>&d2c; compiles one library at a time. Each library contains one
    or more modules. A module may be implemented by one or more files. Each
    file contains one or more <glossterm>source records</glossterm>, the
    logical unit of Dylan compilation.</para>

    <para>By compiling many source records at once, &d2c; produces more
    efficient code at the cost of using more memory. In addition to
    processing an entire library's worth of source records, &d2c; also
    performs interlibrary optimizations by looking at certain information
    from previously compiled libraries.</para>

    <para>In its current configuration, &d2c; is not well-suited to
    developing new Dylan code. It is, however, well-suited to building
    production versions of libraries. Obvious future projects include
    reducing the granularity of compilation and implementing a
    selectively-incremental compiler that can modify the object code of a
    running program. The basic architecture was designed with these
    projects in mind.</para>

    <para>The actual compilation process procedes roughly as
    follows:</para>

    <itemizedlist>
      <listitem>
	<formalpara>
	  <title>Load any libraries used by the current library</title>

	  <para>The compiler begins by reading in the
	  <filename>*.lib.du</filename> file for the
	  <dlibrary>Dylan</dlibrary> library. As other libraries are
	  <dlit>use</dlit>d, it loads the appropriate
	  <filename>*.lib.du</filename> files. These contain most of the
	  compiler data structures from the original versions of those
	  libraries.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Parse and macro-expand each of the input files</title>

	  <para>The parser is implemented by the &parser-lib;. As each
          top-level form gets parsed, it is passed to
          <dname>process-top-level-form</dname>, which is implemented by
          the &convert-lib;. At the end of this stage, the input files have
          been completely parsed and macro-expanded.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Finalize the top-level forms</title>

	  <para>Top-level forms may contain forward dependencies within a
	  module. In most cases, these dependencies aren't necessitated by
	  the design of the Dylan language, but they are needed for for
	  efficient compilation. We need to study these dependencies if we
	  want to make incremental compilation work. The implementation of
	  <dname>finalize-top-level-form</dname> lives in
	  &convert-lib;.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Process the class hierarchy</title>

	  <para>Optimizing Dylan code requires careful attention to the
	  object model. Unfortunately, &d2c; uses algorithms which require
	  the entire class hiearchy to be computed before link time. (The
	  biggest problem here appear to be assigning unique IDs to
	  individual classes.) The code to analyze the class hierachy lives
	  in the <link
	  linkend="gdmaint-d2c-base-classes"><dmodule>Classes</dmodule>
	  module</link> of the &base-lib;.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Begin processing top-level definitions
	  individually</title>

	  <para>Up until this point, &d2c; performed each step on the
	  entire library before continuing. The next several steps,
	  however, are completed for each top-level form before moving on
	  to the next top-level form. This process is controlled by
	  <dname>compile-1-tlf</dname> in the &main-lib;</para>
	</formalpara>

	<itemizedlist>
	  <listitem>
	    <formalpara>
	      <title>Convert the parse tree into the front-end
              representation</title>

	      <para>For various unfortunate reasons, &d2c; uses the term
	      <glossterm>front-end representation</glossterm>
	      (<acronym>FER</acronym>) for what other compilers call the
	      <glossterm>intermediate representation</glossterm>. The
	      conversion process is controlled by methods on
	      <dname>convert-top-level-form</dname> provided by the
	      &convert-lib;. These take the parsed representation of a
	      top-level form and convert it to the <acronym>FER</acronym>
	      using the the <link
	      linkend="gdmaint-d2c-front-builder-interface">
	      <dmodule>Builder-Interface</dmodule> module</link>.</para>
	    </formalpara>
	  </listitem>
	  <listitem>
	    <formalpara>
	      <title>Optimize the FER of each top-level form</title>

	      <para>The compiler performs two kinds of optimizations:
	      <glossterm>simplications</glossterm> and required
	      optimizations. The simplications should produce output
	      equivalent to their input. The required optimizations,
	      however, clean up certain artifacts in the code and insert
	      type checks. It is an error to pass a top-level form to the
	      back end before performing the required optimizations. See
	      <xref linkend="gdmaint-d2c-optimize"> for more
	      details.</para>
	    </formalpara>
	  </listitem>
	  <listitem>
	    <formalpara>
	      <title>Emit C code for the FER of each top-level form</title>

	      <para>The &cback-lib; emits the actual C code required to
	      implement each top-level form.</para>
	    </formalpara>
	  </listitem>
	</itemizedlist>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Dump the local and global heaps</title>

	  <para>Each library has a local heap which gets linked into the
	  library itself. This contains as much static data as
	  possible. However, not all data can safely live here; some must
	  live in the executable application. The per-library heap is
	  called the <glossterm>local heap</glossterm> and the
	  per-application heap is called the <glossterm>global
	  heap</glossterm>. The latter is only dumped if the current
	  library will become an executable application. Both dumpers are
	  implemented by the <link linkend="gdmaint-d2c-cback-heap">
          <dmodule>Heap</dmodule> module</link>.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Save a <filename>*.lib.du</filename> file for the current
	  library if necessary</title>

	  <para>If &d2c; is not compiling an executable application, it
	  dumps the data structures used by this library into a
	  <filename>*.lib.du</filename> file. If another Dylan library
	  includes this library, the dumped data structures will be used to
	  perform inter-library optimizations. The dumped data is stored as
	  persistent objects in <glossterm>Object Description
	  Format</glossterm> (<acronym>ODF</acronym>). The dumping process
	  is controlled by the &main-lib;. <acronym>ODF</acronym> is
	  implemented by the <link
	  linkend="gdmaint-d2c-base-od-format"><dmodule>OD-Format</dmodule>
	  module</link>.</para>
	</formalpara>
      </listitem>
      <listitem>
	<formalpara>
	  <title>Generate a Makefile and run the C compiler</title>
	  
	  <para>The compilation driver in the &main-lib; creates a Makefile
	  and C source files as needed during the compilation process. Once
	  all the necessary code has been generated and the heaps are
	  built, &d2c; invokes <acronym>GNU</acronym>
	  <command>make</command> on the Makefile.</para>
	</formalpara>
      </listitem>
    </itemizedlist>
    
    <sect1 id="gdmaint-d2c-base">
      <title>The &base-lib;</title>
      
      <para>The &base-lib; exports the
      basic data structures used by the compiler. It also provides a number
      of miscellaneous utility modules. Every other library relies on
      &base-lib;.</para>
      
      <sect2 id="gdmaint-d2c-base-miscellaneous">
	<title>Miscellaneous Utility Modules</title>
	
	<para>Several modules in &base-lib; appear
	to contain assorted utility routines used elsewhere in the
	compiler.</para>
	
	<variablelist>
	  <varlistentry>
	    <term><dmodule>Common</dmodule></term>
	    <listitem>
	      <para>This module imports a number of standard modules and
	      re-exports some or all of their constants. Essentially, this
	      module is used to specify a local Dylan dialect for use by
	      the rest of the compiler. It includes
	      <dmodule>Dylan</dmodule>, some of
	      <dmodule>Extensions</dmodule>, a few names from
	      <dmodule>Table-Extensions</dmodule> and several of the
	      <abbrev>I/O</abbrev>-related modules.  </para>
	    </listitem>
	  </varlistentry>
	  <!-- this description no longer applies; DMA varlistentry>
	    <term><dmodule>File-System</dmodule></term>
	    <listitem>
	      <para>This module provides a local implementation of parts of
	      the <dlibrary>File-System</dlibrary> library. We can't
	      replace this with the standard implementation without
	      breaking the ability to bootstrap &d2c; with existing version
	      2.2.0 binaries.</para>
	    </listitem>
	  </varlistentry -->
	  <varlistentry>
	    <term><dmodule>Utils</dmodule></term>
	    <listitem>
	      <para>This appears to be the <quote>grab bag</quote>
	      module. It holds a mix of completely unrelated minor classes
	      and functions.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect2>

      <sect2 id="gdmaint-d2c-base-od-format">
	 <!-- docinfo>
	  <title>OD-Format Module</title>
	  <date>July 11, 2001</date>
	  <author><firstname>Nick</firstname><surname>Kramer</surname></author>
	  <editor>&person.auclair;</editor>
	 </docinfo --> <!-- docinfo not allowed for sect2 tag -->
	 <title>The <dmodule>OD-Format</dmodule> Module</title>
	  <sect3 id="gdmaint-d2c-base-od-format-intro">
	   <title>Introduction</title>

	   <para>The <dmodule>OD-Format</dmodule> module was designed by Rob 
	    MacLachlan and implements the <glossterm>Object
	    Description Format</glossterm>, a binary format for
	    storing persistent objects. This is used by the
	    <filename>*.lib.du</filename> files emitted by &d2c;,
	    though it might be potentially useful elsewhere.</para>

	   <para>The file
	   <filename>gd/src/d2c/compiler/base/od-format.dylan</filename> 
	   contains an extensive discussion the module's goals and
	   data format.</para> 

         <para>The basic requirement of the "Object Description Format"
          (ODF) is to allow an open-ended variety of objects to be dumped
          into a file, where:</para>

	   <itemizedlist>
	    <listitem>
	      <para>instances may refer to each other in an arbitrary graph
	      structure, and</para>
	    </listitem>
	    <listitem>
	      <para>some of the references may be to objects that are
              defined in distinct object description units (files,
              etc.)</para>
	    </listitem>
	   </itemizedlist>

	   <para>In order to make the design interesting, the ODF attempts
          to satisfy various incompatible requirements:</para>

	   <itemizedlist>
	    <listitem>
	      <para>To support efficient parsing and unparsing on a variety
              of architectures, but also to potentially serve as a
              cross-platform interchange format.</para>
	    </listitem>
	    <listitem>
	      <para>To work well on sequential media (like a socket), but
              also to potentially support random-access demand-loading of
              objects when possible (e.g. on files.)</para>
	    </listitem>
	   </itemizedlist>

	   <para>We should consider making this into a standalone library at
	    some point in the future.</para>
 	  </sect3>

	  <sect3 id="gdmaint-d2c-base-od-format-dumping">
	   <title>Dumping Objects</title>

	   <dylanconstantdef>
		<defname>&lt;data-unit-name></defname>
		<defsummary>Things that can be the name of a data
		unit.</defsummary> 
		<defvalue>&lt;symbol></defvalue>
		<defdescription>
		 <para><dname>&lt;data-unit-name></dname> is a
		 <dname>&lt;symbol></dname> because is must be
		 comparible with <dname>\==</dname>.</para> 
		</defdescription>
	   </dylanconstantdef>

	   <dylanconstantdef>
 	    <defname>$library-summary-unit-type</defname>
	    <defsummary>A constant for
		<dname>begin-dumping</dname></defsummary> 
		<defvalue>0</defvalue>
		<defdescription>
		 <para>This is currently the only type of OD format
		 allowed.  To build another format (e.g. DOOD), a new
		 exported constant must be added to
		 <dmodule>OD-Format</dmodule> and the file extension
		 must be added to <dname>$unit-type-strings</dname>
		 (an internal constant to
		 <dmodule>OD-Format</dmodule>).</para>
		</defdescription>
	   </dylanconstantdef>

  	   <dylanfunctiondef>
	    <defname>begin-dumping</defname>
	    <defsummary>Returns a dump state used by other OD
	    functions.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>name</paramname>
	        <paramtype>&lt;data-unit-name></paramtype>
		  <ParamSummary>The thing to dump.</paramSummary>
	      </param>
	      <param>
	        <paramname>type</paramname>
	        <paramtype>&lt;integer></paramtype>
		  <paramSummary>The "unit type code"</paramSummary>
	      </param>
	      <keyparam>
	        <paramname>where</paramname>
	        <paramtype>false-or(&lt;string>)</paramtype>
		  <paramdefault>name.&lt;type translation>.du
		  </paramdefault>
		  <paramSummary>Dump file name.</paramSummary>
	      </keyparam>
	    </defparameters>
	    <defreturns>
	     <param>
		<paramname>dump-state</paramname>
		<paramtype>&lt;dump-state></paramtype>
	     </param>
	    </defreturns>
	    <defdescription>
	      <para>Creates a state (which acts very much like a
	      buffer) for other dumping functions to use to build the
	      dump file in memory.  The <dname>end-dumping</dname>
	      function actually writes the built information to file.</para>
	    </defdescription>
	   </dylanfunctiondef>
	   
  	   <dylanfunctiondef>
	    <defname>end-dumping</defname>
	    <defsummary>Flushes the dump state to file.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>state</paramname>
	        <paramtype>&lt;dump-state></paramtype>
	      </param>
	    </defparameters>
	    <defreturns>
	    </defreturns>
	    <defdescription>
	      <para>Actually output the file.</para>
	    </defdescription>
	   </dylanfunctiondef>

  	   <dylangenericdef>
	    <defname>dump-od</defname>
	    <defadjectives>Open</defadjectives>
	    <defsummary>Write an object to the dump buffer.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>object</paramname>
	        <paramtype>&lt;object></paramtype>
	        <paramsummary>The object to dump.</paramsummary>
	      </param>
	      <param>
	        <paramname>buffer</paramname>
	        <paramtype>&lt;dump-buffer></paramtype>
	        <paramsummary>The in-memory buffer into which the object
	        should be dumped.</paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	    </defreturns>
	    <defdescription>
	      <para>This routine is overloaded to dump individual types
	       objects. Methods for primitive Dylan types can be found in
	       <xref linkend="gdmaint-d2c-base-dylan-dump">.</para>
	    </defdescription>
	   </dylangenericdef>
	
	  <dylanclassdef>
	   <defname>&lt;dump-state></defname>
	   <defsummary>Holder of the in-progress object dump.</defsummary>
	   <defsupers><defsuper>&lt;dump-buffer></defsuper></defsupers>
	   <definitkeywords></definitkeywords>
	   <defdescription>
	    <para>Contains all information about the current
	    object-dump in progress.  It is illegal to use a
	    dump-state after it has been passed to
	    <dname>end-dumping</dname>.  All instances of
	    <dname>&lt;dump-state></dname> are created by calls to
	    <dname>begin-dumping</dname>. 
	    </para>
	   </defdescription>
	  </dylanclassdef>
       </sect3>

	 <sect3 id="gdmaint-d2c-base-od-format-loading">
	  <title>Loading Dumped Objects</title>
	
	  <dylanclassdef>
	   <defname>&lt;dispatcher></defname>
	   <defsummary>Binary to in-memory instance transformer.</defsummary>
	   <defsupers><defsuper>&lt;object></defsuper></defsupers>
	   <definitkeywords>
	    <keyparam>
		<paramname>initialize-from</paramname>
		<paramdefault>*default-dispatcher*</paramdefault>
		<paramsummary>Unless &false;, initialize instance's
		dispatch information from this dispatcher.</paramsummary>
	    </keyparam>
	   </definitkeywords>
	   <defdescription>
	    <para>A dispatcher is an object that tells the loader how
	    to convert binary data into Dylan objects. 
	    </para>
	   </defdescription>
	  </dylanclassdef>

	  <dylanvariabledef>
	   <defname>*default-dispatcher*</defname>
	   <defsummary>Default dispatcher used for initialization.</defsummary>
	   <deftype>&lt;dispatcher></deftype>
	   <defdescription>
	    <para><dmodule>Dylan-dump</dmodule> loads this variable
		with dispatching information for several commonly-used
		Dylan types (see <xref linkend="gdmaint-d2c-base-dylan-dump">).
	    </para>
	   </defdescription>
	  </dylanvariabledef>

	  <dylanvariabledef>
	   <defname>*data-unit-search-path*</defname>
	   <defsummary>Paths to du files.</defsummary>
	   <deftype>&lt;sequence></deftype>
	   <defvalue>#[]</defvalue>
	   <defdescription>
	    <para>This is used by <dname>find-data-unit</dname> to
	    locate the du file to load.
	    </para>
	   </defdescription>
	  </dylanvariabledef>

	   <dylanconstantdef>
		<defname>&lt;location-hint></defname>
		<defsummary>A hint of where to find a data unit.</defsummary>
		<defvalue>&lt;byte-string></defvalue>
		<defdescription>
		 <para>This is currently an absolute(?) pathname.</para>
		</defdescription>
	   </dylanconstantdef>

	   <dylanconstantdef>
		<defname>&lt;word></defname>
		<defsummary>A portable, full-sized <dname>&lt;integer></dname>.</defsummary>
		<defvalue>&lt;integer></defvalue>
		<defdescription>
		 <para>It seems mindy has a limited size for <dname>&lt;integer></dname>,
		  so, for mindy, <dname>&lt;word></dname> is a 
		  <dname>&lt;general-integer></dname> to allow for proper bit manipulations
		  that do not clobber the value via overflow.</para>
		</defdescription>
	   </dylanconstantdef>

	  <dylanmethoddef>
	   <defname>find-data-unit</defname>
	   <defsummary>Locates then loads a du file.</defsummary>
	   <defparameters>
	    <param>
		<paramname>name</paramname>
		<paramtype>&lt;data-unit-name></paramtype>
	    </param>
	    <param>
		<paramname>type</paramname>
		<paramtype>&lt;integer></paramtype>
		<paramsummary>(Currently only
		<dname>$library-summary-unit-type</dname> 
		  allowed).</paramsummary>
	    </param>
	    <keyparam>
		<paramname>location-hint</paramname>
		<paramtype>false-or(&lt;location-hint>)</paramtype>
		<paramsummary>File name for the dump file; used if the data unit cannot
		 be found in the current <dname>*data-unit-search-path*</dname>.
		</paramsummary>
	    </keyparam>
	    <keyparam>
		<paramname>check-hash</paramname>
		<paramtype>false-or(&lt;word>)</paramtype>
		<paramsummary>Can be used to detect version mismatches between data units
		  (used internally as <dlit>expected-hash</dlit>)</paramsummary>
	    </keyparam>
	    <keyparam>
		<paramname>dispatcher</paramname>
		<paramtype>&lt;dispatcher></paramtype>
		<paramdefault>*default-dispatcher*</paramdefault>
		<paramsummary>Provides the dispatcher to be used for the loading process.
		</paramsummary>
	    </keyparam>
	   </defparameters>
	   <defreturns>
	    <param>
		<paramname>res</paramname>
		<paramtype>&lt;data-unit></paramtype>
		<paramsummary>Contains the resulting transformed
		objects from the du file. 
		</paramsummary>
	    </param>
	   </defreturns>
	   <defdescription>
	    <para>Find-data-unit, when given a data unit name and
	    type, returns the corresponding data unit.  This is the
	    main entry for causing loading to happen.  Also used
	    recursively.</para> 
	   </defdescription>
	  </dylanmethoddef>
	 </sect3>

       <sect3 id="gdmaint-d2c-base-od-format-defining">
	  <title>Defining Simple Dumpers and Loaders</title>
	  
	  <para>To write a dumper for a class, one needs to think of a
	  name for the class (usually just take the &lt;>'s off the
	  class name), register the name with
	  <dname>register-object-id</dname>, and define a dumper.  If
	  your data structure contains any object sharing or circular
	  usages, also see <xref
	  linkend="gdmaint-d2c-base-od-format-circular"> and <xref
	  linkend="gdmaint-d2c-base-od-format-sharing">.  For
	  automatic generation of object dumpers and loaders, see
	  <xref linkend="gdmaint-d2c-base-od-format-autodump">.</para>
	  

  	   <dylanmethoddef>
	    <defname>register-object-id</defname>
	    <defsummary>Associates a number for a type for the OD
	    dumping functions.
	    </defsummary>
	    <defparameters>
	      <param>
	        <paramname>name</paramname>
	        <paramtype>&lt;symbol></paramtype>
		  <paramsummary>The name of the type.</paramsummary>
	      </param>
	      <param>
	        <paramname>id</paramname>
	        <paramtype>&lt;integer></paramtype>
		  <paramsummary>The associated integral value.</paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	    </defreturns>
	    <defdescription>
		<para>Equate the <dname>name</dname> with the
		<dname>id</dname>.  This function is not exported;
		rather, all  <dname>register-object-id</dname> calls
		must occur in the <dmodule>OD-Format</dmodule>
		module.</para>
		<para>Of course, this requirement makes it really
		tough for extending <dmodule>OD-Format</dmodule> for
		user defined types ...</para> 
	    </defdescription>
	   </dylanmethoddef>

  	   <dylanfunctiondef>
	    <defname>add-od-loader</defname>
	    <defsummary>Register a method for reading a dumped object back
	     into memory.</defsummary>
	    <defparameters>
	      <param>
	        <paramname>dispatcher</paramname>
	        <paramtype>&lt;dispatcher></paramtype>
		<paramsummary>When loading .lib.du files, this is the
		<dname>*default-dispatcher*</dname></paramsummary>
	      </param>
	      <param>
	        <paramname>name</paramname>
	        <paramtype>&lt;symbol></paramtype>
		<paramsummary>The method will be activated when the
		loader encounters the type registered with
		<dname>register-object-id</dname> in the du
		file.</paramsummary>
	      </param>
	      <param>
	        <paramname>func</paramname>
	        <paramtype>&lt;function></paramtype>
		<paramsummary>The loader method.</paramsummary>
	      </param>
	    </defparameters>
	    <defreturns>
	    </defreturns>
	    <defdescription>
	      <para>This function is the <quote>other half</quote> of
	       <dname>dump-od</dname>. It is called to register a function for
	       reloading dumped objects, which has the signature:</para>
<programlisting>
method(state :: &lt;load-state>) => res :: &lt;object-type-read-in></programlisting>
		<para>If you use <dname>add-od-loader</dname>, you
		will need to define a corresponding method on
		<dname>dump-od</dname> (see <xref
		linkend="gdmaint-d2c-base-od-format-dumping">).</para>
	    </defdescription>
	   </dylanfunctiondef>

	   <dylanmethoddef>
	    <defname>add-make-dumper</defname>
	    <defsummary>Convenience method to add both a loader and
	    dumper.</defsummary> 
	    <defparameters>
	     <param>
		<paramname>name</paramname>
		<paramtype>&lt;symbol></paramtype>
		<paramsummary>Type name.</paramsummary>
	     </param>
	     <param>
		<paramname>dispatcher</paramname>
		<paramtype>&lt;dispatcher></paramtype>
		<paramsummary>Where the loader and dumper are being added.</paramsummary>
	     </param>
	     <param>
		<paramname>obj-class</paramname>
		<paramtype>&lt;class></paramtype>
		<paramsummary>Must be the direct class of the instances we
 are to dump (and of course, must also be instantiable via make.)</paramsummary>
	     </param>
		<param>
		 <paramname>slots</paramname>
		 <paramtype>&lt;list></paramtype>
		 <paramsummary>The slots' descriptions of the class.</paramsummary>
		</param>
		<keyparam>
		 <paramname>load-external</paramname>
		 <paramtype>&lt;boolean></paramtype>
		</keyparam>
		<keyparam>
		 <paramname>dumper-only</paramname>
		 <paramtype>&lt;boolean></paramtype>
		 <paramsummary>If &true;, do not create the
		 loader.</paramsummary> 
		</keyparam>
		<keyparam>
		 <paramname>load-side-effect</paramname>
		 <paramtype>false-or(&lt;function>)</paramtype>
		</keyparam>
		<keyparam>
		 <paramname>dump-side-effect</paramname>
		 <paramtype>false-or(&lt;function>)</paramtype>
		</keyparam>
	    </defparameters>
	    <defreturns></defreturns>
	    <defdescription>
		<para>A convenient way to define both a loader and a
		dumper for objects of class <dname>obj-class</dname>.
		<dname>Slots</dname> is a list which is in this
		format:</para> 
<programlisting>
#(slot-accessor-function-1, init-keyword-1, setter-function-1,
  slot-accessor-function-2, init-keyword-2, setter-function-2,
  ...)
</programlisting>
		<para>Note that the stuff is implicitly grouped in
		clumps of 3.  Either of the init-keyword or the setter
		may be &false;, but not both.  The "make dumper"
		requests backpatching when it encounters an unresolved
		forward reference (due to circularities).  Any slot
		which might have a forward reference must have a
		setter function (it can also have an init-keyword,
		which will be used if possible).</para> 

		<para>A "make dumper" may be used when an object can
		be reconstructed from some accessor values by
		reinstatiating the object with <dname>make</dname> and
		backpatching some slots.  This is pretty general,
		since the accessor and setter function are not
		required to be slot accessors and setters. 
		</para>
	    </defdescription>
	   </dylanmethoddef>
       </sect3>

	 <sect3 id="gdmaint-d2c-base-od-format-autodump">
	  <title>Autodump</title>

	  <para>[Description of Autodump coming soon]</para>
	 </sect3>

	 <sect3 id="gdmaint-d2c-base-od-format-representation">
	  <title>ODF Representation of Objects</title>

	  <para>In the dump files, objects contain the following
	  parts:  a header, raw data, sub-objects, and an
	  end-of-object marker.  The header is a single machine word
	  which contains the class of the object.  (Actually, it
	  contains the object-id, which is found by registry look-up.)
	  The header also indicates if there is any raw data and
	  sub-objects.  The raw data section is zero or more machine
	  words which only have meaning to the object's loader.  If
	  raw data is present, it is preceded by a byte-count (which
	  is a single machine word).  If there are sub-objects, they
	  come next.  The last object in a sub-object list is a
	  magical <dname>$end-object</dname>, which denotes both the
	  end of the sub-object list and the last word of the current
	  object. 
	  </para>
	  <para>For more detail on the binary representation and on
	  issues such as endian-ness and machine word size, see <xref
	  linkend="gdmaint-d2c-base-od-format-binary">.</para>

	  <para>When an object is loaded, the loading code reads in
	  the header.  The object class id is extracted from the
	  header.  The dispatcher then provides a load function based
	  on the class id, which reads the remainder of the data
	  associated with the object and returns the reconstructed
	  object.</para> 
	 </sect3>

       <sect3 id="gdmaint-d2c-base-od-format-dumpers">
	<title>Functions for Writing Dumpers</title>
        <para>When adding a method to <dname>dump-od</dname> use the
	methods described here to push out the objects correctly.</para> 

	<dylanmethoddef>
	 <defname>dump-definition-header</defname>
	 <defsummary>Dump an object definition header.</defsummary>
	 <defparameters>
	  <param>
	   <paramname>name</paramname>
	   <paramtype>&lt;symbol></paramtype>
	  </param>
	  <param>
	   <paramname>buf</paramname>
	   <paramtype>&lt;dump-buffer></paramtype>
	   <paramsummary>Probably best to use the
	   <dname>&lt;dump-state></dname> instance passed into
	   <dname>dump-od</dname></paramsummary> 
	  </param>
	  <keyparam>
	   <paramname>subobjects</paramname>
	   <paramdefault>#f</paramdefault>
	   <paramsummary>&true; means this object has subobjects</paramsummary>
	  </keyparam>
	  <keyparam>
	   <paramname>raw-data</paramname>
	   <paramdefault>$odf-no-raw-data-format</paramdefault>
	   <paramsummary>The Raw-Format field in an object-definition
	   header encodes information needed to byte/word format
	   translation, and in the degenerate case, indicates there is
	   no raw data at all.  Allowable format codes are
	    <dname>$odf-no-raw-data-format</dname>, 
	    <dname>$odf-byte-raw-data-format</dname>, 
	    <dname>$odf-16bit-raw-data-format</dname>, 
	    <dname>$odf-32bit-raw-data-format</dname>, 
	    <dname>$odf-64bit-raw-data-format</dname>, 
	    <dname>$odf-untranslatable-raw-data-format</dname>, and 
	    <dname>$odf-word-raw-data-format</dname> (which is 32 or
	    64 as appropriate, used for <dname>&lt;word></dname> in
	    format pseudo-objects).</paramsummary>
	  </keyparam>
	 </defparameters>
	 <defreturns></defreturns>
	 <defdescription>
	  <para>The first dump call in <dname>dump-op</dname> for
	  simple objects, this function dumps the object's header to
	  the buffer.  If one is dumping compound objects, first save
	  the position of the <glossterm>buf</glossterm> before
	  calling this method with some code like this:</para> 
<programlisting>
define method dump-od(obj :: &lt;ratio>, buf :: &lt;dump-state>) => ();
  let start-pos = buf.current-pos;
  dump-definition-header(#"ratio", buf, subobjects: #t);
  dump-od(obj.numerator, buf);
  dump-od(obj.denominator, buf);
  dump-end-entry(start-pos, buf);
end method dump-od;</programlisting>
	  <para>This is necessary so that
	  <dname>dump-end-entry</dname> (see the next documented
	  method) writes out the terminal correctly.</para> 
	 </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	 <defname>dump-end-entry</defname>
	 <defsummary>Dump an "end of object" marker. This is only
	 necessary if there are subobjects.</defsummary> 
	 <defparameters>
	  <param>
	   <paramname>start-posn</paramname>
	   <paramtype>&lt;integer></paramtype>
	   <paramsummary>Where the object began.</paramsummary>
	  </param>
	  <param>
	   <paramname>buf</paramname>
	   <paramtype>&lt;dump-buffer></paramtype>
	   <paramsummary>Usually the <dname>&lt;dump-state></dname> instance
	    passed into <dname>dump-od</dname>.</paramsummary>
	  </param>
	 </defparameters>
	 <defreturns></defreturns>
	 <defdescription>
	  <para>Before dumping the compound object, be sure to save
	  the buffer's current position (as in the sample code for
	  <dname>dump-definition-header</dname>) because this method
	  needs that information.</para> 
	 </defdescription>
	</dylanmethoddef>

	<dylanmethoddef>
	 <defname>dump-simple-object</defname>
	 <defsummary>Dump an object that has only a constant number of
	 subobjects (no raw data).</defsummary> 
	 <defparameters>
	  <param>
	   <paramname>name</paramname>
	   <paramtype>&lt;symbol></paramtype>
	   <paramsummary>The instance's class name.</paramsummary>
	  </param>
	  <param>
	   <paramname>buf</paramname>
	   <paramtype>&lt;dump-buffer></paramtype>
	   <paramsummary>Usually the <dname>&lt;dump-state></dname> instance
	    passed into <dname>dump-od</dname>.</paramsummary>
	  </param>
	  <restparam>
	   <paramname>slots</paramname>
	   <paramsummary>The values of the slots of this object.</paramsummary>
	  </restparam>
	 </defparameters>
	 <defreturns></defreturns>
	 <defdescription>
	  <para>This method provides a simple way to dump objects of
	  known size, so using this method, writing
	  <dname>dump-od</dname> for <dname>&lt;ratio></dname> 
	   would be:</para>
<programlisting>
define method dump-od(obj :: &lt;ratio>, buf :: &lt;dump-state>) => ();
  dump-simple-object(#"ratio", buf, obj.numerator, obj.denominator);
end method dump-od;</programlisting>
	  </defdescription>
	 </dylanmethoddef>

	 <dylanmethoddef>
	  <defname>dump-word</defname>
	  <defsummary>Dump an integer into the buffer as one word.</defsummary>
	  <defparameters>
	   <param>
	    <paramname>obj</paramname>
	    <paramtype>&lt;word></paramtype>
	    <paramsummary>The integer to dump.</paramsummary>
	   </param>
	   <param>
	    <paramname>buf</paramname>
	    <paramtype>&lt;dump-buffer></paramtype>
	   </param>
	  </defparameters>
	  <defreturns></defreturns>
	  <defdescription>
	   <para>This dumps an <dname>&lt;integer></dname> as part of
	   of an object.  If you want to dump an
	   <dname>&lt;integer></dname> as an
	   <dname>&lt;integer></dname>, use the <dname>dump-od</dname>
	   on <dname>&lt;integer></dname> in <xref
	   linkend="gdmaint-d2c-base-dylan-dump">.</para> 
	  </defdescription>
	 </dylanmethoddef>

	 <dylanmethoddef>
	  <defname>dump-raw-data</defname>
	  <defsummary>Dumps a collection into the buffer.</defsummary>
	  <defparameters>
	   <param>
	    <paramname>obj</paramname>
	    <paramtype>&lt;collection></paramtype>
	    <paramsummary>The collection to dump.</paramsummary>
	   </param>
	   <param>
	    <paramname>bsize</paramname>
	    <paramtype>&lt;integer></paramtype>
	    <paramsummary>The number of elements in the
	    collection.</paramsummary> 
	   </param>
	   <param>
	    <paramname>buf</paramname>
	    <paramtype>&lt;dump-buffer></paramtype>
	   </param>
	  </defparameters>
	  <defreturns></defreturns>
	  <defdescription>
	   <para>This take a collection, <glossterm>obj</glossterm>,
	   and dumps its contents to <glossterm>buf</glossterm>.  This
	   method is usually called in connection with dumping a
	   complex object, for example, <dname>dump-od</dname> for
	   <dname>&lt;byte-string></dname> in <xref
	   linkend="gdmaint-d2c-base-dylan-dump"> dumps strings
	   thusly:</para> 
<programlisting>
define method dump-od(obj :: &lt;byte-string>, buf :: &lt;dump-buffer>) => ();
  dump-definition-header(#"byte-string", buf,
  			 raw-data: $odf-byte-raw-data-format);
  dump-raw-data(obj, obj.size, buf);
end method;</programlisting>
          </defdescription>
	 </dylanmethoddef>
       </sect3>

       <sect3 id="gdmaint-d2c-base-od-format-loaders">
	<title>Functions for Writing Loaders</title>

        <para>The basic concept of writing a loader is to read in the
	information you wrote out with the method on
	<dname>dump-od</dname>.  This process (writing loaders) is a
	bit different than writing dumpers, though.  Here, you provide
	a method to <dname>add-od-loader</dname> (described in <xref
	linkend="gdmaint-d2c-base-od-format-defining">) 
	that is activated by a <dname>&lt;dispatcher></dname> instance
	when it encounters the object in the dump file to load.</para>

	<para>A loader on <dname>&lt;byte-string></dname>
	(the corresponding <dname>dump-od</dname> method is found in
	<xref linkend="gdmaint-d2c-base-od-format-dumpers">) would
	look like this:</para>
<programlisting>
add-od-loader(*default-dispatcher*, #"byte-string", 
  method (state :: &lt;load-state>)
   => res :: &lt;byte-string>;
    let next = state.od-next;
    let bsize = buffer-word(state.od-buffer, next);
    state.od-next := next + $word-bytes;
    let res = make(&lt;byte-string>, size: bsize);
    load-raw-data(res, bsize, state);
    res;
  end method
);
</programlisting>
        <para>(In this case, the call to <dname>add-od-loader</dname>
	is made at the top-level in
	<filename>dylan-dump.dylan</filename>.)  The functions used to
	build the dispatch method are described below.
	</para>

	<dylanclassdef>
	  <defname>&lt;load-state></defname>
	  <defsummary>A load-state is an object that describes the
	  current state of the loading process. Among other things, it
	  contains an input &lt;stream> and the buffer to the stream.
	  </defsummary>
	  &obj-super;
	  <definitkeywords>
	   <keyparam>
	    <paramname>stream</paramname>
	    <paramtype>&lt;stream></paramtype>
	    <paramsummary>The stream we're reading from.  Only used
	    for refilling the buffer.  This slot is accessed via the
	    <dname>od-stream</dname> method.</paramsummary>
	   </keyparam>
	   <keyparam>
	    <paramname>buffer</paramname>
	    <paramtype>&lt;buffer></paramtype>
	    <paramsummary>State of the stream buffer, which we hold
	    for the duration of the load.  It is accessed via the
	    <dname>od-buffer</dname> method.</paramsummary>
	   </keyparam>
	   <keyparam>
	    <paramname>next</paramname>
	    <paramtype>&lt;buffer-index></paramtype>
	    <paramsummary>The index of the state's stream; it is
	    accessed via the <dname>od-next</dname> method and 
	    can be set (changed) using the
	    <dname>od-next-setter</dname> method.</paramsummary>
	   </keyparam>
	   <keyparam>
	    <paramname>end</paramname>
	    <paramtype>&lt;buffer-index></paramtype>
	    <paramsummary>The end-index for the buffer and stream.
	    This slot is accessed via the <dname>od-end</dname>
	    method.</paramsummary>
	   </keyparam>
	   <keyparam>
	    <paramname>position-offset</paramname>
	    <paramtype>&lt;integer></paramtype>
	    <paramsummary>When added to the od-next pointer, this
	    offset yields the byte offset of our current position from
	    the data-unit start.  This must be updated whenever we
	    refill the buffer.</paramsummary>
	   </keyparam>
	   <keyparam>
	    <paramname>dispatcher</paramname>
	    <paramtype>&lt;dispatcher></paramtype>
	   </keyparam>
	  </definitkeywords>
	  <defdescription>
	   <para>A <dname>&lt;load-state></dname> object is passed
	   into the dispatching method to reconstruct a dumped
	   object (so, you do not need to <dname>make</dname> a
	   <dname>&lt;load-state></dname> instance).  Use that object
	   in conjuction with the functions described below.</para>
	  </defdescription>
	 </dylanclassdef>

	 <dylanconstantdef>
	  <defname>$end-object</defname>
	  <defsummary>An end-of-subobjects marker.</defsummary>
	  <deftype>&lt;end-object></deftype>
	  <defdescription><para>A magical object which is always the last
	  sub-object in an object.</para></defdescription>
	 </dylanconstantdef>

	 <dylanmethoddef>
	  <defname>load-object-dispatch</defname>
	  <defsummary>Read an object header and invoke the appropriate
	  loader. Return the object that the loader
	  returns.</defsummary>
	  <defparameters>&load-state-param;</defparameters>
	  <defreturns>
	   <param>
	    <paramname>res</paramname>
	    <paramtype>&lt;object></paramtype>
	    <paramsummary>The reconstructed object.</paramsummary>
	   </param>
	  </defreturns>
	  <defdescription>
	   <para>Start loading some objects from a load-state.
	   Dispatches to an appropriate loader method depending on the
	   dispatcher and the entry type.  Returns the object.</para>
	   
	   <para>For example, to load a <dname>&lt;ratio></dname>
	   instance, build a dispatching method like this:</para>
<programlisting>
add-od-loader(*default-dispatcher*, #"ratio", 
  method (state :: &lt;load-state>) => res :: &lt;ratio>;
    
    let npart = load-object-dispatch(state);
    let dpart = load-object-dispatch(state);
    assert-end-object(state);
    ratio(npart, dpart);
  end method
);</programlisting>
	  </defdescription>
	 </dylanmethoddef>

	 <dylanmethoddef>
	  <defname>load-raw-data</defname>
	  <defsummary>Loads data into a parameter.</defsummary>
	  <defparameters>
	   <param>
	    <paramname>res</paramname>
	    <paramtype>&lt;byte-string></paramtype>
	    <paramsummary>A pre-allocated buffer where the raw data
	    gets loaded.</paramsummary>
	   </param>
	   <param>
	    <paramname>elsize</paramname>
	    <paramtype>&lt;integer></paramtype>
	    <paramsummary>Size of the buffer (or the maximum bytes to
	    load).</paramsummary>
	   </param>
	   &load-state-param;
	  </defparameters>
	  <defreturns>
	   <param>
	    <paramname>nnext</paramname>
	    <paramtype>&lt;buffer-index></paramtype>
	    <paramsummary>The position in the
	    <dname>&lt;load-state></dname>'s buffer after loading the
	    raw data.</paramsummary>
	   </param>
	  </defreturns>
	  <defdescription>
	    <para>Loads raw data into <glossterm>res</glossterm>.  It
	    is up to the dispatching method to interpret that loaded
	    raw data in order to reconstruct the object's
	    state.</para>

	    <para>Usually a call to <dname>load-raw-data</dname> is to
	    load a string, so reconstruction is easy (see the example
	    at the top of <link
	    linkend="gdmaint-d2c-base-od-format-loaders">this
	    section</link>).  One thing 
	    of note is that this method is <em>not</em> functional:
	    <dparam>res</dparam> is <em>not</em> returned, but is a
	    destructively modified parameter.</para>
	  </defdescription>
	 </dylanmethoddef>

	 <dylanmethoddef>
	  <defname>load-subobjects-vector</defname>
	  <defsummary>Returns a vector of an object's
	  subobjects.</defsummary>
	  <defparameters>
	   &load-state-param;
	   <param>
	    <paramname>size-hint</paramname>
	    <paramtype>false-or(&lt;integer>)</paramtype>
	    <paramsummary>If a number, then the number of subobjects
	    MUST match.</paramsummary>
	   </param>
	  </defparameters>
	  <defreturns>
	   <param>
	    <paramname>res</paramname>
	    <paramtype>&lt;simple-object-vector></paramtype>
	    <paramsummary>The subobjects of the object.</paramsummary>
	   </param>
	  </defreturns>
	  <defdescription>
	   <para>Loads the dumped subobjects into a vector.  Note that
	   the subobjects may be unresolved when loaded with this
	   function ... it is the responsibility of the user of this
	   function to resolve those objects (see <xref
	   linkend="gdmaint-d2c-base-od-format-circular"> for more
	   information on functions for object resolution such as
	   <dname>obj-resolved?</dname>, <dname>actual-obj</dname>, and
	   <dname>request-backpatch</dname>).</para> 

	   <para>So, getting a <dname>&lt;vector></dname> from this
	   function still requires programming effort, e.g.:</para>
<programlisting>
add-od-loader(*default-dispatcher*, #"simple-object-vector", 
  method (state :: &lt;load-state>) => res :: &lt;simple-object-vector>;
    let contents = load-subobjects-vector(state, #f);
    let rsize = contents.size;
    let res = make(&lt;simple-object-vector>, size: rsize);
    for (i from 0 below rsize)
      let el = contents[i];
      if (el.obj-resolved?)
        res[i] := el.actual-obj;
      else
        res[i] := el;
	request-backpatch(el, method (actual) res[i] := actual end);
      end;
    end;
    res;
  end method
);</programlisting>

           <para>Fortunately, the <dmodule>Dylan-dump</dmodule> module
	   provides this dispatching method.  See <xref
	   linkend="gdmaint-d2c-base-dylan-dump">.</para>
	  </defdescription>
	 </dylanmethoddef>

	 <dylanmethoddef>
	  <defname>load-sole-subobject</defname>
	  <defsummary>Loads the only subobject of this
	  object.</defsummary>
	  <defparameters>&load-state-param;</defparameters>
	  <defreturns>
	   <param>
	    <paramname>res</paramname>
	    <paramtype>&lt;object></paramtype>
	    <paramsummary>The resolved subobject.</paramsummary>
	   </param>
	  </defreturns>
	  <defdescription>
	   <para>Load a one-slot object.  The value is returned, and
	   we check that there was in fact only one subobject.</para>  
	  </defdescription>
	 </dylanmethoddef>

	 <dylanmethoddef>
	  <defname>assert-end-object</defname>
	  <defsummary>Reads from the buffer, and signals an error if
	  the next thing read isn't an end-of-object
	  marker.</defsummary>
	  <defparameters>&load-state-param;</defparameters>
	  &no-returns;
	  <defdescription>
	   <para>Ensure the subobject list ends with the end-of-object
	   token.</para>
	  </defdescription>
	 </dylanmethoddef>
       </sect3>

       <sect3 id="gdmaint-d2c-base-od-format-circular">
	  <title>Circular Usage</title>
        <para>To deal with circular object usage graphs, several
	mechanisms are employed. Objects can be dumped as forward
	references and defined later. The loader for the object
	containing the forward reference has the option of delaying
	object creation until the forward referenced object is loaded,
	or requesting that the object be backpatched when the forward
	referenced object is finally loaded.</para>

	<para>The following descriptions TBD:</para>
	<itemizedlist>
	 <listitem><para>new-local-id</para></listitem>
	 <listitem><para>label-next-object</para></listitem>
	 <listitem><para>dump-local-reference</para></listitem>
	 <listitem><para>&lt;forward-ref></para></listitem>
	 <listitem><para>obj-resolved?</para></listitem>
	 <listitem><para>actual-obj</para></listitem>
	 <listitem><para>request-backpatch</para></listitem>
	 <listitem><para>resolve-forward-ref</para></listitem>
	</itemizedlist>
       </sect3>

       <sect3 id="gdmaint-d2c-base-od-format-sharing">
	  <title>Object Sharing</title>
        <para>By default, it is assumed that the object being dumped
	has no object sharing, i.e., for all sub-objects the ref-count
	is one. For any object that has a ref-count greater than one,
	that object must be a sub-class of
	&lt;identity-preserving-mixin>. (If it is ok to dump the object
	multiple times and load it back as separate objects, then this
	superclass may be omitted.)</para> 

	<para>The following descriptions TBD:</para>
	<itemizedlist>
	 <listitem><para>&lt;identity-preserving-mixin></para></listitem>
	 <listitem><para>maybe-dump-reference</para></listitem>
	</itemizedlist>
       </sect3>

       <sect3 id="gdmaint-d2c-base-od-format-binary">
	<title>Binary Representation</title>

	<para>To allow efficiency as well as potential interchange,
	objects are described by a word sequence which vaguely
	resembles the in-core representation.  The word size is
	implementation defined, and dumper/loader methods dump/load
	data as words having the native byte ordering.  The format is
	defined so that any necessary byte-swapping and word-size
	adjustment can be done as a pre-pass filter to the actual
	loader.  The format is described in detail at the top of
	<filename>od-format.dylan</filename>.</para>

	<para>The implication of the above is that data-unit files
	produced from <dmodule>OD-Format</dmodule> are not portable.</para>

	<sect4 id="gdmaint-d2c-base-od-format-binary-examples">
	 <title>Examples</title>
	 <para>These examples show the bits for some literals,
	 assuming with 32bit word size and big-endian order (which, by
	 the way i386 is not big-endian), and assigning convenient
	 values for the object class-IDs.  See the actual code for the
	 real definitions and class IDs.</para> 

         <para>For example, we could describe a byte-string like this:</para>
<programlisting>
    0: &lt;Header? = #b1, Etype = #b00, Subobjects? = #b0, Raw-Format = #x1,
	Class-ID = byte-string-odf-id>
    1: string byte-count
    2[ceiling(byte-count, word-bytes)]: 
       &lt;string-chars: *></programlisting>

	 <para>Assuming <dname>byte-string-$odf-id</dname> is
	 <dlit>#x666</dlit>, the actual bits for <dname>"Foo"</dname>
	 would be:</para> 
<programlisting>
    #x81000666
    #x00000003
    #x466F6F00</programlisting>

	 <para>A list has subobjects, but no raw data, so it would
	 look like:</para> 
<programlisting>
    0: &lt;Header? = #b1, Etype = #b00, Subobjects? = #b1, Raw-Format = #x0,
        Raw-Size = #x00, Class-ID = list-odf-id>

    1[N]: &lt;header of subobject 0, subobject data>
       ...

    M: &lt;Header? = #b1, Etype = #b01, Start-Offset: * = M></programlisting>

	 <para>If <dname>list-odf-id</dname> were <dlit>#x667</dlit>,
	 then <dlit>#("Foo", "Bar")</dlit> would be:</para> 
<programlisting>
    0: #x90000667
    1: #x81000666
    2: #x00000003
    4: #x466F6F00
    5: #x81000666
    6: #x00000003
    9: #x42617200
    7: #xA0000007</programlisting>

	 <para>This demonstrates the nesting of objects, and shows how
	 the end is marked.  Note that:</para>

	 <itemizedlist>
	  <listitem><para><dlit>"Foo"</dlit> is represented by exactly
	  the same bits here (it is position-independent), and
	  that</para></listitem> 
	  <listitem><para>The entire sequence is position-independent,
	  since the end-entry has a relative offset, and
	  that</para></listitem> 
	  <listitem><para>The basic subobject protocol doesn't say in
	  advance how many subobjects there's going to be; you have to
	  wait for the end header.  This could be avoided for
	  e.g. vectors by considering subobject 0 to be the
	  length.</para></listitem> 
	 </itemizedlist>
	</sect4>

       </sect3>
      </sect2>

      <sect2 id="gdmaint-d2c-base-dylan-dump">
	<title>The <dmodule>Dylan-Dump</dmodule> Module</title>

	<para>This module provides ODF dumping and loading routines for all
	of the primitive types. </para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-compile-time-values">
	<title>The <dmodule>Compile-Time-Values</dmodule> Module</title>

	<para>This module exports <dname>&lt;ct-value></dname>, which
	represents a value known at compile time. It also supplies
	<dname>&lt;literal></dname> and a number of subclasses to represent
	literal strings, integers, lists and other primitive types.</para>

	<para>Other compile time values can be found elsewhere. Literal
	<dname>&lt;type></dname> objects are handled by classes in the
	<link linkend="gdmaint-d2c-base-ctype"><dmodule>CType</dmodule>
	module</link>. Literal <dname>&lt;class></dname> objects are
	handled by classes in the <link
	linkend="gdmaint-d2c-base-classes"><dmodule>Classes</dmodule>
	module</link>. Literal <dname>&lt;function></dname> objects are
	handled by classes in the <link
	linkend="gdmaint-d2c-base-compile-time-functions"><dmodule>Compile
	Time Functions</dmodule> module</link>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-source">
	<title>The <dmodule>Source</dmodule> Module</title>
      
	<para>&d2c; was designed to fetch source records from several
	sources, including flat text files and eventaully code
	databases. To permit this flexibility, &d2c; uses a very abstract
	interface for representing locations in source code.</para>

	<para>The <dname>&lt;source-location></dname> class is an open,
	abstract class with no slots. All instances must provide a method
	for <dname>describe-source-location</dname>.</para>

	<para>The <dname>source-location</dname> generic takes an arbitrary
	object as an argument and returns a source location. The mix-in
	class <dname>&lt;source-location-mixin></dname> provides the
	init-keyword <dlit>source-location:</dlit> and a method on
	<dlit>source-location</dlit> which returns the value of the keyword
	or <dname>&lt;unknown-source-location></dname>.</para>

	<para>The <dname>&lt;source-file></dname> class reads an entire
	input file into memory and provides access to the contents. It's
	tightly-coupled to the class
	<dname>&lt;file-source-location></dname>, which represents a
	location within a source file. Separating these two classes is not
	feasible. Among other things, this code generates the attractive,
	multiline displays of exactly where an error occured.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-tokens">
	<title>The <dmodule>Tokens</dmodule> Module</title>

	<para>This module provides classes and constants for representing
	tokens and syntax tables.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-header">
	<title>The <dmodule>Header</dmodule> Module</title>

	<para>Dylan source files have <acronym>RFC</acronym> 822 headers,
	similar to those used by Internet e-mail and many other
	protocols. This module provides support for parsing headers at the
	top of a file and extracting the values of keywords. White space at
	the begining and ends of lines is removed automatically.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-platform">
	<title>The <dmodule>Platform</dmodule> Module</title>

	<para>This module contains code to parse
	<filename>platforms.descr</filename>, which contains descriptions
	of the various host platforms supported by &d2c;. A description of
	each of the parameters appears in
	<filename>platforms.descr</filename> itself.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-errors">
	<title>The <dmodule>Errors</dmodule> Module</title>

	<para>This module exports a number of classes and functions related
	to compiler errors and warnings.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-signature">
	<title>The <dmodule>Signature-Interface</dmodule> and
	<dmodule>Signature</dmodule> Modules</title>

	<para>The <dmodule>Signature-Interface</dmodule> module creates a
	group of names which are actually implemented in the
	<dmodule>Signature</dmodule> module. These represent the formal
	parameter and result lists of a Dylan function.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-names">
	<title>The <dmodule>Names</dmodule> Module</title>

	<para>When reporting errors, &d2c; often needs to provide names for
	various functions, anonymous local methods and other things found
	in Dylan programs. This module knows about several different kinds
	of names and how they should be displayed to the user.</para>

	<para>It does not appear that these classes are used in as part of
	the compiler's own computations. A quick look suggests that this is
	merely interface and debugging code.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-definitions">
	<title>The <dmodule>Definitions</dmodule> Module</title>

	<comment>I'm not quite sure what this module does, so take this
	description with a grain of salt. Better yet, figure out what this
	module does and fix this documentation.</comment>

	<para>The top-of-file comment for this module reads:</para>

	<blockquote>
	  <para>Abstract class that all definitions inherit from.  A
          definition is the compilers handle on some run-time value.  In
          addition to the obvious things, definitions exist for things
          like the type of a variable (when it isn't a compile-time
          constant).</para>
	</blockquote>

	<para>It appears that named, top-level forms each get a
	definition. From the comment, it sounds as if the following code
	produces two definitions:</para>

	<programlisting>
define variable foo :: run-time-expression() = #f;
</programlisting>

	<para>One definition refers to the variable itself, and the other
	refers to the type value computed at initialization time. Is this a
	correct assumption?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-variables">
	<title>The <dmodule>Variables</dmodule> Module</title>

	<para>This module is in change of libraries, modules and
	namespaces.  It maintains the global table of libraries, processes
	the various clauses in <dlit>define library</dlit> and <dlit>define
	module</dlit>, and keeps track of where variable definitions
	live. The magic <dmodule>Dylan-User</dmodule> modules get set up
	here as well.</para>

	<para>Each <dname>&lt;variable></dname> object also provides slots
	for the associated definition, transformers and constant
	evaluator. It would appear that this module defines some of the
	more important data structures in the compiler.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-policy">
	<title>The <dmodule>Policy</dmodule> Module</title>

	<para>The <dmodule>Policy</dmodule> represents an
	<glossterm>optimization policy</glossterm>: a set of parameters
	used for making tradeoffs between speed, safety and code size. A
	quick inspection of the code shows that a
	<dname>&lt;policy></dname> object will not survive the dumping and
	loading processes intact. Do these actually get used?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-ctype">
	<title>The <dmodule>CType</dmodule> Module</title>

	<comment>Does <dmodule>ctype</dmodule> stand for <quote>constant
	type</quote>, <quote>compile-time type</quote>, or something else
	entirely?</comment>

	<para>This module defines the compiler's type model. This is used
	by the <link
	linkend="gdmaint-d2c-base-flow"><dmodule>Flow</dmodule>
	module</link> to represent the types of expressions, and by the
	&optimize-lib; during several phases of optimization.</para>

	<para>Most of these types can be represented as Dylan objects.
	Such types also inherit from <dname>&lt;ct-value></dname>, so they
	can be represented as compile-time values (see <xref
	linkend="gdmaint-d2c-base-compile-time-values">).</para>

	<para>All ctypes inherit from
	<dname>&lt;values-ctype></dname>. Single-value types (e.g., the
	types of variables) are represented by subclasses of
	<dname>&lt;ctype></dname>.  Multiple-value types (e.g., the return
	values of functions) are represented as instances of
	<dname>&lt;multi-value-ctype></dname>.</para>

	<para>Various subclasses of <dname>&lt;ctype></dname>
	represent class types, union types and all the standard (and
	non-standard) limited types supported by &d2c;. The class
	<dname>&lt;unknown-ctype></dname> represents a type we won't know
	until runtime. The function <dname>empty-type</dname> returns a
	type union with no members. No object can ever be an instance of
	this type. (Empty types are used extensively when computing the
	intersections, unions and differences of types.)</para>

	<para>Class types are defined in the <link
        linkend="gdmaint-d2c-base-classes"><dmodule>Classes</dmodule>
        module</link>.</para>

	<para><dname>&lt;multi-value-ctype></dname> is a bit tricky. It
	represents zero or more required values of known types, zero or
	more optional values of known types, and an optional
	<dlit>#rest</dlit> list&mdash;which may also be typed. (See the
	source for more information.) The function
	<dname>wild-ctype</dname> returns a multi-value type representing
	zero or more values of any type.</para>

	<para>This module supports type intersections, type unions and type
	differences, primarily for use by the optimizer. All of the
	operations may be imprecise; if so, the second return value will
	typically be false.</para>

	<para>The intersection of two types is described as:</para>

	<blockquote>
	  <para>Return as restrictive a type as we can discover that is no
          more restrictive than the intersection of Type1 and Type2.  The
          second value is true if the result is exact.  At worst, we
          arbitrarily return one of the arguments as the first value
          (trying not to return an unknown type).</para>
	</blockquote>

	<para>The union of two types is described as:</para>

	<blockquote>
	  <para>Find a type which includes both types.  The result is an
          unknown type if either of the arguments are unknown; otherwise
          the result is precise.</para>
	</blockquote>
	
	<para>The difference of two types is described as:</para>

	<blockquote>
	  <para>Return our best guess at the type that describes all
          objects that are in Type1 but not in Type2.  If we can't
          precisely determine this type, then return something more
          inclusive than it, but never more inclusive than Type1.</para>
	</blockquote>
	
	<para>Other things in this module include subtype tests, type
	extent computation and type specifiers. The various
	<quote><dlit>-dispatch</dlit></quote> functions have nothing to do
	with the compiler's support for generic functions&mdash;they're
	just hooks for extending various generic functions defined in this
	module.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-transformers">
	<title>The <dmodule>Transformers</dmodule> Module</title>

	<para>Transformers are functions that are attached to function
	definitions. They serve as a sort of procedural macro in the
	optimizer. For instance, the do() function is transformed into
	an ordinary loop construct so the optimizer can bang on it
	some more. See the <dmodule>cheese</dmodule> module for usage
	of this.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-representation">
	<title>The <dmodule>Representation</dmodule> Module</title>

	<para>This module provides a very abstract interface for choosing
	data representations in generated code. It currently appears to be
	implemented by the <link linkend="gdmaint-d2c-base-c-representation">
        <dmodule>C-Representation</dmodule> module</link>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-classes">
	<title>The <dmodule>Classes</dmodule> Module</title>

	<para>This module contains the guts of the class system, which is
	implemented with classes as a subtype of
	<dname>&lt;ctype></dname>. This module also computes class
	precedence lists, unique class IDs and slot layouts.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-type-dump">
	<title>The <dmodule>Type-Dump</dmodule> Module</title>

	<para>This is an implementation module which contains ODF support
	for various subclasses of <dname>&lt;ctype></dname>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-c-representation">
	<title>The <dmodule>C-Representation</dmodule> Module</title>

	<para>This modules knows about the different C data types. It also
	knows about heap representations, direct representations and
	general representations.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-compile-time-functions">
	<title>The <dmodule>Compile-Time-Functions</dmodule> Module</title>

	<para>From the top-of-file comment:</para>

	<blockquote>
	  <para>A ct-function is a kind of compile-time value used to
          represent a function. ct-functions contain various
          linkage-related information needed to call the function, but
          don't reference the FER for the function (e.g. the
          &lt;function-literal>.)  This information is used both by the
          backend and by the heap builder.</para>
	</blockquote>

	<para>This is also where Peter Housel added the support for
	callback functions. This module includes support for
	<glossterm>general entries</glossterm> and <glossterm>generic
	entries</glossterm>, which are presumably the type-checked and
	dispatched entry points for functions, respectively.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-base-flow">
	<title>The <dmodule>Flow</dmodule> Module</title>

	<para>These classes define the <glossterm>flow model</glossterm>
	used by the compiler. Together with the classes defined in the
	<link linkend="gdmaint-d2c-front-front"><dmodule>Front</dmodule>
	module</link>, they make up the <glossterm>intermediate
	representation</glossterm> used to communicate between the
	&convert-lib;, the &front-lib;, the &optimize-lib; and the
	&cback-lib;.</para>

	<para>Unfortunately, the front-end and the back-end of the compiler
	use a slightly different version of the intermediate
	representation. To confuse matters further, both versions are
	called the <quote>front-end representation</quote> (see <xref
	linkend="gdmaint-d2c-front-builder-interface"> for more
	details).</para>
	
	<para>The actual flow model is fairly straightforward. Data-flow
	classes are defined in <filename>data-flow.dylan</filename>, and
	control-flow classes are defined in
	<filename>control-flow.dylan</filename>.</para>

	<para>The data-flow classes represent variables, constants,
	operations and assignments. They use a generalization of the
	traditional three-address form. Expressions are broken down
	into a series of step-by-step assignments to temporary
	variables. The right-hand side of an assignment may contain a
	constant, a variable or a single operation (nesting is not
	allowed). The operation may take any number of arguments, each of
	which must be another variable or a constant.</para>

	<para>When the flow classes are first created, a particular
	variable may be assigned to more than once. The optimizer, however,
	converts all variables to <glossterm>single static
	assignment</glossterm> (<abbrev>SSA</abbrev>) form. In SSA form,
	each variable is given a value at creation time and never
	modified. This restriction simplifies many optimization algorithms
	considerably.</para>

	<para>Prior to SSA conversion, variables are represented by the
	class <dname>&lt;intial-variable></dname>. Each individual
	assignment to a variable is represented as an
	<dname>&lt;initial-definition></dname>. After SSA conversion,
	variables are represented by the class
	<dname>&lt;ssa-variable></dname>.</para>

	<para>The control-flow model represents groups of assignments as
	<glossterm>regions</glossterm>. The simplest kind of region is
	<dname>&lt;simple-region></dname>, which represents a
	linear series of assignments. A
	<dname>&lt;compound-region></dname> holds several regions
	which are executed in sequence. The various subclasses of
	<dname>&lt;join-region></dname> represent control constructs with
	non-linear flow patterns. An <dname>&lt;exit-region></dname>
	transfers control to an enclosing block; various subclasses are
	used to return from functions, exit loops and perform other kinds
	of funky control flow.</para> 

	<para>This part of the compiler is well-commented, so you may want
	to read the source for further details. You'll also want to look at
	the classes defined in <link
	linkend="gdmaint-d2c-front-front"><dmodule>Front</dmodule>
	module</link>, most of which extend the control- and data-flow
	model in various useful ways.</para>

	<para>The classes <dname>&lt;join-operation></dname>,
	<dname>&lt;join-assignment></dname> and
	<dname>&lt;join-region></dname> are currently ignored by the rest
	of the compiler. In each case the word <quote>join</quote> refers
	to the Phi function used in traditional SSA form. These classes
	will be used if anybody ever fixes the optimizer's SSA
	conversion.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-parser">
      <title>The &parser-lib;</title>

      <para>The &parser-lib; handles lexical analysis, parsing and
      macro expansion. It relies only on the &base-lib;.</para>

      <sect2 id="gdmaint-d2c-parser-tokenize">
	<title>The <dmodule>Tokenize</dmodule> Module</title>

	<para>This module provides an abstract class
	<dname>&lt;tokenizer></dname> supporting <dname>get-token</dname>,
	<dname>unget-token</dname> and a few other functions.</para>

	<para>For implementations of this interface, see <xref
        linkend="gdmaint-d2c-parser-lexer"> and <xref
        linkend="gdmaint-d2c-parser-fragments">.</para>
      </sect2>
      
      <sect2 id="gdmaint-d2c-parser-source-utilities">
	<title>The <dmodule>Source-Utilities</dmodule> Module</title>

	<para>This module implements a number of subclasses of
	<dname>&lt;source-location></dname> (see <xref
	linkend="gdmaint-d2c-base-source"> for details) that are used to
	represent the source of tokens during macro expansion.</para>

	<para>There may be slightly more to this module than is apparent at
	first glance.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-lexer">
	<title>The <dmodule>Lexer</dmodule> Module</title>

	<para>This module provides <dname>&lt;lexer></dname>, a subclass of
	<dname>&lt;tokenizer></dname> used to get tokens from a source
	record.</para>
      </sect2>
      
      <sect2 id="gdmaint-d2c-parser-fragments">
	<title>The <dmodule>Fragments</dmodule> Module</title>

	<para>Fragments are the input to and output from macro
	expansion. According to the top-of-file comment:</para>

	<blockquote>
	  <para>The DRM says that:</para>

	  <blockquote>
	    <para>The input to, and output from, a macro expansion is a
            fragment, which is a sequence of elementary fragments.  An
            elementary fragment is one of the following:</para>

	    <itemizedlist>
	      <listitem>
		<para>A token: the output of the lexical grammar. ...</para>
	      </listitem>
	      <listitem>
		<para>A bracketed fragment: balanced brackets ( (), [], or
                {} ) enclosing a fragment.</para>
	      </listitem>
	      <listitem>
		<para>A macro-call fragment: a macro call.</para>
	      </listitem>
	      <listitem>
		<para>A parsed fragment: a single unit that is not
                decomposable into its component tokens.  It has been fully
                parsed by the phrase grammar.  A parsed fragment is either
                an expression, a definition, or a local declaration.</para>
	      </listitem>
	    </itemizedlist>
	  </blockquote>

	  <para>So the parser needs to be able to produce fragments, the
          macro expander needs to be able to destructure and reconstruct
          fragments, and then the parser needs to be able to grovel the
          final results.  This file implements all that.</para>
	</blockquote>

	<para>This module also provides
	<dname>&lt;fragment-tokenizer></dname>, a subclass of
	<dname>&lt;tokenizer></dname> used to get tokens from a macro
	fragment.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-parse-tree">
	<title>The <dmodule>Parse-Tree</dmodule> Module</title>

	<para>This module defines the tree representation used by the
	parser and the macro-expander. (It also includes the classes needed
	to represent the contents of a <dlit>define macro</dlit>
	form.)</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-parser">
	<title>The <dmodule>Parser</dmodule> Module</title>

	<para>This modules takes input from a <dname>&lt;tokenizer></dname>
	and generates a parse tree. It looks like the main entry point is
	<dname>parse-source-record</dname>. There are other entry points
	which are called recursively by the macro expander; these parse a
	single production of Dylan's grammar.</para>

	<para>This module defines the generic function
	<dname>process-top-level-form</dname>. It does not, however, define
	any methods. When the parser has found a top-level form, it calls
	<dname>process-top-level-form</dname> and allows other modules to
	take care of the details. This design may have implications for
	multi-threading and code reuse&mdash;it looks like the parser can
	only be used in one way by any given program.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-parser-macros">
	<title>The <dmodule>Macros</dmodule> Module</title>
<!-- Riff on procedural macros played by &person.auclair; -->

	<para>This module implements macro expansion as defined in the
	&drm;. It also provides <dname>&lt;macro-definition></dname> (see
	<xref linkend="gdmaint-d2c-base-definitions">).</para>

	<para>Note that this module only handles those macros which
	expand according to the standard rules. More complicated macros
	are handled elsewhere by procedural expanders. To define a new
	procedural expander, register it using
        <dname>define-procedural-expander</dname> (a method defined in
        this module).  We'll discuss procedural macros as implemented by &d2c;
	in some detail below.</para>
        

        <sect3 id="gdmaint-d2c-parser-macros-procedural">
         <title>Gwydion &dylan; Procedural Macros</title>
	 <para>In this section, I shall use "procedural macro" to mean 
	   "procedural macro as implemented by &gdmp; on &d2c;".  This 
	   special definition contains an implicit caveat:  procedural macros
	   are not defined in the &drm; and are not standardized across &dylan;
	   implementations -- use at your own risk.  Also, discussion on the
	   &gdmp; mailing list has noted that macros defined by the &drm; 
	   (hereinafter referred to as "plain macros") are "Turing-complete"
	   (yes, just as machine language and C are Turing-complete), 
	   which means that &drm; macros can do whatever procedural macros can
	   do; it just may require more effort and creativity on the user of
	   the plain macro definition to do it.  Procedural macros provide the
	   macro writer alternatives to an aim, their lack does not disallow any
	   desired aim.  Those wishing to write &drm;-compliant &dylan; may
	   safely skip this section.</para>

	 <sect4 id="gdmaint-d2c-parser-macros-procedural-intro">
	  <title>An Introduction</title>

          <para>First off, a procedural macro is a macro ... a special kind
           of macro that (explained simply) uses Dylan expressions evaluated
           before expansion time to build a macro-expansion.  Then, like any
	   plain macro, the expansion substitutes fragments matched by the 
           template with the procedural result.  Procedural macros can be more
	   expressive than the macros defined in the &drm;, but this 
	   expressiveness comes at the cost of necessarily more work both 
	   in preparing to write the macro (the bits of support code) and in 
	   actually writing the macro itself. I will use the 
	   <dname>make-if</dname>  procedural macro as defined in
	   <XREF LINKEND="gdmaint-d2c-convert-expanders"> to show how 
	   procedural macros work. 
          </para>

	  <para>Second off, plain macros are straightforward (!) in their
 	   approach to source-code manipulation as compared to procedural 
	   macros.  Plain macros match a pattern in the source code and then
	   substitute that pattern with the (fixed) expansion:  </para>

<programlisting>
source code (with a macro pattern) in
 => expanded source code out</programlisting>

	  <para>Procedural macros give the user programmatic control over the 
	   expansion: </para>
	  
<programlisting>
source code (with a macro pattern) in
 => generate appropriate expansion (programmatically, of course)
  => expanded source code out</programlisting>

	  <para>A procedural macro writer must not only manage issues of 
	   writing plain macros, but must also manage the process of 
	   writing the expansion.  This additional requirement means
	   that writing code that creates a macro expansion is writing code 
	   that manipulates the
	   <glossterm>Front-End Representation</glossterm> (see
	   <XREF LINKEND="gdmaint-d2c-front">), and, as such, is quite 
	   different than writing general-purpose code.  Particularly, the
	   code (method)  that writes the expander must interact with the code 
	   generator engine and feed it things it understands:  
	   <glossterm>fragment</glossterm>s
	   (see <XREF LINKEND="gdmaint-d2c-parser-fragments">).</para>
         </sect4>
         <sect4 id="gdmaint-d2c-parser-macros-procedural-example">
	  <title>An Example</title>
	  <para>Section using <dname>make-if</dname> as an illustration TBD.
	  </para>
	 </sect4>
	 <sect4 id="gdmaint-d2c-parser-macros-procedural-develop">
	  <title>Roll Your Own, With Analysis</title>
	  <para>TBD: here we'll create <dname>avg</dname> from Paul Graham's
	   On Lisp book as a regular macro (from Chris Double) and as a 
	   procedural macro, comparing and contrasting the two styles.</para>
	 </sect4>
	</sect3>

      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-front">
      <title>The &front-lib;</title>

      <para>The &front-lib; is repsonsible
      for processing the <glossterm>Front End Representation</glossterm> of
      a Dylan program. It depends only on the
      &base-lib;.</para>

      <para>Data is passed from the &parser-lib; to the
      &front-lib; by the &convert-lib;.</para>

      <sect2 id="gdmaint-d2c-front-builder-interface">
	<title>The <dmodule>Builder-Interface</dmodule> Module</title>
	
	<para>This module defines an interface which can be used to build
        the <glossterm>front-end representation</glossterm>
        (<acronym>FER</acronym>) of a parsed Dylan program.</para>
	
	<para>Note that this module actually defines two interfaces:
	<dname>&lt;flow-builder></dname>, an abstract interface for
	constructing basic blocks (see <xref
	linkend="gdmaint-d2c-base-flow">); and
	<dname>&lt;fer-builder></dname>, a more specific version of that
	interface which is used to construct the front-end
	representation. It's not apparent that the former, more general
	interface is actually used anywhere else.</para>
	
	<para>This interface is implemented by the <link
	linkend="gdmaint-d2c-front-front"><dmodule>Front</dmodule>
	module</link>.</para>

	<para>The <dname>optimize-component</dname> generic function gets
	implemented by the &optimize-lib;. We need to figure out why it's
	defined here instead of there.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-primitives">
	<title>The <dmodule>Primitives</dmodule> Module</title>

	<para>This module defines the primitive operations which may appear
        in Dylan code.</para>
      </sect2>      

      <sect2 id="gdmaint-d2c-front-front">
	<title>The <dmodule>Front</dmodule> Module</title>

	<para>This module does all the heavy lifting for the front-end of
        the compiler. It's split across a number of source files:</para>

	<variablelist>
	  <varlistentry>
	    <term><filename>front.dylan</filename></term>
	    <listitem>
	      <para>The data structures used in the front-end
	      representation. These extend the classes defined in the <link
              linkend="gdmaint-d2c-base-flow"><dmodule>Flow</dmodule>
              module</link>.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>builder.dylan</filename></term>
	    <listitem>
	      <para>Abstract classes and generic functions for the
	      <dname>&lt;flow-builder></dname> and
	      <dname>&lt;fer-builder></dname> classes.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>fer-builder.dylan</filename></term>
	    <listitem>
	      <para>The actual implementation of the various builders. This
	      seems to be where the actual front-end code lives.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>fer-dump.dylan</filename></term>
	    <listitem>
	      <para>Code for dumping the front-end representation as
	      text.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><filename>clone.dylan</filename></term>
	    <listitem>
	      <para>Code to clone the data structures representing a
	      top-level function. This seems to be used when inlining
	      functions.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>To add a new class to the <acronym>FER</acronym> hiearchy,
	you'll need to add code to the following files:
	<filename>front.dylan</filename>,
	<filename>fer-dump.dylan</filename>,
	<filename>clone.dylan</filename>,
        <filename>fer-od.dylan</filename> and
        <filename>base/od-format.dylan</filename>. If you miss any of these
	spots, things will break in various entertaining ways.
        </para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-fer-od">
	<title>The <dmodule>FER-OD</dmodule> Module</title>

	<para>This module contains code for dumping the front-end
        representation as ODF (see <xref
        linkend="gdmaint-d2c-base-od-format">). Special case is taken to
        make sure that all dumps start with a
        <dname>&lt;function-literal></dname> object; smaller
        components of the front-end representation can not be dumped
        individually.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-function-definitions">
	<title>The <dmodule>Function-Definitions</dmodule> Module</title>

	<para>This module implements various subclasses of
	<dname>&lt;definition></dname> representing functions (see <xref
	linkend="gdmaint-d2c-base-definitions">). Most of the machinery for
	adding methods to a generic function at compile-time lives here, as
	does a good chunk of code related to sealing.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-variable-definitions">
	<title>The <dmodule>Variable-Definitions</dmodule> Module</title>

	<para>This module implements <dname>&lt;variable-definition></dname>.
        It also contains some of the code for handling load-time type
        expressions.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-front-top-level-forms">
	<title>The <dmodule>Top-Level-Forms</dmodule> Module</title>

	<para>This is not a very meaty module. It doesn't make much sense
	in the absence of the &convert-lib;. It does, however, contain a
	few classes for describing the things found at the top level of a
	Dylan file and provides the generic function
	<dname>finalize-top-level-form</dname>, which is called by the
	compilation driver once everything has been parsed.</para>

	<para>This should not be confused with the <link
	linkend="gdmaint-d2c-convert-top-level-expressions">
	<dmodule>Top-Level-Expressions</dmodule> module</link>, which
	instantiates the data structures defined in this module.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-convert">
      <title>The &convert-lib;</title>

      <para>The &convert-lib; acts as an adaptor between the
      &parser-lib; and the &front-lib;.</para>

      <para>As a rule of thumb, the &convert-lib; implements those
      parts of the front end which know about the output of the
      parser.</para>

      <sect2 id="gdmaint-d2c-convert-lexenv">
	<title>The <dmodule>LexEnv</dmodule> Module</title>

	<para>This module implements <glossterm>lexical
	environments</glossterm> (a formal term for <quote>local
	namespaces</quote>). This is the code that associates variable
	names with the correct bindings.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-compile-time-eval">
	<title>The <dmodule>Compile-Time-Eval</dmodule> Module</title>

	<para>This module performs compile-time evaluation of constant
	expressions. It operates on the parsed representation of a Dylan
	program, not the front-end representation.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-expanders">
	<title>The <dmodule>Expanders</dmodule> Module</title>

	<para>This module contains <link
	linkend="gdmaint-d2c-parser-macros">procedural macro
	expanders</link> for basic, built-in macros such as
	<dname>make-if</dname>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-fer-convert">
	<title>The <dmodule>FER-Convert</dmodule> Module</title>

	<para>This module processes chunks of the parse tree and uses the
	<link linkend="gdmaint-d2c-front-builder-interface">
        <dname>&lt;fer-builder></dname></link> to produce the front-end
        representation.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-about-top-level">
	<title>Processing of Top-Level Definitions</title>

	<para>The code to process top-level definitions is spread across
	several libraries. Most of the machinery actually lives here in the
	&convert-lib;.</para>

	<para>Each top-level form must define methods on three generic
	functions:</para>

	<variablelist>
	  <varlistentry>
	    <term><dname>process-top-level-form</dname></term>
	    <listitem>
	      <para>When the parser finishes with a top-level form, it
	      passes the form to this function, which produces the final
	      parse tree and creates an object representing the top-level
              form. (See <xref linkend="gdmaint-d2c-parser-parser">.)</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dname>finalize-top-level-form</dname></term>
	    <listitem>
	      <para>This function is called by the compilation driver when
	      all the top-level forms have been parsed. It's used to
	      implement various kinds of foward references within a
	      module.
              (See <xref linkend="gdmaint-d2c-front-top-level-forms">.)</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><dname>convert-top-level-form</dname></term>
	    <listitem>
	      <para>Once a top-level form has been processed and finalized,
              it can be converted to the appropriate front-end
              representation. Methods on this function use the
              <dname>&lt;fer-builder></dname> interface. (See <xref
	      linkend="gdmaint-d2c-front-top-level-forms"> and <xref
              linkend="gdmaint-d2c-front-builder-interface">.)</para>
	    </listitem>
	  </varlistentry>
	</variablelist>

	<para>Generally speaking, the parsed representation of a built-in
	<dlit>define foo</dlit> form would be named
	<dname>&lt;define-foo-parse></dname>. The object representing the
	top-level form itself would be named
	<dname>&lt;define-foo-tlf></dname>. There's also a
	<dname>&lt;foo-definition></dname> floating around in most cases.
	The relationships between these three representations need to be
	documented.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-macros">
	<title>The <dmodule>Define-Macros</dmodule> Module</title>

	<para>This module handles <dlit>define macro</dlit> forms and
	<glossterm>macro calls</glossterm> which appear at the top
	level.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-conv-define-lib-and-mod">
	<title>The <dmodule>Define-Libraries-and-Modules</dmodule>
	Module</title>

	<para>This module handles <dlit>define library</dlit> and
	<dlit>define module</dlit> forms.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-functions">
	<title>The <dmodule>Define-Functions</dmodule> Module</title>

	<para>This module handles <dlit>define generic</dlit> and
	<dlit>define method</dlit> forms. (<dlit>define function</dlit>
	forms are expanded by a macro defined in the runtime library.) Most
	of the logic for <glossterm>implicit generic functions</glossterm>
	lives here.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-conv-define-const-and-var">
	<title>The <dmodule>Define-Constants-and-Variables</dmodule>
	Module</title>

	<para>This module handles <dlit>define generic</dlit> and
	<dlit>define method</dlit> forms. It also includes code for
	<glossterm>constant methods</glossterm>, which may get used in a
	few strange places. More research is needed here.</para>

	<para>This module contains an alarming number of <quote>shouldn't
	happen</quote> errors. Is this left-over code, safety checks for a
	fragile area of the compiler, or evidence of some fundamental
	confusion about what's going on?</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-define-classes">
	<title>The <dmodule>Define-Classes</dmodule> Module</title>

	<para>This library handles <dlit>define class</dlit> forms. There's
	a lot in here, including <link
	linkend="gdmaint-d2c-base-ctype"><glossterm>ctype</glossterm>
	calculation</link> for classes and creation of getter and setter
	methods. It's not immediately clear how this relates to the code in
	<link linkend="gdmaint-d2c-base-classes">the module
	<dmodule>Classes</dmodule></link>.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-convert-top-level-expressions">
	<title>The <dmodule>Top-Level-Expressions</dmodule> Module</title>

	<para>This module handles actual code appearing at the top
	level. There's also something going on with
	<dname>&lt;magic-interal-primitives-placeholder></dname>, which is
	(of course) excessively magic. If you're the sort of person who
	likes to figure out how magicians do their tricks, feel free to
	figure this out for the rest of us.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-optimize">
      <title>The <dlibrary>Compiler-Optimize</dlibrary> Library</title>

      <para>&d2c; was written as a research project. As such, it contains
      some very sophisticated optimization routines.</para>

      <sect2 id="gdmaint-d2c-optimize-cheese">
	<title>The <dmodule>Cheese</dmodule> Module</title>

	<para>For some unknown reason, all of the optimization code found
	in the compiler is contained in a single module named
	<dmodule>Cheese</dmodule>. Furthermore, this module does not
	actually provide an entrance point for optimizing a chunk of code.
	Instead, it adds methods to the generic function
	<dname>optimize-component</dname>, which is exported by the <link
	linkend="gdmaint-d2c-front-builder-interface">
	<dmodule>Builder-Interface</dmodule> module</link>. This interface
	is somewhat less than amusing.</para>

	<para>This entry-point weirdness has been cleaned up on the
	<literal>OPTIMIZER_HACKING</literal> branch in CVS.</para>

	<para>To study this module, begin by reading the method
	<dname>optimize-component</dname> in the file
	<filename>cheese.dylan</filename>. This routine is described in
	<xref linkend="gdmaint-d2c-optimize-control-flow">.</para>
      </sect2>

      <sect2>
	<title>Data Formats</title>
	
	<para>The optimizer's data structures are defined in a number of
	modules:</para>

	<itemizedlist>
	  <listitem>
	    <formalpara>
	      <title>The type model</title>

	      <para>Because this is a Dylan compiler, the type model is
	      pretty hairy. See <xref linkend="gdmaint-d2c-base-ctype"> and
	      <xref linkend="gdmaint-d2c-base-classes">.</para>
	    </formalpara>
	  </listitem>
	  <listitem>
	    <formalpara>
	      <title>The intermediate representation</title>

	      <para>The optimizer manipulates code in the format defined by
	      the <link
              linkend="gdmaint-d2c-base-flow"><dmodule>Flow</dmodule>
              module</link> and the <link
              linkend="gdmaint-d2c-front-front"><dmodule>Front</dmodule>
              module</link>. In the code, this is is referred to as
	      <acronym>FER</acronym>, which is short for <quote>Front End
	      Representation.</quote></para>
	    </formalpara>

	    <para>The optimizer normally uses the <link
	    linkend="gdmaint-d2c-front-builder-interface">
	    <dmodule>Builder-Interface</dmodule> module</link> to create
	    new <acronym>FER</acronym> structures. If you're familiar with
	    the underlying <acronym>FER</acronym> classes, you can pick up
	    the builder interface as you read through the optimizer. Look
	    for calls to <dname>build-assignment</dname>,
	    <dname>make-unknown-call</dname> and related functions. They're
	    everywhere.</para>
	  </listitem>
	</itemizedlist>

	<para>The optimizer will make a <emphasis>lot</emphasis> more sense
	if you study the documentation and code for these modules
	first.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-optimize-control-flow">
	<title>Control Flow</title>

	<para>The optimizer has two modes: normal mode, and simplification
	mode. Normal mode is called from the driver in &main-lib; to
	optimize top-level functions.  Simplification mode is called from
	several places in &convert-lib; to tidy up newly-defined inline
	functions. This means inline functions get optimized twice: once
	when they're defined, and a second time when they're inlined.</para>

	<para>The optimizer's main entry point is the function
	<dname>optimize-component</dname>. This function contains a weird
	driver loop. The goal of the loop is drain two queues:
	<dlit>component.initial-variables</dlit> and
	<dlit>component.reoptimize-queue</dlit>.</para>

	<para>The <dname>initial-variables</dname> queue is filled by the
	FER builder (and by certain routines in optimize). At first, the
	queue contains all the variables in the component. The optimizer
	drains the queue by passing each variable to the function
	<dname>maybe-convert-to-ssa</dname>.</para>

	<para>The function <dname>maybe-convert-to-ssa</dname> tries to
	convert each variable to <acronym>SSA</acronym> form.
	<acronym>SSA</acronym> variables are <quote>static, single
	assignments</quote>. Each SSA variable is defined by a single
	assignment, and never changes in value. Because the values of these
	variables never change, the optimizer can make lots of useful
	assumptions about them.</para>

	<para>Unfortunaely, <dname>maybe-convert-to-ssa</dname> isn't very
	smart. It only does the most trivial kind of conversion&mdash;it
	changes <dname>&lt;initial-variable></dname>s with one
	<dname>&lt;initial-definition></dname> into
	<dname>&lt;ssa-variable></dname>s. (There are good algorithms for
	SSA conversion which can convert <emphasis>every</emphasis>
	variable. If we need these, check the literature.)</para>

	<para>Once the <dname>initial-variables</dname> queue has been
	drained, the optimizer starts work on the
	<dname>reoptimize-queue</dname>. This queue was initially set up
	during conversion (by the FER builder, I think). It contains
	everything we currently need to optimize.</para>

	<para>The optimizer pops the first item off the front of the queue
	and passes it to the generic function <dname>optimize</dname>. This
	function knows how to do special-purpose optimizations on each
	subclass of <dname>&lt;queueable-mixin></dname>. These subclasses
	include expressions, assignments and certain basic blocks.</para>

	<para>The generic function <dname>optimize</dname> is implemented
	by methods stewn throughout the optimizer. Each of these methods
	knows how to simplify a particular kind of queueable object. The
	method for <dname>&lt;if-region></dname>, for example, checks to
	see if the test condition is a compile-time value, and if so,
	replaces the <dname>&lt;if-region></dname> with the appropriate
	branch. Other methods do compile-time evaluation of primitives,
	dispatch generic functions, and optimize slot access.</para>

	<para>The methods on <dname>optimize</dname> may or may not change
	a particular queueable object. But if a given method
	<emphasis>does</emphasis> make a change, it may open up new
	opportunities to improve various other queueables. So when we
	modify a queueable, we must generally reoptimize everything that
	depends on it.</para>

	<para>To reoptimize depedents, we can't use recursive calls to
	<dname>optimize</dname>. Instead, we must re-insert the dependent
	into the <dname>reoptimize-queue</dname> (remember that?) using the
	function <dname>reoptimize</dname>. If the dependent is already in
	the queue, <dname>reoptimize</dname> does nothing. But if the
	dependent isn't already in the queue, <dname>reoptimize</dname>
	adds it to very front.</para>
	
	<para>Once we've optimized a single queueable, we return to the
	top-level driver. At this point, we have to drain the
	<dname>initial-variables</dname> queue again (which will almost
	always be empty). Once this is done, we pop the next item off of
	<dname>reoptimize-queue</dname> and make another call to
	<dname>optimize</dname>.</para>

	<para>Once both queues are finally empty, the driver can move
	on. It first applies a number of
	<quote>simplifications</quote>&mdash;control-flow cleanups,
	CSE-elimination, and things like that. Any of these simplifications
	might add something to one of our two queues. If this happens, we
	need to drain our queues again and reapply our simplifications from
	the beginning. Fortunately, this backtracking happens very rarely,
	and it doesn't trigger any kind of global reoptimization.</para>
	
	<para>The next step depends on our <dname>simplify-only?</dname>
	argument. If this argument is true, we're doing
	<quote>pre-optimizion</quote> of an inline function, and we should
	stop at this point. But if <dname>simplify-only?</dname> is false,
	we're optimizing a regular function and need to get it ready for
	the back end.</para>

	<para>To prepare a function for the back end, we need to add type
	checks, replace certain <quote>placeholder</quote> queueables, do
	environment analysis to find closure variables, and build the
	external entry points for local functions.</para>

	<para>Each of these stages works like a simplification. It may
	add items to our two queues. If it does, we have to go drain those
	queues, reapply all our simplifications, and so forth.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-optimize-callopt-trans">
	<title>Call Optimization & Transformers</title>

	<para>Dylan, like LISP, uses function calls to represent most
	language operations. Arithmetic oprators are functions. Slot
	getters and setters are functions. Even array access is done using
	functions. Given this, it's clear that the optimizer needs to
	spend a lot of time improving function calls.</para>

	<para>Function calls are represented in <acronym>FER</acronym>
        using subclasses of <dname>&lt;abstract-call></dname>. You can find
        these classes in the file
        <filename>front/front.dylan</filename>. (Go ahead and read the
        comments, they're actually informative.)</para>

	<para>The are three subclasses of
        <dname>&lt;abstract-call></dname>. Each represents a different kind
        of function call. Calls to specific, known methods are represented by
        <dname>&lt;known-call></dname>. Calls to a generic function are
        represented by subclasses of <dname>&lt;general-call></dname>.
        (The most common of these is <dname>&lt;unknown-call></dname>.)
        Calls which are known to be erroneous are represented by
        <dname>&lt;error-call></dname>.</para>

	<para>Most function calls start life as an instance of
	<dname>&lt;unknown-call></dname>. These are processed by the
	<dname>optimize</dname> method for
	<dname>&lt;unknown-call></dname>. (Look in
	<filename>callopt.dylan</filename>.) This method does some
	complicated dispatching. But in several of the most common cases,
	we wind up calling <dname>optimize-generic</dname>.</para>

	<para>The function <dname>optimize-generic</dname> tries two
	different optimization strategies. First, it looks for an
	appropriate <glossterm>transformer</glossterm>. Transformers know
	how to optimize specific generic functions. If no transformer can
	be found, or the transformer declines,
	<dname>optimize-generic</dname> tries to do compile-time dispatch
	instead.  This is done by looking for applicable methods. If
	there's a single applicable method, then we can replace the
	<dname>&lt;general-call></dname> with a
	<dname>&lt;known-call></dname>.</para>

	<para>Simpler optimizations are applied to
	<dname>&lt;known-call></dname>s. But again, it's possible to
	register a transformer. This transformer will be applied to known
	calls with exactly matching function signatures.</para>

	<para>Most of the transformers live in
	<filename>trans.dylan</filename>. There's also some black magic in
	here to handle calls to <dname>instance?</dname> by converting them
	into <dname>&lt;instance?></dname> placeholders, and changing them
	back into real code later, when replacing placeholders. This was
	probably done to hide these calls during simplification
	passes.</para>

      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-cback">
      <title>The <dlibrary>Compiler-CBack</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-CBack</dlibrary> library generates C
      code from the optimized front-end representation of a
      component.</para>

      <sect2 id="gdmaint-d2c-cback-stack-analysis">
	<title>The <dmodule>Stack-Analysis</dmodule> Module</title>

	<para>This module analyzes the stack usage of a function. It's
	relatively straightforward and independent of the rest of the back
	end.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-cback-cback">
	<title>The <dmodule>CBack</dmodule> Module</title>

	<para>This module has two main entry points:
	<dname>emit-tlf-gunk</dname> and <dname>emit-component</dname>. The
	former emits arbitrary C code needed by a given top-level form. The
	latter translates a Dylan function into actual C code.</para>

	<para>The file <filename>cback.dylan</filename> contains more
	documentation about how things work.</para>

	<para>Right now, the back end assumes that the optimizer has been
	run. It's unclear which optimizations can be skipped safely.</para>
      </sect2>

      <sect2 id="gdmaint-d2c-cback-heap">
	<title>The <dmodule>Heap</dmodule> Module</title>

	<para>This module emits local (per library) and global (per
	application) heaps. Extensive documentation can be found in
	<filename>heap.dylan</filename>.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-main">
      <title>The <dlibrary>Compiler-Main</dlibrary> Library</title>

      <para>The <dlibrary>Compiler-Main</dlibrary> library contains the
      actual compilation driver.</para>

      <sect2 id="gdmaint-d2c-main-main">
	<title>The <dmodule>Main</dmodule> Module</title>

	<para>This module provides the command-line interface and
	compilation driver for &d2c;. It's relatively safe to make changes
	here, because they generally don't affect the rest of the
	compiler.</para>
      </sect2>
    </sect1>

    <sect1 id="gdmaint-d2c-dylan">
      <title>The <dlibrary>Dylan</dlibrary> Runtime Library</title>

      <para>The runtime library is strongly dependent on the internal
      workings of &d2c;. A moderate amount of code duplication occurs:
      &d2c; will contain a compile-time version of a function and the
      runtime will contain a fully dynamic version.</para>
    </sect1>
  </chapter>

  <CHAPTER id="gdmaint-melange-internals">
    <TITLE>Melange Internals Guide</TITLE>

    <PARA>Melange is scheduled to be replaced by Pidgin in a future version
    of Gwydion Dylan. Therefore, this section of the guide will eventually
    contain a description of Pidgin and its public APIs.</PARA>
  </CHAPTER>

  <APPENDIX id="gdmaint-style">
    <TITLE>Gwydion Project Coding Style Guide</TITLE>

    <NOTE>
      <PARA>This appendix lists the Dylan language coding style
      guidelines formerly used by the Gwydion Project.</PARA>
    </NOTE>
    
    <PARA>This file lists two broad categories of style issues for
    Dylan.  One category, called "Recommended", contains style points
    to which Gwydion programmers should adhere, as opposed to "must
    adhere".  If someone sometimes, or even always, breaks a
    recommended style point, then others must to be tolerant of that
    deviation.  You must not modify the original author's code purely
    to satisfy an urge to convert the original author's style to your
    own.  The second category, called "Mandated", contains style
    points to which Gwydion programmers must adhere.  If you find
    someone has deviated from a mandated style point, then you may
    convert the code to be the mandated style.</PARA>

    <SECT1 id="gdmaint-style-recommended">
      <TITLE>Recommended</TITLE>

      <SECT2 id="gdmaint-style-indent-level">
	<TITLE>Indent level</TITLE>

	<PARA> You should use a two-space indentation.  Each time code
	needs to be further indented, you should use one indent level,
	which is two spaces.</PARA>
      </SECT2>

      <SECT2 id="gdmaint-style-wrapping-slot-descriptions">
	<TITLE>Indent wrapping slot descriptions</TITLE>

	<PARA>When a slot description wraps to a new line in a "define
        class" form, the extra lines should be indented one extra
        indent level.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-triple-slash-comments">
	<TITLE>Using <LITERAL>///</LITERAL> comments</TITLE>

	<PARA>If you use <LITERAL>///</LITERAL> comments, they should
        only be used between top-level declarations.
        <LITERAL>///</LITERAL> comments can be used for logical page
        headers, inter-function comments, code section introductions
        (logical page headers), etc., for example:</PARA>

	<PROGRAMLISTING>
...
end method;

/// order-espresso -- Method for Exported GF.
///
/// This method orders espresso at carts on the corner when it is
/// raining.  If it is not raining, this method delegates to
/// next-method. 
///
define method order-espresso (vendor :: &lt;outdoor-espresso-cart&gt;,
                              #next next-method)
  => ();
  ...
end method;</PROGRAMLISTING>
	
	<PARA>Many programmers do not like others to use
        <LITERAL>///</LITERAL> comments.  Rob noted that if these are
        only used between top-level declarations, where the
        <LITERAL>///</LITERAL> indicates a comment of wider scope (as
        over a whole definition or logical page), then the Gwydion
        environment should be able to display such comments however
        any particular user wants to see them.</PARA>
      </SECT2>
      <SECT2 id="gdmaint-style-c-comments">
	<TITLE>Using <LITERAL>/* ... */</LITERAL></TITLE>
	
	<PARA>If you use <LITERAL>/* ... */</LITERAL> comments, they
        should only be used at the beginning of a file or the
        beginning of a logical page so that their use is highly
        localized.  This prevents them from showing up surprisingly in
        random places throughout a file of code.  Using
        <LITERAL>/*...*/</LITERAL> comments should go away once the
        Gwydion environment has a means for linking general commentary
        to logical units of code.  This issue has absolutely nothing
        to do with using <LITERAL>/*...*/</LITERAL> to temporarily
        exclude code fragments.</PARA>
      </SECT2>
      <SECT2 id="gdmaint-style-wrapping-function-headers">
	<TITLE>Wrapping function definition headers</TITLE>

	<PARA>When a function header wraps (that is, a <LITERAL>define
	generic</LITERAL> or a <LITERAL>define module</LITERAL>
	declaration), you should either break the line within the
	parameter list or between the name and the parameter list.  If
	you break the line between the name and parameter list, or
	perhaps after the parameter list, then you should indent any
	extra lines one extra indent level.  There is one exception:
	the first line of the return values specification may be
	indented only one space.  The following are examples of
	recommended style:</PARA>

	<PROGRAMLISTING>
define method some-longer-name-for-effect
    (one :: &lt;class-1&gt;, two :: &lt;class-2&gt;, ...)
    => (result1 :: &lt;type1&gt;, result2 :: &lt;type2&gt;);
  statement1;
  statement2;
  ...;
end method;

define method some-longer-name-for-effect
    (one :: &lt;class-1&gt;, two :: &lt;class-2&gt;, ...)
 => (result1 :: &lt;type1&gt;, result2 :: &lt;type2&gt;);
  statement1;
  statement2;
  ...;
end method;</PROGRAMLISTING>
      </SECT2>
      <SECT2 id="gdmaint-style-indent-keyword-parameters">
	<TITLE>Indent keyword parameters beyond
	<LITERAL>#key</LITERAL> token</TITLE>

	<PARA> If there is more than one keyword parameter specified
	in a function declaration, then all keyword parameter
	specifications should line up with the first specification.
	The following is an example:</PARA>
	
	<PROGRAMLISTING>
define method foo (foo :: &lt;simple-object-vector&gt;,
                   #key start :: &lt;fixed-integer&gt; = 0,
		        stop :: &lt;fixed-integer&gt; = foo.size)
  ...</PROGRAMLISTING>
	
	<PARA>If a parameter list that contains a
        <LITERAL>#key</LITERAL> wraps, then you should wrap the
        parameter list before the <LITERAL>#key</LITERAL>
        token.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-indent-varconst">
	<TITLE>Wrapping variable and constant definitions</TITLE>
	
	<PARA>When a variable or constant definition wraps, you should
        break the line before the <LITERAL>=</LITERAL> token:</PARA>
	
	<PROGRAMLISTING>
define constant western-culture :: &lt;integer&gt;
  = north-america-mask | south-america-mask | europe-mask;</PROGRAMLISTING>
      </SECT2>
      
      <SECT2 id="gdmaint-style-end-foo">
	<TITLE>Using <LITERAL>end <PARAMETER>mumble</PARAMETER></LITERAL>
        to terminate statements</TITLE>
	
	<PARA>You should use <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL>, rather than just
	<LITERAL>end</LITERAL>, whenever there is sufficient vertical
	space between the beginning and the end of the statement to
	hinder readability.  Some programmers like to use <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL> religiously, but those
	same programmers only use "end" when using <LITERAL>end
	<PARAMETER>mumble</PARAMETER></LITERAL> would make a
	single-line statement wrap onto a new line.  Programmers may
	add the <LITERAL><PARAMETER>mumble</PARAMETER></LITERAL> to an
	<LITERAL>end</LITERAL> if they feel the code was hard to
	visually scan, but programmers should not add
	<LITERAL><PARAMETER>mumble</PARAMETER></LITERAL>s to all
	<LITERAL>end</LITERAL>s in someone else's code just because
	they like that style.  This policy is consistent with adding
	additional comments to someone else's code to help
	readability.</PARA>
      </SECT2>

      <SECT2 id="gdmaint-style-horizonal">
	<TITLE>Horizontal space for columnization or other visual
	effects</TITLE>

	<PARA>You should NOT use horizontal spacing to columnize
	aspects of Dylan code, or to present other visual effects
	within the program.  If you do this, you should do it rarely.
	The one exception to this rule is the "Indent keyword
	parameters beyond #key token" recommendation.</PARA>
      </SECT2>

      <SECT2 id="gdmaint-style-keyword-syntax">
	<TITLE>Keyword syntax</TITLE>
	
	<PARA> You should only use keyword notation for symbols in
        function calls and function declarations.  You can also use
        keyword notation in slot descriptions within <LITERAL>define
        class</LITERAL>, where you are supplying a symbol to be the
        key for an initialization argument.  When a symbol is a value,
        such as a default value in a declaration or an argument value
        in a call, you should use symbol notation, not keyword
        notation.  The following are examples of recommended
        style:</PARA>

	<PROGRAMLISTING>
define method reposition (stream :: &lt;stream&gt;, offset :: &lt;integer&gt;,
                          #key from: = #"start")


define method foo ()
  ...
  bar(x, y, color: #"red");
  ...
end method;

// In this example, required-init-keyword: would always be in
// keyword notation, and "foo:" is the item to which this style
// recommendation speaks.
//
define class &lt;frob&gt;
  slot gag, required-init-keyword: foo:;
end;
//
// Or ...
//
define class &lt;frob&gt;
  slot gag, required-init-keyword: #"foo";
end;</PROGRAMLISTING>
      </SECT2>

      <SECT2 id="gdmaint-style-blank-lines-before-decls">
	<TITLE>Blank comment line between introductory comments and
	definitions</TITLE>
	
	<PARA> You should include a blank comment line between the
        introductory comments for a function and the function
        definition.  This applies to any top-level declaration for
        which you supply an introductory comment.  The following is an
        example:</PARA>
	
	<PROGRAMLISTING>
// Blah blah blah GINGER blah blah blah.
//
define ...</PROGRAMLISTING>
      </SECT2>
      
      <SECT2 id="gdmaint-style-wrapping-case">
	<TITLE>Wrapping <LITERAL>case</LITERAL> statements (applies to
	<LITERAL>select</LITERAL> too)</TITLE>
	
	<PARA>If any single branch of a <LITERAL>case</LITERAL>
        statement wraps, then you should wrap every branch.  In
        practice, there are common exceptions to this
        recommendation.</PARA>

	<PARA> When wrapping a case statement, you should wrap it
        after the <LITERAL>=></LITERAL> token.  There should be no
        exceptions to this recommendation.</PARA>

	<PARA>	The following exhibit the recommended style:</PARA>

	<PROGRAMLISTING>
case
  test1 => expression1;
  test2 => expression2;
end;

case
  test1 =>
    statement1;
    statement2;
  test2 =>
    statement1;
    statement2;
end;</PROGRAMLISTING>
      </SECT2>

      <SECT2 id="gdmaint-style-otherwise">
	<TITLE>Using <LITERAL>#t</LITERAL> for
	<LITERAL>otherwise</LITERAL> in <LITERAL>case</LITERAL>
	statements</TITLE>
	
	<PARA> You should not use <LITERAL>#t</LITERAL> for
	<LITERAL>otherwise</LITERAL> in <LITERAL>case</LITERAL>
	statements.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-for-clauses">
	<TITLE>Wrapping <LITERAL>for</LITERAL> clauses</TITLE>
	
	<PARA>When an <LITERAL>=</LITERAL>/<LITERAL>then</LITERAL>
        clause needs to wrap, you should wrap before the
        <LITERAL>=</LITERAL> and before the 'then'.  Both the '=' and
        the 'then' should be indented one extra indent level:</PARA>

	<PROGRAMLISTING>
// Correct.
//
... nested levels ...
                 for (some-index
			= initialization-expression(x, y, z)
			then stepper(u, v, w))
	           stuff(some-index);
		 end;

// Incorrect.
//
... nested levels ...
                 for (some-index = initialization-expression(x, y, z)
			then stepper(u, v, w))
		   stuff(some-index);
		 end;</PROGRAMLISTING>
      </SECT2>
    </SECT1>
    
    <SECT1 id="gdmaint-style-mandated">
      <TITLE>Mandated</TITLE>
      
      <SECT2 id="gdmaint-style-open-paren-after-func-def">
	<TITLE>Function name and open paren</TITLE>
	
	<PARA> The <LITERAL>define generic</LITERAL> or
        <LITERAL>define method</LITERAL> declarations must have a
        space or newline between the name of the definition and the
        parameter list.  At any function call site, the name and open
        paren must be adjacent, with no intervening characters.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-wrappping-let">
	<TITLE>Wrapping <LITERAL>let</LITERAL> statements</TITLE>

	<PARA>If a <LITERAL>let</LITERAL> statement wraps, you must
	put the equal sign on a new line and indent it one extra
	indent level.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-semicolons">
	<TITLE>Terminate statements with semicolons</TITLE>

	<PARA>Semicolons are terminators and must appear wherever they
	are optional, except as covered by the "Single-line
	statements" mandate.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-single-line-statements">
	<TITLE>Single-line statements</TITLE>
	
	<PARA> Single-line statement, such as if-else, must not have
        any internal semicolons.  If a single-line statement requires
        an internal semicolon, then you must break the statement into
        multiple lines.  For example, the following would be illegal
        in Gwydion style:</PARA>
	<PROGRAMLISTING>
let x = if (some-test) foo(); 3; else 5; end;
let x = if (some-test) foo(); 3 else 5 end;
let f = method (a, b) foo(); #f; end;</PROGRAMLISTING>
	
	<PARA>These should be formatted as follows (ignoring the
	<LITERAL>end if</LITERAL> issue):</PARA>

	<PROGRAMLISTING>
let x = if (some-test)
   foo();
   3;
 else
   5;
 end;
let f = method (a, b)
   foo();
   #f;
 end;</PROGRAMLISTING>
	
	<PARA> Most programmers felt this rule, by its nature of
        eliminating multiple statements within a block on a single
        line, made code much more readable.</PARA>
      </SECT2>
      
      <SECT2 id="gdmaint-style-wrappping-expr">
	<TITLE>Wrapping arithmetic/boolean expressions</TITLE>
	
	<PARA> You must wrap long expressions before operators and
        indent the operators with one extra indent level from the
        beginning of the expression.  Note, assignments are considered
        to be "statements", and the "expression" that wraps is the
        code on the right-hand side of the assignment operator.
        Therefore, the first two examples below are considered to be
        approved style, but the third is not:</PARA>
	
	<PROGRAMLISTING>
my-local := big-computation(arg1, arg2)
       + another-hairy-long-calculation(arg3, arg4, arg5)
my-local := (big-computation(arg1, arg2)
        + another-hairy-long-calculation(arg3, arg4, arg5))
my-local := big-computation(arg1, arg2)
  + another-hairy-long-calculation(arg3, arg4, arg5)</PROGRAMLISTING>
      </SECT2>
    </SECT1>
  </APPENDIX>
</BOOK>
